<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_r2v_zvy_sp">
  <title id="im148475">Choosing the Table Storage Model</title>
  <body>
    <p>Greenplum Database supports several storage models and a mix of storage models.
      When you create a table, you choose how to store its data. This topic explains the options for
      table storage and how to choose the best storage model for your workload.</p>
    <ul id="ul_wjf_1wy_sp">
      <li id="im168064">
        <xref href="#topic37" type="topic" format="dita"/>
      </li>
      <li id="im211316">
        <xref href="#topic38" type="topic" format="dita"/>
      </li>
      <li id="im168306">
        <xref href="#topic39" type="topic" format="dita"/>
      </li>
      <li id="im168351">
        <xref href="#topic40" type="topic" format="dita"/>
      </li>
      <li id="im168411">
        <xref href="#topic41" type="topic" format="dita"/>
      </li>
      <li>
        <xref href="#topic55" format="dita"/>
      </li>
      <li>
        <xref href="#topic62" format="dita"/>
      </li>
    </ul>
    <note> To simplify the creation of database tables, you can specify the default values for some
      table storage options with the Greenplum Database server configuration parameter
        <codeph>gp_default_storage_options</codeph>. <p>For information about the
        parameter, see "Server Configuration Parameters" in the <cite>Greenplum Database Reference
          Guide</cite>.</p>
    </note>
  </body>
  <topic id="topic37" xml:lang="en">
    <title id="im168000">Heap Storage</title>
    <body>
      <p>By default, Greenplum Database uses the same heap storage model as PostgreSQL. Heap table
        storage works best with OLTP-type workloads where the data is often modified after it is
        initially loaded. <codeph>UPDATE</codeph> and <codeph>DELETE</codeph> operations require
        storing row-level versioning information to ensure reliable database transaction processing.
        Heap tables are best suited for smaller tables, such as dimension tables, that are often
        updated after they are initially loaded.</p>
    </body>
  </topic>
  <topic id="topic38" xml:lang="en">
    <title id="im201394">Append-Optimized Storage</title>
    <body>
      <p>Append-optimized table storage works best with denormalized fact tables in a data warehouse
        environment. Denormalized fact tables are typically the largest tables in the system. Fact
        tables are usually loaded in batches and accessed by read-only queries. Moving large fact
        tables to an append-optimized storage model eliminates the storage overhead of the per-row
        update visibility information, saving about 20 bytes per row. This allows for a leaner and
        easier-to-optimize page structure. The storage model of append-optimized tables is optimized
        for bulk data loading. Single row <codeph>INSERT</codeph> statements are not
        recommended.</p>
      <section id="im168504">
        <title>To create a heap table</title>
        <p>Row-oriented heap tables are the default storage type.</p>
        <p>
          <codeblock>=&gt; CREATE TABLE foo (a int, b text) DISTRIBUTED BY (a);</codeblock>
        </p>
        <title>To create an append-optimized table</title>
        <p>Use the <codeph>WITH</codeph> clause of the <codeph>CREATE TABLE</codeph> command to
          declare the table storage options. The default is to create the table as a regular
          row-oriented heap-storage table. For example, to create an append-optimized table with no
          compression:</p>
        <p>
          <codeblock>=&gt; CREATE TABLE bar (a int, b text) 
    WITH (appendonly=true)
    DISTRIBUTED BY (a);</codeblock>
        </p>
        <p><codeph>UPDATE</codeph> and <codeph>DELETE</codeph> are not allowed on append-optimized
          tables in a serializable transaction and will cause the transaction to abort.
            <codeph>CLUSTER</codeph>, <codeph>DECLARE...FOR UPDATE</codeph>, and triggers are not
          supported with append-optimized tables.</p>
      </section>
    </body>
  </topic>
  <topic id="topic39" xml:lang="en">
    <title id="im168256">Choosing Row or Column-Oriented Storage</title>
    <body>
      <p>Greenplum provides a choice of storage orientation models:
        row, column, or a combination of both. This topic provides general guidelines for choosing
        the optimum storage orientation for a table. Evaluate performance using your own data and
        query workloads.</p>
      <ul id="ul_mtf_1wy_sp">
        <li id="im201450">Row-oriented storage: good for OLTP types of workloads with many iterative
          transactions and many columns of a single row needed all at once, so retrieving is
          efficient.</li>
        <li id="im201471">Column-oriented storage: good for data warehouse workloads with
          aggregations of data computed over a small number of columns, or for single columns that
          require regular updates without modifying other column data.</li>
      </ul>
      <p>For most general purpose or mixed workloads, row-oriented storage offers the best
        combination of flexibility and performance. However, there are use cases where a
        column-oriented storage model provides more efficient I/O and storage. Consider the
        following requirements when deciding on the storage orientation model for a table:</p>
      <ul id="ul_oyf_1wy_sp">
        <li id="im168747"><b>Updates of table data.</b> If you load and update the table data
          frequently, choose a row-oriented<ph> heap</ph> table. <ph
           >Column-oriented table storage is only available on append-optimized
            tables.</ph>
          <p>See <xref href="#topic37" type="topic" format="dita"/> for more
            information.</p></li>
        <li id="im170466"><b>Frequent INSERTs.</b> If rows are frequently inserted into the table,
          consider a row-oriented model. Column-oriented tables are not optimized for write
          operations, as column values for a row must be written to different places on disk.</li>
        <li id="im168960"><b>Number of columns requested in queries.</b> If you typically request
          all or the majority of columns in the <codeph>SELECT</codeph> list or
            <codeph>WHERE</codeph> clause of your queries, consider a row-oriented model.
          Column-oriented tables are best suited to queries that aggregate many values of a single
          column where the <codeph>WHERE</codeph> or <codeph>HAVING</codeph> predicate is also on
          the aggregate column. For
            example:<codeblock>SELECT SUM(salary)...</codeblock><codeblock>SELECT AVG(salary)... WHERE salary &gt; 10000</codeblock><p>Or
            where the <codeph>WHERE</codeph> predicate is on a single column and returns a
            relatively small number of rows. For
          example:</p><codeblock>SELECT salary, dept ... WHERE state='CA'</codeblock></li>
        <li id="im170487"><b>Number of columns in the table.</b> Row-oriented storage is more
          efficient when many columns are required at the same time, or when the row-size of a table
          is relatively small. Column-oriented tables can offer better query performance on tables
          with many columns where you access a small subset of columns in your queries.</li>
        <li id="im168797"><b>Compression.</b> Column data has the same data type, so storage size
          optimizations are available in column-oriented data that are not available in row-oriented
          data. For example, many compression schemes use the similarity of adjacent data to
          compress. However, the greater adjacent compression achieved, the more difficult random
          access can become, as data must be uncompressed to be read.</li>
      </ul>
      <section id="im169305">
        <title>To create a column-oriented table</title>
        <p>The <codeph>WITH</codeph> clause of the <codeph>CREATE TABLE</codeph> command specifies
          the table's storage options. The default is a row-oriented<ph> heap
            table. Tables that use column-oriented storage must be append-optimized tables</ph>. For
          example, to create a column-oriented table:</p>
        <p>
          <codeblock>=&gt; CREATE TABLE bar (a int, b text) 
    WITH (appendonly=true, orientation=column)
    DISTRIBUTED BY (a);
</codeblock>
        </p>
      </section>
    </body>
  </topic>
  <topic id="topic40" xml:lang="en">
    <title id="im168077">Using Compression (Append-Optimized Tables Only)</title>
    <body>
      <p>There are two types of in-database compression available in the Greenplum Database for
        append-optimized tables:</p>
      <ul id="ul_n2g_1wy_sp">
        <li id="im201632">Table-level compression is applied to an entire table. </li>
        <li id="im201672">Column-level compression is applied to a specific column. You can apply
          different column-level compression algorithms to different columns.</li>
      </ul>
      <p>The following table summarizes the available compression algorithms.</p>
      <table id="im198267">
        <title>Compression Algorithms for Append-Optimized Tables</title>
        <tgroup cols="3">
          <colspec colnum="1" colname="col1" colwidth="130pt"/>
          <colspec colnum="2" colname="col2" colwidth="136pt"/>
          <colspec colnum="3" colname="col3" colwidth="110pt"/>
          <thead>
            <row>
              <entry colname="col1">Table Orientation</entry>
              <entry colname="col2">Available Compression Types</entry>
              <entry colname="col3">Supported Algorithms</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="col1">Row</entry>
              <entry colname="col2">Table</entry>
              <entry colname="col3"><codeph>ZLIB</codeph>, <codeph>ZSTD</codeph>, and
                <codeph>QUICKLZ</codeph><sup>1</sup></entry>
            </row>
            <row>
              <entry colname="col1">Column</entry>
              <entry colname="col2">Column and Table</entry>
              <entry colname="col3"><codeph>RLE_TYPE</codeph>, <codeph>ZLIB</codeph>, <codeph>ZSTD</codeph>, and
                  <codeph>QUICKLZ</codeph><sup>1</sup></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <p>
        <note type="note"><sup>1</sup>QuickLZ compression is not available in the open source
          version of Greenplum Database.</note>
      </p>
      <p>When choosing a compression type and level for append-optimized tables, consider these
        factors:</p>
      <ul id="ul_xlg_1wy_sp">
        <li id="im201780">CPU usage. Your segment systems must have the available CPU power to
          compress and uncompress the data.</li>
        <li id="im201781">Compression ratio/disk size. Minimizing disk size is one factor, but also
          consider the time and CPU capacity required to compress and scan data. Find the optimal
          settings for efficiently compressing data without causing excessively long compression
          times or slow scan rates.</li>
        <li id="im201782">Speed of compression. QuickLZ compression generally uses less CPU capacity
          and compresses data faster at a lower compression ratio than zlib. zlib provides higher
          compression ratios at lower speeds. <p>For example, at compression level 1
              (<codeph>compresslevel=1</codeph>), QuickLZ and zlib have comparable compression
            ratios, though at different speeds. Using zlib with <codeph>compresslevel=6</codeph> can
            significantly increase the compression ratio compared to QuickLZ, though with lower
            compression speed. ZStandard compression can provide for either good compression ratio or
	    speed, depending on compression level, or a good compromise on both.  </p></li>
        <li id="im201783">Speed of decompression/scan rate. Performance with compressed
          append-optimized tables depends on hardware, query tuning settings, and other factors.
          Perform comparison testing to determine the actual performance in your
            environment.<note>Do not create compressed append-optimized tables on file systems that
            use compression. If the file system on which your segment data directory resides is a
            compressed file system, your append-optimized table must not use
          compression.</note></li>
      </ul>
      <p>Performance with compressed append-optimized tables depends on hardware, query tuning
        settings, and other factors. You should perform comparison testing to determine
        the actual performance in your environment.</p>
	<note type="note">Zstd compression level can be set to values between 1 and 19.
	QuickLZ compression level can only be set to level 1; no other values are
        available. Compression level with zlib can be set to values from 1 - 9. Compression level
        with RLE can be set to values from 1 - 4.<p>An <codeph>ENCODING</codeph> clause specifies
        compression type and level for individual columns. When an <codeph>ENCODING</codeph>
        clause conflicts with a <codeph>WITH</codeph> clause, the <codeph>ENCODING</codeph> clause
        has higher precedence than the <codeph>WITH</codeph> clause.</p></note>
      <section id="im159764">
        <title>To create a compressed table</title>
        <p>The <codeph>WITH</codeph> clause of the <codeph>CREATE TABLE</codeph> command declares
          the table storage options. Tables that use compression must be append-optimized tables.
          For example, to create an append-optimized table with zlib compression at a compression
          level of 5:</p>
        <p>
          <codeblock>=&gt; CREATE TABLE foo (a int, b text) 
   WITH (appendonly=true, compresstype=zlib, compresslevel=5);
</codeblock>
        </p>
      </section>
    </body>
  </topic>
  <topic id="topic41" xml:lang="en">
    <title id="im202441">Checking the Compression and Distribution of an Append-Optimized
      Table</title>
    <body>
      <p>Greenplum provides built-in functions to check the compression ratio and the distribution
        of an append-optimized table. The functions take either the object ID or a table name. You
        can qualify the table name with a schema name.</p>
      <table id="im161827">
        <title>Functions for compressed append-optimized table metadata</title>
        <tgroup cols="3">
          <colspec colnum="1" colname="col1" colwidth="183pt"/>
          <colspec colnum="2" colname="col2" colwidth="98pt"/>
          <colspec colnum="3" colname="col3" colwidth="169pt"/>
          <thead>
            <row>
              <entry colname="col1">Function</entry>
              <entry colname="col2">Return Type</entry>
              <entry colname="col3">Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="col1">get_ao_distribution(name)<p>get_ao_distribution(oid)</p></entry>
              <entry colname="col2">Set of (dbid, tuplecount) rows</entry>
              <entry colname="col3">Shows the distribution of an append-optimized table's rows
                across the array. Returns a set of rows, each of which includes a segment
                  <i>dbid</i> and the number of tuples stored on the segment.</entry>
            </row>
            <row>
              <entry colname="col1"
                  >get_ao_compression_ratio(name)<p>get_ao_compression_ratio(oid)</p></entry>
              <entry colname="col2">float8</entry>
              <entry colname="col3">Calculates the compression ratio for a compressed
                append-optimized table. If information is not available, this function returns a
                value of -1.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <p>The compression ratio is returned as a common ratio. For example, a returned value of
          <codeph>3.19</codeph>, or <codeph>3.19:1</codeph>, means that the uncompressed table is
        slightly larger than three times the size of the compressed table.</p>
      <p>The distribution of the table is returned as a set of rows that indicate how many tuples
        are stored on each segment. For example, in a system with four primary segments with
          <i>dbid</i> values ranging from 0 - 3, the function returns four rows similar to the
        following:</p>
      <p>
        <codeblock>=# SELECT get_ao_distribution('lineitem_comp');
 get_ao_distribution
---------------------
(0,7500721)
(1,7501365)
(2,7499978)
(3,7497731)
(4 rows)
</codeblock>
      </p>
    </body>
  </topic>
  <topic id="topic42" xml:lang="en">
    <title>Support for Run-length Encoding</title>
    <body>
      <p>Greenplum Database supports Run-length Encoding (RLE) for column-level compression. RLE
        data compression stores repeated data as a single data value and a count. For example, in a
        table with two columns, a date and a description, that contains 200,000 entries containing
        the value <codeph>date1</codeph> and 400,000 entries containing the value
          <codeph>date2</codeph>, RLE compression for the date field is similar to
          <codeph>date1 200000 date2 400000</codeph>. RLE is not useful with files that do not have
        large sets of repeated data as it can greatly increase the file size.</p>
      <p>There are four levels of RLE compression available. The levels progressively increase the
        compression ratio, but decrease the compression speed.</p>
      <p>Greenplum Database versions 4.2.1 and later support column-oriented RLE compression. To
        backup a table with RLE compression that you intend to restore to an earlier version of
        Greenplum Database, alter the table to have no compression or a compression type supported
        in the earlier version (<codeph>ZLIB</codeph> or <codeph>QUICKLZ</codeph>) before you start
        the backup operation.</p>
      <p>Greenplum Database combines delta compression with RLE compression for data in columns of
        type <codeph>BIGINT</codeph>, <codeph>INTEGER</codeph>, <codeph>DATE</codeph>,
          <codeph>TIME</codeph>, or <codeph>TIMESTAMP</codeph>. The delta compression algorithm is
        based on the change between consecutive column values and is designed to improve compression
        when data is loaded in sorted order or when the compression is applied to data in sorted
        order.</p>
    </body>
  </topic>
  <topic id="topic43" xml:lang="en">
    <title id="im198634">Adding Column-level Compression</title>
    <body>
      <p>You can add the following storage directives to a column for append-optimized tables with
        column orientation:</p>
      <ul id="ul_asg_1wy_sp">
        <li id="im203149">Compression type</li>
        <li id="im203164">Compression level</li>
        <li id="im203171">Block size for a column </li>
      </ul>
      <p>Add storage directives using the <codeph>CREATE TABLE</codeph>, <codeph>ALTER
          TABLE</codeph>, and <codeph>CREATE TYPE</codeph> commands. </p>
      <p>The following table details the types of storage directives and possible values for
        each.</p>
      <table id="im198636">
        <title>Storage Directives for Column-level Compression</title>
        <tgroup cols="4">
          <colspec colnum="1" colname="col1" colwidth="87pt"/>
          <colspec colnum="2" colname="col2" colwidth="95pt"/>
          <colspec colnum="3" colname="col3" colwidth="147pt"/>
          <colspec colnum="4" colname="col4" colwidth="167.25pt"/>
          <thead>
            <row>
              <entry colname="col1">Name</entry>
              <entry colname="col2">Definition</entry>
              <entry colname="col3">Values</entry>
              <entry colname="col4">Comment</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="col1">
                <codeph>COMPRESSTYPE</codeph>
              </entry>
              <entry colname="col2">Type of compression.</entry>
              <entry colname="col3"><codeph>zstd: </codeph>ZStandard
                    algorithm<p><codeph>zlib: </codeph>deflate
                      algorithm</p><p><codeph>quicklz</codeph>: fast
                    compression</p><p><codeph>RLE_TYPE</codeph>: run-length encoding
                    </p><p><codeph>none</codeph>: no compression</p></entry>
              <entry colname="col4">Values are not case-sensitive.</entry>
            </row>
            <row>
              <entry colname="col1" morerows="3">
                <codeph>COMPRESSLEVEL</codeph>
              </entry>
              <entry colname="col2" morerows="3">Compression level.</entry>
              <entry colname="col3"><codeph>zlib</codeph> compression:
                  <codeph>1</codeph>-<codeph>9</codeph></entry>
              <entry colname="col4"><codeph>1</codeph> is the fastest method with the least
                compression. <codeph>1</codeph> is the default.<p><codeph>9</codeph> is the slowest
                  method with the most compression.</p></entry>
            </row>
            <row>
              <entry colname="col3"><codeph>zstd</codeph> compression:
                  <codeph>1</codeph>-<codeph>19</codeph></entry>
              <entry colname="col4"><codeph>1</codeph> is the fastest method with the least
                compression. <codeph>1</codeph> is the default.<p><codeph>19</codeph> is the slowest
                  method with the most compression.</p></entry>
            </row>
            <row>
              <entry colname="col3"><codeph>QuickLZ</codeph> compression:<p><codeph>1</codeph> – use
                  compression</p></entry>
              <entry colname="col4"><codeph>1</codeph> is the default.</entry>
            </row>
            <row>
              <entry colname="col3"><codeph>RLE_TYPE</codeph> compression: <codeph>1</codeph> –
                  <codeph>4</codeph><p><codeph>1</codeph> - apply RLE only</p><p><codeph>2</codeph>
                  - apply RLE then apply zlib compression level 1</p><p><codeph>3</codeph> - apply
                  RLE then apply zlib compression level 5</p><p><codeph>4</codeph> - apply RLE then
                  apply zlib compression level 9</p></entry>
              <entry colname="col4"><codeph>1</codeph> is the fastest method with the least
                    compression.<p><codeph>4</codeph> is the slowest method with the most
                  compression. <codeph>1</codeph> is the default.</p></entry>
            </row>
            <row>
              <entry colname="col1">
                <codeph>BLOCKSIZE</codeph>
              </entry>
              <entry colname="col2">The size in bytes for each block in the table</entry>
              <entry colname="col3">
                <codeph>8192 – 2097152</codeph>
              </entry>
              <entry colname="col4">The value must be a multiple of 8192.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <p>The following is the format for adding storage directives.</p>
      <p>
        <codeblock>[ ENCODING ( <i>storage_directive</i> [,…] ) ] </codeblock>
      </p>
      <p>where the word ENCODING is required and the storage directive has three parts:</p>
      <ul id="ul_hzg_1wy_sp">
        <li id="im203108">The name of the directive</li>
        <li id="im203115">An equals sign</li>
        <li id="im203122">The specification </li>
      </ul>
      <p>Separate multiple storage directives with a comma. Apply a storage directive to a single
        column or designate it as the default for all columns, as shown in the following
          <codeph>CREATE TABLE</codeph> clauses.</p>
      <p>
        <i>General Usage:</i>
      </p>
      <codeblock><i>column_name</i> <i>data_type</i> ENCODING ( <i>storage_directive </i>[, … ] ), …  
</codeblock>
      <codeblock>COLUMN <i>column_name</i> ENCODING ( <i>storage_directive</i> [, … ] ), … 
</codeblock>
      <codeblock>DEFAULT COLUMN ENCODING ( <i>storage_directive</i> [, … ] )
</codeblock>
      <p>
        <i>Example:</i>
      </p>
      <codeblock>C1 char ENCODING (compresstype=quicklz, blocksize=65536) 
</codeblock>
      <codeblock>COLUMN C1 ENCODING (compresstype=zlib, compresslevel=6, blocksize=65536)
</codeblock>
      <codeblock>DEFAULT COLUMN ENCODING (compresstype=quicklz)
</codeblock>
    </body>
    <topic id="topic44" xml:lang="en">
      <title>
        <b>Default Compression Values</b>
      </title>
      <body>
        <p>If the compression type, compression level and block size are not defined, the default is
          no compression, and the block size is set to the Server Configuration Parameter
            <codeph>block_size</codeph>.</p>
      </body>
    </topic>
    <topic id="topic45" xml:lang="en">
      <title id="im196311">
        <b>Precedence of Compression Settings</b>
      </title>
      <body>
        <p>Column compression settings are inherited from the type level to the table level to the partition level to
          the subpartition level. The lowest-level settings have priority. </p>
        <ul id="ul_j3h_1wy_sp">
          <li id="im1963152">Column compression settings defined at the table level override any
            compression settings for the type.</li>
          <li id="im196315">Column compression settings specified at the table level override any
            compression settings for the entire table.</li>
          <li id="im196314">Column compression settings specified for partitions override any
            compression settings at the column or table levels.</li>
          <li id="im196313">Column compression settings specified for subpartitions override any
            compression settings at the partition, column or table levels.</li>
          <li id="im207669">When an <codeph>ENCODING</codeph> clause conflicts with a
              <codeph>WITH</codeph> clause, the <codeph>ENCODING</codeph> clause has higher
            precedence than the <codeph>WITH</codeph> clause.</li>
        </ul>
        <note type="note">The <codeph>INHERITS</codeph> clause is not allowed in a table that
          contains a storage directive or a column reference storage directive.<p>Tables created
            using the <codeph>LIKE</codeph> clause ignore storage directive and column reference
            storage directives.</p></note>
      </body>
    </topic>
    <topic id="topic46" xml:lang="en">
      <title>
        <b>Optimal Location for Column Compression Settings</b>
      </title>
      <body>
        <p>The best practice is to set the column compression settings at the level where the data
          resides. See <xref href="#topic52" type="topic" format="dita"/>, which shows a table with
          a partition depth of 2. <codeph>RLE_TYPE</codeph> compression is added to a column at the
          subpartition level.</p>
      </body>
    </topic>
    <topic id="topic47" xml:lang="en">
      <title>
        <b>Storage Directives Examples</b>
      </title>
      <body>
        <p>The following examples show the use of storage directives in <codeph>CREATE
            TABLE</codeph> statements.</p>
      </body>
      <topic id="topic48" xml:lang="en">
        <title>Example 1 </title>
        <body>
          <p>In this example, column <codeph>c1</codeph> is compressed using <codeph>zstd</codeph>
            and uses the block size defined by the system. Column <codeph>c2</codeph> is compressed
            with <codeph>quicklz</codeph>, and uses a block size of <codeph>65536</codeph>. Column
              <codeph>c3</codeph> is not compressed and uses the block size defined by the
            system.</p>
          <codeblock>CREATE TABLE T1 (c1 int ENCODING (compresstype=zstd),
                  c2 char ENCODING (compresstype=quicklz, blocksize=65536),
                  c3 char)    WITH (appendonly=true, orientation=column);</codeblock>
        </body>
      </topic>
      <topic id="topic49" xml:lang="en">
        <title>Example 2</title>
        <body>
          <p>In this example, column <codeph>c1</codeph> is compressed using <codeph>zlib</codeph>
            and uses the block size defined by the system. Column <codeph>c2</codeph> is compressed
            with <codeph>quicklz</codeph>, and uses a block size of <codeph>65536</codeph>. Column
              <codeph>c3</codeph> is compressed using <codeph>RLE_TYPE</codeph> and uses the block
            size defined by the system.</p>
          <codeblock>CREATE TABLE T2 (c1 int ENCODING (compresstype=zlib),
                  c2 char ENCODING (compresstype=quicklz, blocksize=65536),
                  c3 char,
                  COLUMN c3 ENCODING (compresstype=RLE_TYPE)
                  )
    WITH (appendonly=true, orientation=column);</codeblock>
        </body>
      </topic>
      <topic id="topic50" xml:lang="en">
        <title>Example 3</title>
        <body>
          <p>In this example, column <codeph>c1</codeph> is compressed using <codeph>zlib</codeph>
            and uses the block size defined by the system. Column <codeph>c2</codeph> is compressed
            with <codeph>quicklz</codeph>, and uses a block size of <codeph>65536</codeph>. Column
              <codeph>c3</codeph> is compressed using <codeph>zlib</codeph> and uses the block size
            defined by the system. Note that column <codeph>c3</codeph> uses <codeph>zlib</codeph>
            (not <codeph>RLE_TYPE</codeph>) in the partitions, because the column storage in the
            partition clause has precedence over the storage directive in the column definition for
            the table.</p>
          <codeblock>CREATE TABLE T3 (c1 int ENCODING (compresstype=zlib),
                  c2 char ENCODING (compresstype=quicklz, blocksize=65536),
                  c3 text, COLUMN c3 ENCODING (compresstype=RLE_TYPE) )
    WITH (appendonly=true, orientation=column)
    PARTITION BY RANGE (c3) (START ('1900-01-01'::DATE)          
                             END ('2100-12-31'::DATE),
                             COLUMN c3 ENCODING (compresstype=zlib));</codeblock>
        </body>
      </topic>
      <topic id="topic51" xml:lang="en">
        <title>Example 4</title>
        <body>
          <p>In this example, <codeph>CREATE TABLE</codeph> assigns the <codeph>zlib</codeph> compresstype storage
            directive to <codeph>c1</codeph>. Column <codeph>c2</codeph> has no storage directive
            and inherits the compression type (<codeph>quicklz</codeph>) and block size
              (<codeph>65536</codeph>) from the <codeph>DEFAULT COLUMN ENCODING</codeph> clause.</p>
          <p>Column <codeph>c3</codeph>'s <codeph>ENCODING</codeph> clause defines its compression
            type, <codeph>RLE_TYPE</codeph>. The <codeph>ENCODING</codeph> clause defined for a
            specific column overrides the <codeph>DEFAULT ENCODING</codeph> clause, so column
            <codeph>c3</codeph> uses the default block size, <codeph>32768</codeph>.</p>
          <p>Column <codeph>c4</codeph> has a compress
            type of <codeph>none</codeph> and uses the default block size.</p>
          <codeblock>CREATE TABLE T4 (c1 int ENCODING (compresstype=zlib),
                  c2 char,
                  c3 text,
                  c4 smallint ENCODING (compresstype=none),
                  DEFAULT COLUMN ENCODING (compresstype=quicklz,
                                             blocksize=65536),
                  COLUMN c3 ENCODING (compresstype=RLE_TYPE)
                  ) 
   WITH (appendonly=true, orientation=column);</codeblock>
        </body>
      </topic>
      <topic id="topic52" xml:lang="en">
        <title id="im196338">Example 5</title>
        <body>
          <p>This example creates an append-optimized, column-oriented table, T5. T5 has two
            partitions, <codeph>p1</codeph> and <codeph>p2</codeph>, each of which has
            subpartitions. Each subpartition has <codeph>ENCODING</codeph> clauses:</p>
          <ul id="ul_vlh_1wy_sp">
            <li id="im209617">The <codeph>ENCODING</codeph> clause for partition
              <codeph>p1</codeph>'s subpartition <codeph>sp1</codeph> defines column
                <codeph>i</codeph>'s compression type as <codeph>zlib</codeph> and block size as
              65536. </li>
            <li id="im209618">The <codeph>ENCODING</codeph> clauses for partition
                <codeph>p2</codeph>'s subpartition <codeph>sp1</codeph> defines column
                <codeph>i</codeph>'s compression type as <codeph>rle_type</codeph> and block size is
              the default value. Column <codeph>k</codeph> uses the default compression and its
              block size is
              8192.<codeblock>CREATE TABLE T5(i int, j int, k int, l int) 
    WITH (appendonly=true, orientation=column)
    PARTITION BY range(i) SUBPARTITION BY range(j)
    (
       partition p1 start(1) end(2)
       ( subpartition sp1 start(1) end(2) 
         column i encoding(compresstype=zlib, blocksize=65536)
       ), 
       partition p2 start(2) end(3)
       ( subpartition sp1 start(1) end(2)
           column i encoding(compresstype=rle_type)
           column k encoding(blocksize=8192)
       )
    );</codeblock></li>
          </ul>
          <p>For an example showing how to add a compressed column to an existing table with the
              <codeph>ALTER TABLE</codeph> command, see <xref href="#topic60" type="topic"
              format="dita"/>.</p>
        </body>
      </topic>
    </topic>
    <topic id="topic53" xml:lang="en">
      <title>
        <b>Adding Compression in a TYPE Command</b>
      </title>
      <body>
        <p>When you create a new type, you can define default compression attributes for the type. For example,
          the following <codeph>CREATE TYPE</codeph> command defines a type named <codeph>int33</codeph>
          that specifies <codeph>quicklz</codeph> compression: </p>
        <codeblock>CREATE TYPE int33 (
   internallength = 4,
   input = int33_in,
   output = int33_out,
   alignment = int4,
   default = 123,
   passedbyvalue,
   compresstype="quicklz",
   blocksize=65536,
   compresslevel=1
   );</codeblock>
        <p>When you specify <codeph>int33</codeph> as a column type in a <codeph>CREATE TABLE</codeph>
          command, the column is created with the storage directives you specified for the type:</p>
        <codeblock>CREATE TABLE t2 (c1 int33)
    WITH (APPENDONLY=true, ORIENTATION=column);</codeblock>
        <p>Table- or column- level storage attributes that you specify in a table definition override
           type-level storage attributes. For information about creating and adding compression
           attributes to a type, see
           <xref href="../../ref_guide/sql_commands/CREATE_TYPE.xml#topic1"/>. For information about changing compression specifications
          in a type, see <xref href="../../ref_guide/sql_commands/ALTER_TYPE.xml#topic1"/>.</p>
      </body>
      <topic id="topic54" xml:lang="en">
        <title>Choosing Block Size</title>
        <body>
          <p>The blocksize is the size, in bytes, for each block in a table. Block sizes must be
            between 8192 and 2097152 bytes, and be a multiple of 8192. The default is 32768.</p>
          <p>Specifying large block sizes can consume large amounts of memory. Block size determines
            buffering in the storage layer. Greenplum maintains a buffer per partition, and per
            column in column-oriented tables. Tables with many partitions or columns consume large
            amounts of memory.</p>
        </body>
      </topic>
    </topic>
  </topic>
  <topic id="topic55" xml:lang="en">
    <title>Altering a Table</title>
    <body>
      <p>The <codeph>ALTER TABLE </codeph>command changes the definition of a table. Use
          <codeph>ALTER TABLE</codeph> to change table attributes such as column definitions,
        distribution policy, storage model, and partition structure (see also <xref
          href="ddl-partition.xml#topic77"/>). For example, to add a not-null constraint to a table
        column:</p>
      <p>
        <codeblock>=&gt; ALTER TABLE address ALTER COLUMN street SET NOT NULL;
</codeblock>
      </p>
    </body>
    <topic id="topic56" xml:lang="en">
      <title>Altering Table Distribution</title>
      <body>
        <p><codeph>ALTER TABLE</codeph> provides options to change a table's distribution policy .
          When the table distribution options change, the table data is redistributed on disk, which
          can be resource intensive. You can also redistribute table data using the existing
          distribution policy.</p>
      </body>
    </topic>
    <topic id="topic57" xml:lang="en">
      <title>Changing the Distribution Policy</title>
      <body>
        <p>For partitioned tables, changes to the distribution policy apply recursively to the child
          partitions. This operation preserves the ownership and all other attributes of the table.
          For example, the following command redistributes the table sales across all segments using
          the customer_id column as the distribution key:</p>
        <p>
          <codeblock>ALTER TABLE sales SET DISTRIBUTED BY (customer_id); 
</codeblock>
        </p>
        <p>When you change the hash distribution of a table, table data is automatically
          redistributed. Changing the distribution policy to a random distribution does not cause
          the data to be redistributed. For example, the following <codeph>ALTER TABLE</codeph>
          command has no immediate effect:</p>
        <p>
          <codeblock>ALTER TABLE sales SET DISTRIBUTED RANDOMLY;
</codeblock>
        </p>
      </body>
    </topic>
    <topic id="topic58" xml:lang="en">
      <title>Redistributing Table Data</title>
      <body>
        <p>To redistribute table data for tables with a random distribution policy (or when the hash
          distribution policy has not changed) use <codeph>REORGANIZE=TRUE</codeph>. Reorganizing
          data may be necessary to correct a data skew problem, or when segment resources are added
          to the system. For example, the following command redistributes table data across all
          segments using the current distribution policy, including random distribution.</p>
        <p>
          <codeblock>ALTER TABLE sales SET WITH (REORGANIZE=TRUE);
</codeblock>
        </p>
      </body>
    </topic>
    <topic id="topic59" xml:lang="en">
      <title>Altering the Table Storage Model</title>
      <body>
        <p>Table storage, compression, and orientation can be declared only at creation. To change
          the storage model, you must create a table with the correct storage options, load the
          original table data into the new table, drop the original table, and rename the new table
          with the original table's name. You must also re-grant any table permissions. For
          example:</p>
        <p>
          <codeblock>CREATE TABLE sales2 (LIKE sales) 
WITH (appendonly=true, compresstype=quicklz, 
      compresslevel=1, orientation=column);
INSERT INTO sales2 SELECT * FROM sales;
DROP TABLE sales;
ALTER TABLE sales2 RENAME TO sales;
GRANT ALL PRIVILEGES ON sales TO admin;
GRANT SELECT ON sales TO guest;
</codeblock>
        </p>
        <p>See <xref href="ddl-partition.xml#topic84"/> to learn how to change the storage model of
          a partitioned table.</p>
      </body>
      <topic id="topic60" xml:lang="en">
        <title id="im196377">
          <b>Adding a Compressed Column to Table</b>
        </title>
        <body>
          <p>Use <codeph>ALTER TABLE</codeph> command to add a compressed column to a table. All of
            the options and constraints for compressed columns described in <xref href="#topic43"
              type="topic" format="dita"/> apply to columns added with the <codeph>ALTER
              TABLE</codeph> command. </p>
          <p>The following example shows how to add a column with <codeph>zlib</codeph> compression
            to a table, <codeph>T1</codeph>.</p>
          <p>
            <codeblock>ALTER TABLE T1
      ADD COLUMN c4 int DEFAULT 0
      ENCODING (COMPRESSTYPE=zlib);
</codeblock>
          </p>
        </body>
      </topic>
      <topic id="topic61" xml:lang="en">
        <title>
          <b>Inheritance of Compression Settings</b>
        </title>
        <body>
          <p>A partition added to a table that has subpartitions defined with compression settings
            inherits the compression settings from the subpartition. The following example shows how
            to create a table with subpartition encodings, then alter it to add a partition.</p>
          <p>
            <codeblock>CREATE TABLE ccddl (i int, j int, k int, l int)
  WITH
    (APPENDONLY = TRUE, ORIENTATION=COLUMN)
  PARTITION BY range(j)
  SUBPARTITION BY list (k)
  SUBPARTITION template(
    SUBPARTITION sp1 values(1, 2, 3, 4, 5),
    COLUMN i ENCODING(COMPRESSTYPE=ZLIB),
    COLUMN j ENCODING(COMPRESSTYPE=QUICKLZ),
    COLUMN k ENCODING(COMPRESSTYPE=ZLIB),
    COLUMN l ENCODING(COMPRESSTYPE=ZLIB))
  (PARTITION p1 START(1) END(10),
   PARTITION p2 START(10) END(20))
;

ALTER TABLE ccddl
  ADD PARTITION p3 START(20) END(30)
;
</codeblock>
          </p>
          <p>Running the <codeph>ALTER TABLE</codeph> command creates partitions of table
              <codeph>ccddl</codeph> named <codeph>ccddl_1_prt_p3</codeph> and
              <codeph>ccddl_1_prt_p3_2_prt_sp1</codeph>. Partition <codeph>ccddl_1_prt_p3</codeph>
            inherits the different compression encodings of subpartition <codeph>sp1</codeph>.</p>
        </body>
      </topic>
    </topic>
  </topic>
  <topic id="topic62" xml:lang="en">
    <title>Dropping a Table</title>
    <body>
      <p><ph>The </ph><codeph>DROP TABLE </codeph>command removes tables from the database. For
        example:</p>
      <p>
        <codeblock>DROP TABLE mytable;
</codeblock>
      </p>
      <p>To empty a table of rows without removing the table definition, use <codeph>DELETE</codeph>
        or <codeph>TRUNCATE</codeph>. For example:</p>
      <p>
        <codeblock>DELETE FROM mytable;

TRUNCATE mytable;
</codeblock>
      </p>
      <p><codeph>DROP TABLE </codeph>always removes any indexes, rules, triggers, and constraints
        that exist for the target table. Specify <codeph>CASCADE </codeph>to drop a table that is
        referenced by a view. <codeph>CASCADE</codeph> removes dependent views. </p>
    </body>
  </topic>
</topic>
