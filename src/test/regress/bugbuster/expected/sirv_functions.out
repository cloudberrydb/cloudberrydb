--start_ignore
drop table if exists sirv_test1_result1;
NOTICE:  table "sirv_test1_result1" does not exist, skipping
drop table if exists sirv_test1_result2;
NOTICE:  table "sirv_test1_result2" does not exist, skipping
--end_ignore
CREATE or replace FUNCTION sirv_test1() RETURNS TEXT AS $$
declare
        result1 TEXT;
        result2 TEXT;
        result3 TEXT;
begin
        CREATE TABLE test_data1 (
                x INT
                , y INT
        ) distributed by (x);


        CREATE TABLE test_data2 (
                x INT
                , y VARCHAR
        ) distributed by(x);


        EXECUTE 'INSERT INTO test_data1 VALUES (1,1)';
        EXECUTE 'INSERT INTO test_data1 VALUES (1,2)';
        EXECUTE 'INSERT INTO test_data1 VALUES (2,3)';
        EXECUTE 'INSERT INTO test_data1 VALUES (3,4)';
        EXECUTE 'INSERT INTO test_data1 VALUES (4,1)';
        EXECUTE 'INSERT INTO test_data1 VALUES (4,2)';
        EXECUTE 'INSERT INTO test_data1 VALUES (4,3)';
        EXECUTE 'INSERT INTO test_data1 VALUES (5,2)';

        EXECUTE 'INSERT INTO test_data2 VALUES (1, ''one'')';
        EXECUTE 'INSERT INTO test_data2 VALUES (1, ''ONE'')';
	EXECUTE 'INSERT INTO test_data2 VALUES (1, ''one'')';
        EXECUTE 'INSERT INTO test_data2 VALUES (1, ''ONE'')';
	EXECUTE 'INSERT INTO test_data2 VALUES (1, ''one'')';
        EXECUTE 'INSERT INTO test_data2 VALUES (1, ''ONE'')';
	EXECUTE 'INSERT INTO test_data2 VALUES (1, ''one'')';
        EXECUTE 'INSERT INTO test_data2 VALUES (1, ''ONE'')';
	
	EXECUTE 'SELECT CASE WHEN count(*)>0 then ''PASS'' ELSE ''FAIL'' END FROM test_data1' into result1;

	EXECUTE 'SELECT CASE WHEN count(*)>0 then ''PASS'' ELSE ''FAIL'' END FROM test_data2' into result2;

	EXECUTE 'DROP TABLE test_data1';
	EXECUTE 'DROP TABLE test_data2';

	IF (result1 = 'PASS')  and  (result2 = 'PASS') THEN
	   result3 = 'PASS';
	else
	   result3 = 'FAIL';

	END IF;

	return result3;

end $$ language plpgsql volatile MODIFIES SQL DATA;
--ctas with sirv in the select list
--start_ignore
explain create table sirv_test1_result1 as select sirv_test1() as res distributed by (res);
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.01..0.02 rows=1 width=0)
   Hash Key: res
   ->  Result  (cost=0.01..0.02 rows=1 width=0)
         InitPlan  (slice2)
           ->  Result  (cost=0.00..0.01 rows=1 width=0)
(5 rows)

--end_ignore
--ctas with sirv in select list
create table sirv_test1_result1 as select sirv_test1() as res distributed by (res);
--workaround
create table sirv_test1_result2 as select (select sirv_test1()) as res distributed by (res);
--start_equiv
select * from sirv_test1_result1;
 res  
------
 PASS
(1 row)

select * from sirv_test1_result2;
 res  
------
 PASS
(1 row)

--end_equiv
--start_ignore
drop table if exists countries_results;
NOTICE:  table "countries_results" does not exist, skipping
drop table if exists sirv_test2_result1;
NOTICE:  table "sirv_test2_result1" does not exist, skipping
drop table if exists sirv_test2_result2;
NOTICE:  table "sirv_test2_result2" does not exist, skipping
--end_ignore
CREATE OR REPLACE FUNCTION sirv_test2 (min_languages integer, min_area float8, min_gnp float8)
  RETURNS text
AS $$
DECLARE
  lang_delta int;
  area_delta float8;
  gnp_delta float8;
BEGIN
  
  EXECUTE 'CREATE  TABLE countries_results (country_code text, country_name text, lang_count int, area float, gnp float) distributed by(country_code)';

  EXECUTE 'INSERT INTO countries_results 
  	   ( with lang_total as
            ( select count(*) as lang_count,country.code,countrylanguage.countrycode
              from country join countrylanguage on (country.code=countrylanguage.countrycode)
              group by country.code,countrylanguage.countrycode order by country.code
            )
            select country.code,country.name, lang_count, country.surfacearea, country.gnp
            from country left outer join lang_total
            on (lang_total.code = country.code)
            where lang_count > ' || min_languages || ' and country.surfacearea > ' || min_area || ' and country.gnp > ' || min_gnp
            || ' order by lang_total.lang_count desc 
           )';
  
  
  EXECUTE 'SELECT max(lang_count - ' || min_languages || '), max(area - ' || min_area || '), max(gnp - ' || min_gnp || ') FROM countries_results' into lang_delta,area_delta,gnp_delta;
  
  EXECUTE 'DROP TABLE countries_results';

  RETURN lang_delta || area_delta || gnp_delta ;

END;
$$
    LANGUAGE plpgsql volatile MODIFIES SQL DATA;
--ctas with sirv in the from clause
--start_ignore
explain create table sirv_test2_result1 as select * from sirv_test2(2,1000,1000) as res distributed by(res);
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.01..0.02 rows=1 width=0)
   Hash Key: res
   ->  Result  (cost=0.01..0.02 rows=1 width=0)
         InitPlan  (slice2)
           ->  Result  (cost=0.00..0.01 rows=1 width=0)
(5 rows)

--end_ignore
create table sirv_test2_result1 as select * from sirv_test2(2,1000,1000) as res distributed by(res);
--workaround
create table sirv_test2_result2 as select * from (select (select sirv_test2(2,1000,1000)) as res) as foo distributed by(res);
--start_equiv
select * from sirv_test2_result1;
        res        
-------------------
 10170744008509700
(1 row)

select * from sirv_test2_result2;
        res        
-------------------
 10170744008509700
(1 row)

--end_equiv
--start_ignore
drop table if exists sirv_test3_result1;
NOTICE:  table "sirv_test3_result1" does not exist, skipping
drop table if exists sirv_test3_result2;
NOTICE:  table "sirv_test3_result2" does not exist, skipping
--end_ignore
CREATE OR REPLACE FUNCTION sirv_test3 (min_languages integer, min_area float8, min_gnp float8)
  RETURNS text
AS $$
DECLARE
  lang_delta int;
  area_delta float8;
  gnp_delta float8;
BEGIN

  EXECUTE 'CREATE  TABLE countries_results (country_code text, country_name text, lang_count int, area float, gnp float) distributed by(country_code)';

  EXECUTE 'INSERT INTO countries_results 
  	   ( with lang_total as
            ( select count(*) as lang_count,country.code,countrylanguage.countrycode
              from country join countrylanguage on (country.code=countrylanguage.countrycode)
              group by country.code,countrylanguage.countrycode order by country.code
            )
            select country.code,country.name, lang_count, country.surfacearea, country.gnp
            from country left outer join lang_total
            on (lang_total.code = country.code)
            where lang_count > ' || min_languages || ' and country.surfacearea > ' || min_area || ' and country.gnp > ' || min_gnp
            || ' order by lang_total.lang_count desc 
           )';
  

  EXECUTE 'SELECT max(lang_count - ' || min_languages || '), max(area - ' || min_area || '), max(gnp - ' || min_gnp || ') FROM countries_results' into lang_delta,area_delta,gnp_delta;
  
  EXECUTE 'DROP TABLE countries_results';

  RETURN lang_delta || area_delta || gnp_delta ;

END;
$$
    LANGUAGE plpgsql volatile MODIFIES SQL DATA;
create table sirv_test3_result1(id int,country_index text) distributed by(id);
create table sirv_test3_result2(id int, country_index text) distributed by(id);
--insert with sirv in the select list
--start_ignore
explain insert into sirv_test3_result1 select 1,sirv_test3(2,1000,1000);
                       QUERY PLAN                       
--------------------------------------------------------
 Insert (slice0; segments: 1)  (rows=1 width=0)
   ->  Result  (cost=0.01..0.02 rows=1 width=0)
         InitPlan  (slice1)
           ->  Result  (cost=0.00..0.01 rows=1 width=0)
(4 rows)

--end_ignore
insert into sirv_test3_result1 select 1,sirv_test3(2,1000,1000);
--workaround
insert into sirv_test3_result2 select 1,(select sirv_test3(2,1000,1000));
--start_equiv
select * from sirv_test3_result1;
 id |   country_index   
----+-------------------
  1 | 10170744008509700
(1 row)

select * from sirv_test3_result2;
 id |   country_index   
----+-------------------
  1 | 10170744008509700
(1 row)

--end_equiv
--start_ignore
drop table if exists sirv_test4_result1;
NOTICE:  table "sirv_test4_result1" does not exist, skipping
drop table if exists sirv_test4_result2;
NOTICE:  table "sirv_test4_result2" does not exist, skipping
--end_ignore
CREATE OR REPLACE FUNCTION sirv_test4(gnp_diff float8, opt integer)  RETURNS FLOAT[] AS $$
declare
        res FLOAT[];
	tmp_values FLOAT[];
	gnp_curr_val float8;
        iter INT = 0;
begin
	gnp_curr_val = gnp_diff;

        CREATE TEMP TABLE l_gnp (
                gnp_values FLOAT[]
        ) distributed by (gnp_values);

        CREATE TEMP TABLE h_gnp(
                gnp_values FLOAT[]
        ) distributed by (gnp_values);

       EXECUTE 'INSERT INTO l_gnp SELECT ARRAY(SELECT gnp FROM country where gnp < '  || gnp_diff || ' order by gnp desc)';
       LOOP
		iter = iter + 1;
		TRUNCATE table h_gnp;
		EXECUTE 'SELECT ARRAY(SELECT gnp FROM country where gnp > ' || gnp_curr_val || ' order by gnp desc LIMIT 50)'  INTO tmp_values;
		EXECUTE 'INSERT INTO h_gnp(gnp_values) VALUES(array['|| array_to_string(tmp_values,',') ||'])';		

                IF(iter > 5)THEN
			EXIT;
		ELSE 
		     gnp_curr_val = gnp_curr_val + 500;
		END IF;

	END LOOP;

			
        IF(opt > 0) THEN
	       EXECUTE 'SELECT gnp_values FROM h_gnp' INTO res;
	ELSE
	       EXECUTE 'SELECT gnp_values FROM l_gnp' INTO res;
	END IF;
	
	DROP TABLE l_gnp;
	DROP TABLE h_gnp;

	RETURN res;
end
$$ LANGUAGE plpgsql volatile MODIFIES SQL DATA;
create table sirv_test4_result1(res float[]) distributed by(res);
create table sirv_test4_result2(res float[]) distributed by(res);
--insert with sirv in the from clause
--start_ignore
explain insert into sirv_test4_result1 select * from sirv_test4(20000,0);
                       QUERY PLAN                       
--------------------------------------------------------
 Insert (slice0; segments: 2)  (rows=1 width=0)
   ->  Result  (cost=0.01..0.02 rows=1 width=0)
         InitPlan  (slice1)
           ->  Result  (cost=0.00..0.01 rows=1 width=0)
(4 rows)

--end_ignore
insert into sirv_test4_result1 select * from sirv_test4(20000,0);
insert into sirv_test4_result1 select * from sirv_test4(25000,1);
insert into sirv_test4_result1 select * from sirv_test4(30000,0);
insert into sirv_test4_result1 select * from sirv_test4(35000,1);
--workaround
insert into sirv_test4_result2 select * from (select (select sirv_test4(20000,0))) AS FOO;
insert into sirv_test4_result2 select * from (select (select sirv_test4(25000,1))) AS FOO;
insert into sirv_test4_result2 select * from (select (select sirv_test4(30000,0))) AS FOO;
insert into sirv_test4_result2 select * from (select (select sirv_test4(35000,1))) AS FOO;
--start_equiv
select * from sirv_test4_result1 order by res;
                                                                                                                                                                                                                                                                                                                                                                                                              res                                                                                                                                                                                                                                                                                                                                                                                                              
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 {19770,19756,19008,17843,17121,17000,16904,16321,15846,15706,14194,13714,12178,11863,11705,11500,11345,10692,10226,10162,9472,9333,9217,9174,9131,8571,8444,8287,8255,8005,7526,7137,6964,6871,6648,6398,6366,6353,6313,6232,6064,6041,5976,5951,5749,5493,5333,5332,5328,5121,4988,4834,4787,4768,4401,4397,4251,4173,4127,3750,3563,3527,3512,3501,3459,3377,3205,3101,2891,2841,2731,2642,2425,2357,2352,2328,2223,2108,2036,2012,1990,1988,1941,1813,1706,1694,1687,1630,1626,1579,1536,1449,1292,1263,1208,1206,1197,1119,1061,1054,1043,998,935,903,870,828,818,776,746,722,681,650,630,612,612,571,536,510,435,382,372,334,320,318,299,293,285,283,261,258,256,212,199,197,182,146,141,109,105,100,97,96,63.2,60,40.7,9,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
 {27037,24375,21929,20831,20594,20208,20026,19770,19756,19008,17843,17121,17000,16904,16321,15846,15706,14194,13714,12178,11863,11705,11500,11345,10692,10226,10162,9472,9333,9217,9174,9131,8571,8444,8287,8255,8005,7526,7137,6964,6871,6648,6398,6366,6353,6313,6232,6064,6041,5976,5951,5749,5493,5333,5332,5328,5121,4988,4834,4787,4768,4401,4397,4251,4173,4127,3750,3563,3527,3512,3501,3459,3377,3205,3101,2891,2841,2731,2642,2425,2357,2352,2328,2223,2108,2036,2012,1990,1988,1941,1813,1706,1694,1687,1630,1626,1579,1536,1449,1292,1263,1208,1206,1197,1119,1061,1054,1043,998,935,903,870,828,818,776,746,722,681,650,630,612,612,571,536,510,435,382,372,334,320,318,299,293,285,283,261,258,256,212,199,197,182,146,141,109,105,100,97,96,63.2,60,40.7,9,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
 {8510700,3787042,2133367,1424285,1378330,1161755,982268,776739,598862,553233,447114,414972,371362,351182,340238,320749,276608,264478,256254,249704,226492,211860,210721,195746,180375,174099,166448,151697,145895,137635,121914,120724,116729,116416,105954,102896,97477,95023,86503,84982,82710,75921,72949,69213,65984,65707,65107,64140,61289,55017}
 {8510700,3787042,2133367,1424285,1378330,1161755,982268,776739,598862,553233,447114,414972,371362,351182,340238,320749,276608,264478,256254,249704,226492,211860,210721,195746,180375,174099,166448,151697,145895,137635,121914,120724,116729,116416,105954,102896,97477,95023,86503,84982,82710,75921,72949,69213,65984,65707,65107,64140,61289,55017}
(4 rows)

select * from sirv_test4_result2 order by res;
                                                                                                                                                                                                                                                                                                                                                                                                              res                                                                                                                                                                                                                                                                                                                                                                                                              
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 {19770,19756,19008,17843,17121,17000,16904,16321,15846,15706,14194,13714,12178,11863,11705,11500,11345,10692,10226,10162,9472,9333,9217,9174,9131,8571,8444,8287,8255,8005,7526,7137,6964,6871,6648,6398,6366,6353,6313,6232,6064,6041,5976,5951,5749,5493,5333,5332,5328,5121,4988,4834,4787,4768,4401,4397,4251,4173,4127,3750,3563,3527,3512,3501,3459,3377,3205,3101,2891,2841,2731,2642,2425,2357,2352,2328,2223,2108,2036,2012,1990,1988,1941,1813,1706,1694,1687,1630,1626,1579,1536,1449,1292,1263,1208,1206,1197,1119,1061,1054,1043,998,935,903,870,828,818,776,746,722,681,650,630,612,612,571,536,510,435,382,372,334,320,318,299,293,285,283,261,258,256,212,199,197,182,146,141,109,105,100,97,96,63.2,60,40.7,9,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
 {27037,24375,21929,20831,20594,20208,20026,19770,19756,19008,17843,17121,17000,16904,16321,15846,15706,14194,13714,12178,11863,11705,11500,11345,10692,10226,10162,9472,9333,9217,9174,9131,8571,8444,8287,8255,8005,7526,7137,6964,6871,6648,6398,6366,6353,6313,6232,6064,6041,5976,5951,5749,5493,5333,5332,5328,5121,4988,4834,4787,4768,4401,4397,4251,4173,4127,3750,3563,3527,3512,3501,3459,3377,3205,3101,2891,2841,2731,2642,2425,2357,2352,2328,2223,2108,2036,2012,1990,1988,1941,1813,1706,1694,1687,1630,1626,1579,1536,1449,1292,1263,1208,1206,1197,1119,1061,1054,1043,998,935,903,870,828,818,776,746,722,681,650,630,612,612,571,536,510,435,382,372,334,320,318,299,293,285,283,261,258,256,212,199,197,182,146,141,109,105,100,97,96,63.2,60,40.7,9,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
 {8510700,3787042,2133367,1424285,1378330,1161755,982268,776739,598862,553233,447114,414972,371362,351182,340238,320749,276608,264478,256254,249704,226492,211860,210721,195746,180375,174099,166448,151697,145895,137635,121914,120724,116729,116416,105954,102896,97477,95023,86503,84982,82710,75921,72949,69213,65984,65707,65107,64140,61289,55017}
 {8510700,3787042,2133367,1424285,1378330,1161755,982268,776739,598862,553233,447114,414972,371362,351182,340238,320749,276608,264478,256254,249704,226492,211860,210721,195746,180375,174099,166448,151697,145895,137635,121914,120724,116729,116416,105954,102896,97477,95023,86503,84982,82710,75921,72949,69213,65984,65707,65107,64140,61289,55017}
(4 rows)

--end_equiv
--start_ignore
drop table if exists sirv_test5_result1;
NOTICE:  table "sirv_test5_result1" does not exist, skipping
drop table if exists sirv_test5_result2;
NOTICE:  table "sirv_test5_result2" does not exist, skipping
--end_ignore
CREATE or replace FUNCTION sirv_test5_fun1() RETURNS TEXT AS $$
declare
        result1 TEXT;
        result2 TEXT;
        result3 TEXT;
begin

        EXECUTE 'CREATE TABLE test_data1 (
                x INT
                , y INT
        ) distributed by(x)';

	EXECUTE 'CREATE TABLE test_data2 (
                x INT
                , y VARCHAR
        ) distributed by(x)';


        EXECUTE 'INSERT INTO test_data1 VALUES (1,1)';
        EXECUTE 'INSERT INTO test_data1 VALUES (1,2)';
        EXECUTE 'INSERT INTO test_data1 VALUES (2,3)';
        EXECUTE 'INSERT INTO test_data1 VALUES (3,4)';
        EXECUTE 'INSERT INTO test_data1 VALUES (4,1)';
        EXECUTE 'INSERT INTO test_data1 VALUES (4,2)';
        EXECUTE 'INSERT INTO test_data1 VALUES (4,3)';
        EXECUTE 'INSERT INTO test_data1 VALUES (5,2)';

        EXECUTE 'INSERT INTO test_data2 VALUES (1, ''one'')';
        EXECUTE 'INSERT INTO test_data2 VALUES (1, ''ONE'')';
        EXECUTE 'INSERT INTO test_data2 VALUES (1, ''one'')';
        EXECUTE 'INSERT INTO test_data2 VALUES (2, ''two'')';
        EXECUTE 'INSERT INTO test_data2 VALUES (2, ''TWO'')';
        EXECUTE 'INSERT INTO test_data2 VALUES (3, ''three'')';
        EXECUTE 'INSERT INTO test_data2 VALUES (7, ''seven'')';

	
	EXECUTE 'SELECT CASE WHEN count(*)>0 then ''PASS'' ELSE ''FAIL'' END FROM test_data1' INTO result1;

	EXECUTE 'SELECT CASE WHEN count(*)>0 then ''PASS'' ELSE ''FAIL'' END FROM test_data2' INTO result2;

	EXECUTE 'DROP TABLE test_data1';
	EXECUTE 'DROP TABLE test_data2';

	IF (result1 = 'PASS')  and  (result2 = 'PASS') THEN
	   result3 = 'PASS';
	else
	   result3 = 'FAIL';

	END IF;

	return result3;

end $$ language plpgsql volatile MODIFIES SQL DATA;
CREATE OR REPLACE FUNCTION sirv_test5_fun2 (min_languages integer, min_area float8, min_gnp float8)
  RETURNS text
AS $$
DECLARE
  lang_delta int;
  area_delta float8;
  gnp_delta float8;
BEGIN

  EXECUTE 'CREATE  TABLE countries_results (country_code text, country_name text, lang_count int, area float, gnp float) distributed by (country_code)';

  EXECUTE 'INSERT INTO countries_results 
  	   ( with lang_total as
            ( select count(*) as lang_count,country.code,countrylanguage.countrycode
              from country join countrylanguage on (country.code=countrylanguage.countrycode)
              group by country.code,countrylanguage.countrycode order by country.code
            )
            select country.code,country.name, lang_count, country.surfacearea, country.gnp
            from country left outer join lang_total
            on (lang_total.code = country.code)
            where lang_count > ' || min_languages || ' and country.surfacearea > ' || min_area || ' and country.gnp > ' || min_gnp
            || ' order by lang_total.lang_count desc 
           )';
  

  EXECUTE 'SELECT max(lang_count - ' || min_languages || '), max(area - ' || min_area || '), max(gnp - ' || min_gnp || ') FROM countries_results' into lang_delta,area_delta,gnp_delta;
  
  EXECUTE 'DROP TABLE countries_results';

  RETURN lang_delta || area_delta || gnp_delta ;

END;
$$
    LANGUAGE plpgsql volatile MODIFIES SQL DATA;
CREATE OR REPLACE FUNCTION sirv_test5_fun3 (min_languages integer, min_area float8, min_gnp float8)
  RETURNS float
AS $$
DECLARE
  lang_delta int;
  area_delta float8;
  gnp_delta float8;
BEGIN

  EXECUTE 'CREATE  TABLE countries_results (country_code text, country_name text, lang_count int, area float, gnp float) distributed by(country_code)';

  EXECUTE 'INSERT INTO countries_results 
  	   ( with lang_total as
            ( select count(*) as lang_count,country.code,countrylanguage.countrycode
              from country join countrylanguage on (country.code=countrylanguage.countrycode)
              group by country.code,countrylanguage.countrycode order by country.code
            )
            select country.code,country.name, lang_count, country.surfacearea, country.gnp
            from country left outer join lang_total
            on (lang_total.code = country.code)
            where lang_count > ' || min_languages || ' and country.surfacearea > ' || min_area || ' and country.gnp > ' || min_gnp
            || ' order by lang_total.lang_count desc 
           )';
  

  EXECUTE 'SELECT max(lang_count - ' || min_languages || '), max(area - ' || min_area || '), max(gnp - ' || min_gnp || ') FROM countries_results' into lang_delta,area_delta,gnp_delta;
  EXECUTE 'DROP TABLE countries_results';

  RETURN lang_delta +  area_delta +  gnp_delta ;

END;
$$
    LANGUAGE plpgsql volatile MODIFIES SQL DATA;
CREATE OR REPLACE FUNCTION sirv_test5_fun4(gnp_diff float8, opt integer)  RETURNS FLOAT[] AS $$
declare
        res FLOAT[];
	tmp_values FLOAT[];
	gnp_curr_val float8;
        iter INT = 0;
begin
	gnp_curr_val = gnp_diff;

        CREATE TEMP TABLE l_gnp (
                gnp_values FLOAT[]
        ) distributed by(gnp_values);

        CREATE TEMP TABLE h_gnp(
                gnp_values FLOAT[]
        ) distributed by (gnp_values);

       EXECUTE 'INSERT INTO l_gnp SELECT ARRAY(SELECT gnp FROM country where gnp < '  || gnp_diff || ' order by gnp desc)';
       LOOP
		iter = iter + 1;
		TRUNCATE table h_gnp;
		EXECUTE 'SELECT ARRAY(SELECT gnp FROM country where gnp > ' || gnp_curr_val || ' order by gnp desc LIMIT 50)'  INTO tmp_values;
		EXECUTE 'INSERT INTO h_gnp(gnp_values) VALUES(array['|| array_to_string(tmp_values,',') ||'])';		

                IF(iter > 5)THEN
			EXIT;
		ELSE 
		     gnp_curr_val = gnp_curr_val + 500;
		END IF;

	END LOOP;

			
        IF(opt > 0) THEN
	       EXECUTE 'SELECT gnp_values FROM h_gnp' INTO res;
	ELSE
	       EXECUTE 'SELECT gnp_values FROM l_gnp' INTO res;
	END IF;

	EXECUTE 'DROP table l_gnp';
        EXECUTE 'DROP table h_gnp';
	RETURN res;
end
$$ LANGUAGE plpgsql volatile MODIFIES SQL DATA;
--select list
--start_ignore
explain create table sirv_test5_result1 as select 'sirv_test1:' || sirv_test5_fun1() as field1,
                                          'sirv_test5_fun2:' || substring(sirv_test5_fun2(2,1000,1000),0,5) as field2,
                                          1.5 * sirv_test5_fun3(2,1000,1000) as field3,
                                          ARRAY[1.0::float,2.0::float] || sirv_test5_fun4(20000,0) as field4
        distributed by (field1);
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.05..0.07 rows=1 width=0)
   Hash Key: field1
   ->  Result  (cost=0.05..0.07 rows=1 width=0)
         InitPlan  (slice2)
           ->  Result  (cost=0.00..0.01 rows=1 width=0)
         InitPlan  (slice3)
           ->  Result  (cost=0.00..0.01 rows=1 width=0)
         InitPlan  (slice4)
           ->  Result  (cost=0.00..0.01 rows=1 width=0)
         InitPlan  (slice5)
           ->  Result  (cost=0.00..0.01 rows=1 width=0)
(11 rows)

--end_ignore
create table sirv_test5_result1 as select 'sirv_test1:' || sirv_test5_fun1() as field1,
                                          'sirv_test5_fun2:' || substring(sirv_test5_fun2(2,1000,1000),0,5) as field2,
                                          1.5 * sirv_test5_fun3(2,1000,1000) as field3,
                                          ARRAY[1.0::float,2.0::float] || sirv_test5_fun4(20000,0) as field4
distributed by (field1);
select * from sirv_test5_result1;
     field1      |        field2        |  field3  |                                                                                                                                                                                                                                                                                                                                                                                         field4                                                                                                                                                                                                                                                                                                                                                                                          
-----------------+----------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 sirv_test1:PASS | sirv_test5_fun2:1017 | 38376165 | {1,2,19770,19756,19008,17843,17121,17000,16904,16321,15846,15706,14194,13714,12178,11863,11705,11500,11345,10692,10226,10162,9472,9333,9217,9174,9131,8571,8444,8287,8255,8005,7526,7137,6964,6871,6648,6398,6366,6353,6313,6232,6064,6041,5976,5951,5749,5493,5333,5332,5328,5121,4988,4834,4787,4768,4401,4397,4251,4173,4127,3750,3563,3527,3512,3501,3459,3377,3205,3101,2891,2841,2731,2642,2425,2357,2352,2328,2223,2108,2036,2012,1990,1988,1941,1813,1706,1694,1687,1630,1626,1579,1536,1449,1292,1263,1208,1206,1197,1119,1061,1054,1043,998,935,903,870,828,818,776,746,722,681,650,630,612,612,571,536,510,435,382,372,334,320,318,299,293,285,283,261,258,256,212,199,197,182,146,141,109,105,100,97,96,63.2,60,40.7,9,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
(1 row)

--from clause
--start_ignore
explain  create table sirv_test5_result2  as select * from sirv_test5_fun1() as field1,
                                                           substring(sirv_test5_fun2(2,1000,1000),0,5) as field2,
                                                           sirv_test5_fun3(2,1000,1000) as field3,
                                                           sirv_test5_fun4(20000,0) as field4
distributed by (field1);
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.09..0.54 rows=7 width=104)
   Hash Key: field1.field1
   ->  Nested Loop  (cost=0.09..0.54 rows=7 width=104)
         InitPlan  (slice5)
           ->  Result  (cost=0.00..0.01 rows=1 width=0)
         ->  Function Scan on "substring" field2  (cost=0.00..0.01 rows=1 width=32)
         ->  Materialize  (cost=0.45..0.52 rows=4 width=72)
               ->  Nested Loop  (cost=0.08..0.45 rows=7 width=72)
                     ->  Nested Loop  (cost=0.05..0.15 rows=7 width=64)
                           ->  Result  (cost=0.01..0.02 rows=1 width=0)
                                 InitPlan  (slice2)
                                   ->  Result  (cost=0.00..0.01 rows=1 width=0)
                           ->  Materialize  (cost=0.03..0.05 rows=1 width=32)
                                 ->  Result  (cost=0.01..0.02 rows=1 width=0)
                                       InitPlan  (slice3)
                                         ->  Result  (cost=0.00..0.01 rows=1 width=0)
                     ->  Materialize  (cost=0.03..0.05 rows=1 width=8)
                           ->  Result  (cost=0.01..0.02 rows=1 width=0)
                                 InitPlan  (slice4)
                                   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(20 rows)

--end_ignore
create table sirv_test5_result2  as select * from sirv_test5_fun1() as field1,
                                                           substring(sirv_test5_fun2(2,1000,1000),0,5) as field2,
                                                           sirv_test5_fun3(2,1000,1000) as field3,
                                                           sirv_test5_fun4(20000,0) as field4
distributed by (field1);
select * from sirv_test5_result2;
 field1 | field2 |  field3  |                                                                                                                                                                                                                                                                                                                                                                                       field4                                                                                                                                                                                                                                                                                                                                                                                        
--------+--------+----------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PASS   | 1017   | 25584110 | {19770,19756,19008,17843,17121,17000,16904,16321,15846,15706,14194,13714,12178,11863,11705,11500,11345,10692,10226,10162,9472,9333,9217,9174,9131,8571,8444,8287,8255,8005,7526,7137,6964,6871,6648,6398,6366,6353,6313,6232,6064,6041,5976,5951,5749,5493,5333,5332,5328,5121,4988,4834,4787,4768,4401,4397,4251,4173,4127,3750,3563,3527,3512,3501,3459,3377,3205,3101,2891,2841,2731,2642,2425,2357,2352,2328,2223,2108,2036,2012,1990,1988,1941,1813,1706,1694,1687,1630,1626,1579,1536,1449,1292,1263,1208,1206,1197,1119,1061,1054,1043,998,935,903,870,828,818,776,746,722,681,650,630,612,612,571,536,510,435,382,372,334,320,318,299,293,285,283,261,258,256,212,199,197,182,146,141,109,105,100,97,96,63.2,60,40.7,9,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
(1 row)

--start_ignore
drop table if exists sirv_test6_result1;
NOTICE:  table "sirv_test6_result1" does not exist, skipping
drop table if exists sirv_test6_result2;
NOTICE:  table "sirv_test6_result2" does not exist, skipping
--end_ignore
CREATE or replace FUNCTION sirv_test6_fun1() RETURNS TEXT AS $$
declare
        result1 TEXT;
        result2 TEXT;
        result3 TEXT;
begin

        EXECUTE 'CREATE TABLE test_data1 (
                x INT
                , y INT
        ) distributed by(x)';

	EXECUTE 'CREATE TABLE test_data2 (
                x INT
                , y VARCHAR
        ) distributed by(x)';


        EXECUTE 'INSERT INTO test_data1 VALUES (1,1)';
        EXECUTE 'INSERT INTO test_data1 VALUES (1,2)';
        EXECUTE 'INSERT INTO test_data1 VALUES (2,3)';
        EXECUTE 'INSERT INTO test_data1 VALUES (3,4)';
        EXECUTE 'INSERT INTO test_data1 VALUES (4,1)';
        EXECUTE 'INSERT INTO test_data1 VALUES (4,2)';
        EXECUTE 'INSERT INTO test_data1 VALUES (4,3)';
        EXECUTE 'INSERT INTO test_data1 VALUES (5,2)';

        EXECUTE 'INSERT INTO test_data2 VALUES (1, ''one'')';
        EXECUTE 'INSERT INTO test_data2 VALUES (1, ''ONE'')';
        EXECUTE 'INSERT INTO test_data2 VALUES (1, ''one'')';
        EXECUTE 'INSERT INTO test_data2 VALUES (2, ''two'')';
        EXECUTE 'INSERT INTO test_data2 VALUES (2, ''TWO'')';
        EXECUTE 'INSERT INTO test_data2 VALUES (3, ''three'')';
        EXECUTE 'INSERT INTO test_data2 VALUES (7, ''seven'')';

	
	EXECUTE 'SELECT CASE WHEN count(*)>0 then ''PASS'' ELSE ''FAIL'' END FROM test_data1' INTO result1;

	EXECUTE 'SELECT CASE WHEN count(*)>0 then ''PASS'' ELSE ''FAIL'' END FROM test_data2' INTO result2;

	EXECUTE 'DROP TABLE test_data1';
	EXECUTE 'DROP TABLE test_data2';

	IF (result1 = 'PASS')  and  (result2 = 'PASS') THEN
	   result3 = 'PASS';
	else
	   result3 = 'FAIL';

	END IF;

	return result3;

end $$ language plpgsql volatile MODIFIES SQL DATA;
CREATE OR REPLACE FUNCTION sirv_test6_fun2 (min_languages integer, min_area float8, min_gnp float8)
  RETURNS text
AS $$
DECLARE
  lang_delta int;
  area_delta float8;
  gnp_delta float8;
BEGIN

  EXECUTE 'CREATE  TABLE countries_results (country_code text, country_name text, lang_count int, area float, gnp float) distributed by (country_code)';

  EXECUTE 'INSERT INTO countries_results 
  	   ( with lang_total as
            ( select count(*) as lang_count,country.code,countrylanguage.countrycode
              from country join countrylanguage on (country.code=countrylanguage.countrycode)
              group by country.code,countrylanguage.countrycode order by country.code
            )
            select country.code,country.name, lang_count, country.surfacearea, country.gnp
            from country left outer join lang_total
            on (lang_total.code = country.code)
            where lang_count > ' || min_languages || ' and country.surfacearea > ' || min_area || ' and country.gnp > ' || min_gnp
            || ' order by lang_total.lang_count desc 
           )';
  

  EXECUTE 'SELECT max(lang_count - ' || min_languages || '), max(area - ' || min_area || '), max(gnp - ' || min_gnp || ') FROM countries_results' into lang_delta,area_delta,gnp_delta;
  
  EXECUTE 'DROP TABLE countries_results';

  RETURN lang_delta || area_delta || gnp_delta ;

END;
$$
    LANGUAGE plpgsql volatile MODIFIES SQL DATA;
CREATE OR REPLACE FUNCTION sirv_test6_fun3 (min_languages integer, min_area float8, min_gnp float8)
  RETURNS float
AS $$
DECLARE
  lang_delta int;
  area_delta float8;
  gnp_delta float8;
BEGIN

  EXECUTE 'CREATE  TABLE countries_results (country_code text, country_name text, lang_count int, area float, gnp float) distributed by(country_code)';

  EXECUTE 'INSERT INTO countries_results 
  	   ( with lang_total as
            ( select count(*) as lang_count,country.code,countrylanguage.countrycode
              from country join countrylanguage on (country.code=countrylanguage.countrycode)
              group by country.code,countrylanguage.countrycode order by country.code
            )
            select country.code,country.name, lang_count, country.surfacearea, country.gnp
            from country left outer join lang_total
            on (lang_total.code = country.code)
            where lang_count > ' || min_languages || ' and country.surfacearea > ' || min_area || ' and country.gnp > ' || min_gnp
            || ' order by lang_total.lang_count desc 
           )';
  

  EXECUTE 'SELECT max(lang_count - ' || min_languages || '), max(area - ' || min_area || '), max(gnp - ' || min_gnp || ') FROM countries_results' into lang_delta,area_delta,gnp_delta;
  EXECUTE 'DROP TABLE countries_results';

  RETURN lang_delta +  area_delta +  gnp_delta ;

END;
$$
    LANGUAGE plpgsql volatile MODIFIES SQL DATA;
CREATE OR REPLACE FUNCTION sirv_test6_fun4(gnp_diff float8, opt integer)  RETURNS FLOAT[] AS $$
declare
        res FLOAT[];
	tmp_values FLOAT[];
	gnp_curr_val float8;
        iter INT = 0;
begin
	gnp_curr_val = gnp_diff;

        CREATE TEMP TABLE l_gnp (
                gnp_values FLOAT[]
        ) distributed by(gnp_values);

        CREATE TEMP TABLE h_gnp(
                gnp_values FLOAT[]
        ) distributed by (gnp_values);

       EXECUTE 'INSERT INTO l_gnp SELECT ARRAY(SELECT gnp FROM country where gnp < '  || gnp_diff || ' order by gnp desc)';
       LOOP
		iter = iter + 1;
		TRUNCATE table h_gnp;
		EXECUTE 'SELECT ARRAY(SELECT gnp FROM country where gnp > ' || gnp_curr_val || ' order by gnp desc LIMIT 50)'  INTO tmp_values;
		EXECUTE 'INSERT INTO h_gnp(gnp_values) VALUES(array['|| array_to_string(tmp_values,',') ||'])';		

                IF(iter > 5)THEN
			EXIT;
		ELSE 
		     gnp_curr_val = gnp_curr_val + 500;
		END IF;

	END LOOP;

			
        IF(opt > 0) THEN
	       EXECUTE 'SELECT gnp_values FROM h_gnp' INTO res;
	ELSE
	       EXECUTE 'SELECT gnp_values FROM l_gnp' INTO res;
	END IF;

	EXECUTE 'DROP table l_gnp';
        EXECUTE 'DROP table h_gnp';
	RETURN res;
end
$$ LANGUAGE plpgsql volatile MODIFIES SQL DATA;
--select list
create table sirv_test6_result1 (field1 text, field2 text, field3 float, field4 float[]) distributed by (field1);
create table sirv_test6_result2 (field1 text, field2 text, field3 float, field4 float[]) distributed by (field1);
--start_ignore
explain insert into sirv_test6_result1   select 'sirv_test6_fun1:' || sirv_test6_fun1() as field1,
                                          'sirv_test6_fun2:' || substring(sirv_test6_fun2(2,1000,1000),0,5) as field2,
                                          1.5 * sirv_test6_fun3(2,1000,1000) as field3,
                                          ARRAY[1.0::float,2.0::float] || sirv_test6_fun4(20000,0);
                       QUERY PLAN                       
--------------------------------------------------------
 Insert (slice0; segments: 2)  (rows=1 width=0)
   ->  Result  (cost=0.05..0.07 rows=1 width=0)
         InitPlan  (slice1)
           ->  Result  (cost=0.00..0.01 rows=1 width=0)
         InitPlan  (slice2)
           ->  Result  (cost=0.00..0.01 rows=1 width=0)
         InitPlan  (slice3)
           ->  Result  (cost=0.00..0.01 rows=1 width=0)
         InitPlan  (slice4)
           ->  Result  (cost=0.00..0.01 rows=1 width=0)
(10 rows)

--end_ignore
insert into sirv_test6_result1   select 'sirv_test6_fun1:' || sirv_test6_fun1() as field1,
                                          'sirv_test6_fun2:' || substring(sirv_test6_fun2(2,1000,1000),0,5) as field2,
                                          1.5 * sirv_test6_fun3(2,1000,1000) as field3,
                                          ARRAY[1.0::float,2.0::float] || sirv_test6_fun4(20000,0);
select * from sirv_test6_result1;
        field1        |        field2        |  field3  |                                                                                                                                                                                                                                                                                                                                                                                         field4                                                                                                                                                                                                                                                                                                                                                                                          
----------------------+----------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 sirv_test6_fun1:PASS | sirv_test6_fun2:1017 | 38376165 | {1,2,19770,19756,19008,17843,17121,17000,16904,16321,15846,15706,14194,13714,12178,11863,11705,11500,11345,10692,10226,10162,9472,9333,9217,9174,9131,8571,8444,8287,8255,8005,7526,7137,6964,6871,6648,6398,6366,6353,6313,6232,6064,6041,5976,5951,5749,5493,5333,5332,5328,5121,4988,4834,4787,4768,4401,4397,4251,4173,4127,3750,3563,3527,3512,3501,3459,3377,3205,3101,2891,2841,2731,2642,2425,2357,2352,2328,2223,2108,2036,2012,1990,1988,1941,1813,1706,1694,1687,1630,1626,1579,1536,1449,1292,1263,1208,1206,1197,1119,1061,1054,1043,998,935,903,870,828,818,776,746,722,681,650,630,612,612,571,536,510,435,382,372,334,320,318,299,293,285,283,261,258,256,212,199,197,182,146,141,109,105,100,97,96,63.2,60,40.7,9,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
(1 row)

--from clause
--start_ignore
explain insert into  sirv_test6_result2  select * from     sirv_test6_fun1() as field1,
                                                           substring(sirv_test6_fun2(2,1000,1000),0,5) as field2,
                                                           sirv_test6_fun3(2,1000,1000) as field3,
                                                           sirv_test6_fun4(20000,0);
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Insert (slice0; segments: 2)  (rows=4 width=104)
   ->  Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.09..0.54 rows=7 width=104)
         Hash Key: field1.field1
         ->  Nested Loop  (cost=0.09..0.54 rows=7 width=104)
               InitPlan  (slice5)
                 ->  Result  (cost=0.00..0.01 rows=1 width=0)
               ->  Function Scan on "substring" field2  (cost=0.00..0.01 rows=1 width=32)
               ->  Materialize  (cost=0.45..0.52 rows=4 width=72)
                     ->  Nested Loop  (cost=0.08..0.45 rows=7 width=72)
                           ->  Nested Loop  (cost=0.05..0.15 rows=7 width=64)
                                 ->  Result  (cost=0.01..0.02 rows=1 width=0)
                                       InitPlan  (slice2)
                                         ->  Result  (cost=0.00..0.01 rows=1 width=0)
                                 ->  Materialize  (cost=0.03..0.05 rows=1 width=32)
                                       ->  Result  (cost=0.01..0.02 rows=1 width=0)
                                             InitPlan  (slice3)
                                               ->  Result  (cost=0.00..0.01 rows=1 width=0)
                           ->  Materialize  (cost=0.03..0.05 rows=1 width=8)
                                 ->  Result  (cost=0.01..0.02 rows=1 width=0)
                                       InitPlan  (slice4)
                                         ->  Result  (cost=0.00..0.01 rows=1 width=0)
(21 rows)

--end_ignore
insert into  sirv_test6_result2  select * from     sirv_test6_fun1() as field1,
                                                           substring(sirv_test6_fun2(2,1000,1000),0,5) as field2,
                                                           sirv_test6_fun3(2,1000,1000) as field3,
                                                           sirv_test6_fun4(20000,0);
select * from sirv_test6_result2;
 field1 | field2 |  field3  |                                                                                                                                                                                                                                                                                                                                                                                       field4                                                                                                                                                                                                                                                                                                                                                                                        
--------+--------+----------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PASS   | 1017   | 25584110 | {19770,19756,19008,17843,17121,17000,16904,16321,15846,15706,14194,13714,12178,11863,11705,11500,11345,10692,10226,10162,9472,9333,9217,9174,9131,8571,8444,8287,8255,8005,7526,7137,6964,6871,6648,6398,6366,6353,6313,6232,6064,6041,5976,5951,5749,5493,5333,5332,5328,5121,4988,4834,4787,4768,4401,4397,4251,4173,4127,3750,3563,3527,3512,3501,3459,3377,3205,3101,2891,2841,2731,2642,2425,2357,2352,2328,2223,2108,2036,2012,1990,1988,1941,1813,1706,1694,1687,1630,1626,1579,1536,1449,1292,1263,1208,1206,1197,1119,1061,1054,1043,998,935,903,870,828,818,776,746,722,681,650,630,612,612,571,536,510,435,382,372,334,320,318,299,293,285,283,261,258,256,212,199,197,182,146,141,109,105,100,97,96,63.2,60,40.7,9,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
(1 row)

--start_ignore
drop table if exists sirv_test9_resul1;
NOTICE:  table "sirv_test9_resul1" does not exist, skipping
drop table if exists sirv_test9_result2;
NOTICE:  table "sirv_test9_result2" does not exist, skipping
drop type if exists test9_holder;
NOTICE:  type "test9_holder" does not exist, skipping
drop table if exists test9_countries cascade;
NOTICE:  table "test9_countries" does not exist, skipping
--end_ignore
CREATE  TABLE test9_countries (country_code text, country_name text, lang_count int, area float, gnp float) distributed by (country_code);
CREATE OR REPLACE FUNCTION sirv_test9_fun1 (min_languages integer, min_area float8, min_gnp float8)
  RETURNS setof  test9_countries
AS $$
DECLARE
  lang_delta int;
  area_delta float8;
  gnp_delta float8;
  r test9_countries;
BEGIN

  for r in 
  	   ( with lang_total as
            ( select count(*) as lang_count,country.code,countrylanguage.countrycode
              from country join countrylanguage on (country.code=countrylanguage.countrycode)
              group by country.code,countrylanguage.countrycode order by country.code
            )
            select country.code,country.name, lang_count, country.surfacearea, country.gnp
            from country left outer join lang_total
            on (lang_total.code = country.code)
            where lang_count > min_languages and country.surfacearea >  min_area  and country.gnp > min_gnp order by lang_total.lang_count desc 
           ) loop
  return next r;
  end loop;

  return;
  

END;
$$
    LANGUAGE plpgsql volatile READS SQL DATA;
--ctas with srf should not apply init plan changes. this is not supported
--start_ignore
explain create table sirv_test9_result1 as select sirv_test9_fun1(2,1000,1000) as field1;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named '' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(2 rows)

explain create table sirv_test9_result1 as select * from sirv_test9_fun1(2,1000,1000) as field1;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'country_code' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Redistribute Motion 1:2  (slice1)  (cost=0.00..12.50 rows=2000 width=84)
   Hash Key: country_code
   ->  Function Scan on sirv_test9_fun1 field1  (cost=0.00..12.50 rows=2000 width=84)
(3 rows)

--end_ignore
--should fail
--create table sirv_test9_result1 as select sirv_test9_fun1(2,1000,1000);
--create table sirv_test9_result1 as select * from sirv_test9_fun1(2,1000,1000);
create type test9_holder as (lang_delta int, area_delta float8, gnp_delta float8);
CREATE OR REPLACE FUNCTION sirv_test9_fun2 (res text,min_languages integer, min_area float8, min_gnp float8)
  RETURNS setof text
AS $$
DECLARE
  lang_delta int;
  area_delta float8;
  gnp_delta float8;
  r test9_holder%rowtype;
BEGIN

  EXECUTE 'CREATE  TABLE countries_results (country_code text, country_name text, lang_count int, area float, gnp float) distributed by (country_code)';

  EXECUTE 'INSERT INTO countries_results 
  	   ( with lang_total as
            ( select count(*) as lang_count,country.code,countrylanguage.countrycode
              from country join countrylanguage on (country.code=countrylanguage.countrycode)
              group by country.code,countrylanguage.countrycode order by country.code
            )
            select country.code,country.name, lang_count, country.surfacearea, country.gnp
            from country left outer join lang_total
            on (lang_total.code = country.code)
            where lang_count > ' || min_languages || ' and country.surfacearea > ' || min_area || ' and country.gnp > ' || min_gnp
            || ' order by lang_total.lang_count desc 
           )';
  

  for r in SELECT max(lang_count - min_languages), max(area - min_area),max( gnp -  min_gnp) FROM countries_results group by country_code order by country_code loop
  return next r.lang_delta || r.area_delta || r.gnp_delta;
  end loop;

  EXECUTE 'DROP TABLE countries_results';
  

  RETURN;

END;
$$
    LANGUAGE plpgsql volatile MODIFIES SQL DATA;
--ctas with srf should not apply init plan changes. this is not supported
--start_ignore
explain create table sirv_test9_result1 as select sirv_test9_fun2('result',2,1000,1000) as field1 distributed by (field1);
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.00..0.01 rows=1 width=0)
   Hash Key: field1
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

explain create table sirv_test9_result1 as select * from sirv_test9_fun2('result',2,1000,1000) as field1 distributed by (field1);
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Redistribute Motion 1:2  (slice1)  (cost=0.00..12.50 rows=2000 width=32)
   Hash Key: field1
   ->  Function Scan on sirv_test9_fun2 field1  (cost=0.00..12.50 rows=2000 width=32)
(3 rows)

--end_ignore
--should fail
--create table sirv_test9_result1 as select sirv_test9_fun2('result',2,1000,1000);
--create table sirv_test9_result1 as select * from sirv_test9_fun2('result',2,1000,1000);
--start_ignore
drop table if exists sirv_test10_result1;
NOTICE:  table "sirv_test10_result1" does not exist, skipping
drop table if exists sirv_test10_result2;
NOTICE:  table "sirv_test10_result2" does not exist, skipping
drop table if exists countries cascade;
NOTICE:  table "countries" does not exist, skipping
drop type if exists sirv_test10_holder;
NOTICE:  type "sirv_test10_holder" does not exist, skipping
--end_ignore
CREATE  TABLE countries (country_code text, country_name text, lang_count int, area float, gnp float) distributed by (country_code);
CREATE OR REPLACE FUNCTION sirv_test10_srf1 (min_languages integer, min_area float8, min_gnp float8)
  RETURNS setof  countries
AS $$
DECLARE
  lang_delta int;
  area_delta float8;
  gnp_delta float8;
  r countries;
BEGIN

  for r in 
  	   ( with lang_total as
            ( select count(*) as lang_count,country.code,countrylanguage.countrycode
              from country join countrylanguage on (country.code=countrylanguage.countrycode)
              group by country.code,countrylanguage.countrycode order by country.code
            )
            select country.code,country.name, lang_count, country.surfacearea, country.gnp
            from country left outer join lang_total
            on (lang_total.code = country.code)
            where lang_count > min_languages and country.surfacearea >  min_area  and country.gnp > min_gnp order by lang_total.lang_count desc 
           ) loop
  return next r;
  end loop;

  return;
  

END;
$$
    LANGUAGE plpgsql volatile READS SQL DATA;
--insert select with srf should not apply init plan changes. this is not supported
create table sirv_test10_result1(field1 countries,country_code text,country_name text, lang_count int, area float, gnp float) distributed by (country_code);
--start_ignore
explain insert into sirv_test10_result1 select sirv_test10_srf1(2,1000,1000);
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Insert (slice0; segments: 2)  (rows=1 width=32)
   ->  Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.00..0.02 rows=2 width=32)
         Hash Key: NULL::text
         ->  Subquery Scan "*SELECT*"  (cost=0.00..0.02 rows=2 width=32)
               ->  Result  (cost=0.00..0.01 rows=1 width=0)
(5 rows)

explain insert into sirv_test10_result1 select sirv_test10_srf1 from sirv_test10_srf1(2,1000,1000);
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert (slice0; segments: 2)  (rows=1000 width=32)
   ->  Redistribute Motion 1:2  (slice1)  (cost=0.00..12.50 rows=2000 width=32)
         Hash Key: NULL::text
         ->  Function Scan on sirv_test10_srf1  (cost=0.00..12.50 rows=2000 width=32)
(4 rows)

--end_ignore
--should fail
--ignore error messages
--start_ignore 
insert into sirv_test10_result1 select sirv_test10_srf1(2,1000,1000);
ERROR:  function cannot execute on segment because it accesses relation "public.country" (functions.c:152)  (seg0 slice1 balasr3-mbp.local:40000 pid=47093) (cdbdisp.c:1476)
DETAIL:  
	 SQL statement " ( with lang_total as ( select count(*) as lang_count,country.code,countrylanguage.countrycode from country join countrylanguage on (country.code=countrylanguage.countrycode) group by country.code,countrylanguage.countrycode order by country.code ) select country.code,country.name, lang_count, country.surfacearea, country.gnp from country left outer join lang_total on (lang_total.code = country.code) where lang_count >  $1  and country.surfacearea >  $2  and country.gnp >  $3  order by lang_total.lang_count desc )"
PL/pgSQL function "sirv_test10_srf1" line 8 at for over select rows
insert into sirv_test10_result1 select sirv_test10_srf1 from sirv_test10_srf1(2,1000,1000);
ERROR:  function cannot execute on segment because it accesses relation "public.country" (functions.c:152)  (entry db balasr3-mbp.local:7000 pid=47126) (cdbdisp.c:1476)
DETAIL:  
	 SQL statement " ( with lang_total as ( select count(*) as lang_count,country.code,countrylanguage.countrycode from country join countrylanguage on (country.code=countrylanguage.countrycode) group by country.code,countrylanguage.countrycode order by country.code ) select country.code,country.name, lang_count, country.surfacearea, country.gnp from country left outer join lang_total on (lang_total.code = country.code) where lang_count >  $1  and country.surfacearea >  $2  and country.gnp >  $3  order by lang_total.lang_count desc )"
PL/pgSQL function "sirv_test10_srf1" line 8 at for over select rows
--end_ignore
select * from sirv_test10_result1; --should return 0 rows
 field1 | country_code | country_name | lang_count | area | gnp 
--------+--------------+--------------+------------+------+-----
(0 rows)

--user defined type
create type sirv_test10_holder as (lang_delta int, area_delta float8, gnp_delta float8);
CREATE OR REPLACE FUNCTION sirv_test10_srf2 (res text,min_languages integer, min_area float8, min_gnp float8)
  RETURNS setof text
AS $$
DECLARE
  lang_delta int;
  area_delta float8;
  gnp_delta float8;
  r sirv_test10_holder%rowtype;
BEGIN

  EXECUTE 'CREATE  TABLE countries_results (country_code text, country_name text, lang_count int, area float, gnp float) distributed by (country_code)';

  EXECUTE 'INSERT INTO countries_results 
  	   ( with lang_total as
            ( select count(*) as lang_count,country.code,countrylanguage.countrycode
              from country join countrylanguage on (country.code=countrylanguage.countrycode)
              group by country.code,countrylanguage.countrycode order by country.code
            )
            select country.code,country.name, lang_count, country.surfacearea, country.gnp
            from country left outer join lang_total
            on (lang_total.code = country.code)
            where lang_count > ' || min_languages || ' and country.surfacearea > ' || min_area || ' and country.gnp > ' || min_gnp
            || ' order by lang_total.lang_count desc 
           )';
  

  for r in SELECT max(lang_count - min_languages), max(area - min_area),max( gnp -  min_gnp) FROM countries_results group by country_code order by country_code loop
  return next r.lang_delta || r.area_delta || r.gnp_delta;
  end loop;
  
  EXECUTE 'DROP table countries_results';
  

  RETURN;

END;
$$
    LANGUAGE plpgsql volatile MODIFIES SQL DATA;
create table sirv_test10_result2(res text) distributed by (res);
--insert select with srf should not apply init plan changes. this is not supported
--start_ignore
explain insert into sirv_test10_result2 select sirv_test10_srf2('result',2,1000,1000);
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Insert (slice0; segments: 2)  (rows=1 width=0)
   ->  Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.00..0.01 rows=1 width=0)
         Hash Key: res
         ->  Result  (cost=0.00..0.01 rows=1 width=0)
(4 rows)

explain insert into sirv_test10_result2 select * from sirv_test10_srf2('result',2,1000,1000);
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert (slice0; segments: 2)  (rows=1000 width=32)
   ->  Redistribute Motion 1:2  (slice1)  (cost=0.00..12.50 rows=2000 width=32)
         Hash Key: sirv_test10_srf2.sirv_test10_srf2
         ->  Function Scan on sirv_test10_srf2  (cost=0.00..12.50 rows=2000 width=32)
(4 rows)

--end_ignore
--should fail
--ignore error messages
--start_ignore
insert into sirv_test10_result2 select sirv_test10_srf2('result',2,1000,1000);
ERROR:  function cannot execute on segment because it issues a non-SELECT statement (functions.c:134)  (seg0 slice1 balasr3-mbp.local:40000 pid=47132) (cdbdisp.c:1476)
DETAIL:  
	 SQL statement "CREATE  TABLE countries_results (country_code text, country_name text, lang_count int, area float, gnp float) distributed by (country_code)"
PL/pgSQL function "sirv_test10_srf2" line 8 at execute statement
insert into sirv_test10_result2 select * from sirv_test10_srf2('result',2,1000,1000);
ERROR:  function cannot execute on segment because it issues a non-SELECT statement (functions.c:134)  (entry db balasr3-mbp.local:7000 pid=47126) (cdbdisp.c:1476)
DETAIL:  
	 SQL statement "CREATE  TABLE countries_results (country_code text, country_name text, lang_count int, area float, gnp float) distributed by (country_code)"
PL/pgSQL function "sirv_test10_srf2" line 8 at execute statement
--end_ignore
select * from sirv_test10_result2; --should return 0 rows
 res 
-----
(0 rows)

--start_ignore
drop table if exists sirv_test11_input;
NOTICE:  table "sirv_test11_input" does not exist, skipping
--end_ignore
CREATE OR REPLACE FUNCTION sirv_test11 (min_languages integer, min_area float8, min_gnp float8)
  RETURNS text
AS $$
DECLARE
  lang_delta int;
  area_delta float8;
  gnp_delta float8;
BEGIN

  EXECUTE 'CREATE  TABLE countries_results (country_code text, country_name text, lang_count int, area float, gnp float) distributed by(country_code)';

  EXECUTE 'INSERT INTO countries_results 
  	   ( with lang_total as
            ( select count(*) as lang_count,country.code,countrylanguage.countrycode
              from country join countrylanguage on (country.code=countrylanguage.countrycode)
              group by country.code,countrylanguage.countrycode order by country.code
            )
            select country.code,country.name, lang_count, country.surfacearea, country.gnp
            from country left outer join lang_total
            on (lang_total.code = country.code)
            where lang_count > ' || min_languages || ' and country.surfacearea > ' || min_area || ' and country.gnp > ' || min_gnp
            || ' order by lang_total.lang_count desc 
           )';
  

  EXECUTE 'SELECT max(lang_count - ' || min_languages || '), max(area - ' || min_area || '), max(gnp - ' || min_gnp || ') FROM countries_results' into lang_delta,area_delta,gnp_delta;
  
  EXECUTE 'DROP TABLE countries_results';

  RETURN lang_delta || area_delta || gnp_delta ;

END;
$$
    LANGUAGE plpgsql volatile MODIFIES SQL DATA;
create table sirv_test11_input as select trunc(0.5 * 5) as lang_count,surfacearea, gnp from country where continent = 'Asia' distributed by (lang_count);
--ctas with sirv taking non constant arguments. should not apply init plan changes. 
--start_ignore
explain create table sirv_test11_result1 as select sirv_test11(lang_count::int,surfacearea::float,gnp::float) as res from sirv_test11_input distributed by (res);
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2.02 rows=26 width=19)
   Hash Key: res
   ->  Seq Scan on sirv_test11_input  (cost=0.00..2.02 rows=26 width=19)
(3 rows)

explain create table sirv_test11_result1 as select * from ( select sirv_test11(lang_count::int,surfacearea::float,gnp::float) as res from sirv_test11_input) FOO  distributed by (res);
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2.02 rows=26 width=19)
   Hash Key: res
   ->  Seq Scan on sirv_test11_input  (cost=0.00..2.02 rows=26 width=19)
(3 rows)

--end_ignore
--start_ignore
drop table if exists sirv_test12_input;
NOTICE:  table "sirv_test12_input" does not exist, skipping
drop table if exists sirv_test12_result1;
NOTICE:  table "sirv_test12_result1" does not exist, skipping
--end_ignore
CREATE OR REPLACE FUNCTION sirv_test12 (min_languages integer, min_area float8, min_gnp float8)
  RETURNS text
AS $$
DECLARE
  lang_delta int;
  area_delta float8;
  gnp_delta float8;
BEGIN

  EXECUTE 'CREATE  TABLE countries_results (country_code text, country_name text, lang_count int, area float, gnp float) distributed by(country_code)';

  EXECUTE 'INSERT INTO countries_results 
  	   ( with lang_total as
            ( select count(*) as lang_count,country.code,countrylanguage.countrycode
              from country join countrylanguage on (country.code=countrylanguage.countrycode)
              group by country.code,countrylanguage.countrycode order by country.code
            )
            select country.code,country.name, lang_count, country.surfacearea, country.gnp
            from country left outer join lang_total
            on (lang_total.code = country.code)
            where lang_count > ' || min_languages || ' and country.surfacearea > ' || min_area || ' and country.gnp > ' || min_gnp
            || ' order by lang_total.lang_count desc 
           )';
  

  EXECUTE 'SELECT max(lang_count - ' || min_languages || '), max(area - ' || min_area || '), max(gnp - ' || min_gnp || ') FROM countries_results' into lang_delta,area_delta,gnp_delta;
  
  EXECUTE 'DROP TABLE countries_results';

  RETURN lang_delta || area_delta || gnp_delta ;

END;
$$
    LANGUAGE plpgsql volatile MODIFIES SQL DATA;
create table sirv_test12_input as select trunc(0.5 * 5) as lang_count,surfacearea, gnp from country where continent = 'Asia' distributed by (lang_count);
create table sirv_test12_result1 (res text) distributed by (res);
--insert select with sirv taking non constant arguments. should not apply init plan changes. 
--start_ignore
explain insert into sirv_test12_result1 select sirv_test12(lang_count::int,surfacearea::float,gnp::float) from sirv_test12_input;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Insert (slice0; segments: 2)  (rows=26 width=19)
   ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2.02 rows=26 width=19)
         Hash Key: res
         ->  Seq Scan on sirv_test12_input  (cost=0.00..2.02 rows=26 width=19)
(4 rows)

explain insert into sirv_test12_result1 select * from (select sirv_test12(lang_count::int,surfacearea::float,gnp::float) from sirv_test12_input) FOO;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Insert (slice0; segments: 2)  (rows=26 width=19)
   ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2.02 rows=26 width=19)
         Hash Key: res
         ->  Seq Scan on sirv_test12_input  (cost=0.00..2.02 rows=26 width=19)
(4 rows)

--end_ignore
--should fail
--ignore error messages
--start_ignore
insert into sirv_test12_result1 select sirv_test12(lang_count::int,surfacearea::float,gnp::float) from sirv_test12_input;
ERROR:  function cannot execute on segment because it issues a non-SELECT statement (functions.c:134)  (seg1 slice1 balasr3-mbp.local:40001 pid=47100) (cdbdisp.c:1476)
DETAIL:  
	 SQL statement "CREATE  TABLE countries_results (country_code text, country_name text, lang_count int, area float, gnp float) distributed by(country_code)"
PL/pgSQL function "sirv_test12" line 7 at execute statement
insert into sirv_test12_result1 select * from (select sirv_test12(lang_count::int,surfacearea::float,gnp::float) from sirv_test12_input) FOO;
ERROR:  function cannot execute on segment because it issues a non-SELECT statement (functions.c:134)  (seg1 slice1 balasr3-mbp.local:40001 pid=47102) (cdbdisp.c:1476)
DETAIL:  
	 SQL statement "CREATE  TABLE countries_results (country_code text, country_name text, lang_count int, area float, gnp float) distributed by(country_code)"
PL/pgSQL function "sirv_test12" line 7 at execute statement
--end_ignore
select * from sirv_test12_result1;
 res 
-----
(0 rows)

--start_ignore
drop language if exists plpythonu cascade;
NOTICE:  language "plpythonu" does not exist, skipping
drop table if exists sirv_test13_result1;
NOTICE:  table "sirv_test13_result1" does not exist, skipping
drop table if exists sirv_test13_result2;
NOTICE:  table "sirv_test13_result2" does not exist, skipping
--end_ignore
CREATE LANGUAGE plpythonu;
CREATE or replace FUNCTION sirv_test13_fun1 ()
  RETURNS text
AS $$
  plpy.execute('CREATE TABLE test_data1 (x INT, y INT) distributed by (x)')
  plpy.execute('CREATE TABLE test_data2 (x INT, y VARCHAR) distributed by (x)')

  for i in range(10):
    plpy.execute('INSERT INTO test_data1 VALUES (' + str(i) + ',' + str(i) + ')')

  for i in range(10):
    plpy.execute('INSERT INTO test_data2 VALUES (' + str(i) + ',\'' + str(i) + '\')')

  result1 = plpy.execute ('SELECT CASE WHEN count(*)>0 then \'PASS\' ELSE \'FAIL\' END FROM test_data1')
  result2 = plpy.execute ('SELECT CASE WHEN count(*)>0 then \'PASS\' ELSE \'FAIL\' END FROM test_data2')

  if ((result1 is not None) & (result2 is not None)):
    result3 = 'PASS'
  else:
    result3 = 'FAIL'

  plpy.execute('DROP TABLE test_data1')
  plpy.execute('DROP TABLE test_data2')
  return result3
  
$$ LANGUAGE plpythonu MODIFIES SQL DATA;
CREATE OR REPLACE FUNCTION sirv_test13_fun2(gnp_diff float8, opt integer)  RETURNS FLOAT[] AS $$
  gnp_curr_val = gnp_diff;
  plpy.execute('CREATE TEMP TABLE l_gnp ( gnp_values FLOAT[]) distributed by (gnp_values)')
  plpy.execute('CREATE TEMP TABLE h_gnp ( gnp_values FLOAT[]) distributed by (gnp_values)')

  plpy.execute('INSERT INTO l_gnp SELECT ARRAY(SELECT gnp FROM country where gnp < ' + str(gnp_diff) + ' order by gnp desc)')
  
  gnp_curr_val = gnp_diff

  for i in range(5):
    plpy.execute('TRUNCATE table h_gnp')
    plpy.execute('INSERT INTO h_gnp SELECT ARRAY(SELECT gnp FROM country where gnp > ' +  str(gnp_curr_val) + ' order by gnp desc LIMIT 50)')
    gnp_curr_val = gnp_curr_val + 500

  if(opt > 0):
    res = plpy.execute('SELECT gnp_values from h_gnp')
  else:
    res = plpy.execute('SELECT gnp_values from l_gnp')
  
  plpy.execute('DROP TABLE l_gnp')
  plpy.execute('DROP TABLE h_gnp')
 
  return res[0]["gnp_values"]

$$ LANGUAGE plpythonu MODIFIES SQL DATA;
--select list
--start_ignore
explain create table sirv_test13_result1 as select 'sirv_test1:' || sirv_test13_fun1() as field1,
                                          ARRAY[1.0::float,2.0::float] || sirv_test13_fun2(20000,0) as field2
        distributed by (field1);
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.03..0.04 rows=1 width=0)
   Hash Key: field1
   ->  Result  (cost=0.03..0.04 rows=1 width=0)
         InitPlan  (slice2)
           ->  Result  (cost=0.00..0.01 rows=1 width=0)
         InitPlan  (slice3)
           ->  Result  (cost=0.00..0.01 rows=1 width=0)
(7 rows)

--end_ignore
create table sirv_test13_result1 as select 'sirv_test1:' || sirv_test13_fun1() as field1,
                                          ARRAY[1.0::float,2.0::float] || sirv_test13_fun2(20000,0) as field2
distributed by (field1);
select * from sirv_test13_result1;
     field1      |                                                                                                                                                                                                                                                                                                                                                                                         field2                                                                                                                                                                                                                                                                                                                                                                                          
-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 sirv_test1:PASS | {1,2,19770,19756,19008,17843,17121,17000,16904,16321,15846,15706,14194,13714,12178,11863,11705,11500,11345,10692,10226,10162,9472,9333,9217,9174,9131,8571,8444,8287,8255,8005,7526,7137,6964,6871,6648,6398,6366,6353,6313,6232,6064,6041,5976,5951,5749,5493,5333,5332,5328,5121,4988,4834,4787,4768,4401,4397,4251,4173,4127,3750,3563,3527,3512,3501,3459,3377,3205,3101,2891,2841,2731,2642,2425,2357,2352,2328,2223,2108,2036,2012,1990,1988,1941,1813,1706,1694,1687,1630,1626,1579,1536,1449,1292,1263,1208,1206,1197,1119,1061,1054,1043,998,935,903,870,828,818,776,746,722,681,650,630,612,612,571,536,510,435,382,372,334,320,318,299,293,285,283,261,258,256,212,199,197,182,146,141,109,105,100,97,96,63.2,60,40.7,9,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
(1 row)

--from clause
--start_ignore
explain  create table sirv_test13_result2  as select * from sirv_test13_fun1() as field1,
                                                            sirv_test13_fun2(20000,0) as field2
distributed by (field1);
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.05..0.15 rows=7 width=64)
   Hash Key: field1.field1
   ->  Nested Loop  (cost=0.05..0.15 rows=7 width=64)
         ->  Result  (cost=0.01..0.02 rows=1 width=0)
               InitPlan  (slice2)
                 ->  Result  (cost=0.00..0.01 rows=1 width=0)
         ->  Materialize  (cost=0.03..0.05 rows=1 width=32)
               ->  Result  (cost=0.01..0.02 rows=1 width=0)
                     InitPlan  (slice3)
                       ->  Result  (cost=0.00..0.01 rows=1 width=0)
(10 rows)

--end_ignore
create table sirv_test13_result2  as select * from sirv_test13_fun1() as field1,
                                                            sirv_test13_fun2(20000,0) as field2
distributed by (field1);
select * from sirv_test13_result2;
 field1 |                                                                                                                                                                                                                                                                                                                                                                                       field2                                                                                                                                                                                                                                                                                                                                                                                        
--------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PASS   | {19770,19756,19008,17843,17121,17000,16904,16321,15846,15706,14194,13714,12178,11863,11705,11500,11345,10692,10226,10162,9472,9333,9217,9174,9131,8571,8444,8287,8255,8005,7526,7137,6964,6871,6648,6398,6366,6353,6313,6232,6064,6041,5976,5951,5749,5493,5333,5332,5328,5121,4988,4834,4787,4768,4401,4397,4251,4173,4127,3750,3563,3527,3512,3501,3459,3377,3205,3101,2891,2841,2731,2642,2425,2357,2352,2328,2223,2108,2036,2012,1990,1988,1941,1813,1706,1694,1687,1630,1626,1579,1536,1449,1292,1263,1208,1206,1197,1119,1061,1054,1043,998,935,903,870,828,818,776,746,722,681,650,630,612,612,571,536,510,435,382,372,334,320,318,299,293,285,283,261,258,256,212,199,197,182,146,141,109,105,100,97,96,63.2,60,40.7,9,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
(1 row)

--start_ignore
drop language if exists plpythonu cascade;
NOTICE:  drop cascades to function sirv_test13_fun2(double precision,integer)
NOTICE:  drop cascades to function sirv_test13_fun1()
drop table if exists sirv_test14_result1;
NOTICE:  table "sirv_test14_result1" does not exist, skipping
--end_ignore
CREATE LANGUAGE plpythonu;
CREATE or replace FUNCTION sirv_test14_fun1 ()
  RETURNS text
AS $$
  plpy.execute('CREATE TABLE test_data1 (x INT, y INT) distributed by (x)')
  plpy.execute('CREATE TABLE test_data2 (x INT, y VARCHAR) distributed by (x)')

  for i in range(10):
    plpy.execute('INSERT INTO test_data1 VALUES (' + str(i) + ',' + str(i) + ')')

  for i in range(10):
    plpy.execute('INSERT INTO test_data2 VALUES (' + str(i) + ',\'' + str(i) + '\')')

  result1 = plpy.execute ('SELECT CASE WHEN count(*)>0 then \'PASS\' ELSE \'FAIL\' END FROM test_data1')
  result2 = plpy.execute ('SELECT CASE WHEN count(*)>0 then \'PASS\' ELSE \'FAIL\' END FROM test_data2')

  if ((result1 is not None) & (result2 is not None)):
    result3 = 'PASS'
  else:
    result3 = 'FAIL'

  plpy.execute('DROP TABLE test_data1')
  plpy.execute('DROP TABLE test_data2')
  return result3
  
$$ LANGUAGE plpythonu MODIFIES SQL DATA;
CREATE OR REPLACE FUNCTION sirv_test14_fun2(gnp_diff float8, opt integer)  RETURNS FLOAT[] AS $$
  gnp_curr_val = gnp_diff;
  plpy.execute('CREATE TEMP TABLE l_gnp ( gnp_values FLOAT[]) distributed by (gnp_values)')
  plpy.execute('CREATE TEMP TABLE h_gnp ( gnp_values FLOAT[]) distributed by (gnp_values)')

  plpy.execute('INSERT INTO l_gnp SELECT ARRAY(SELECT gnp FROM country where gnp < ' + str(gnp_diff) + ' order by gnp desc)')
  
  gnp_curr_val = gnp_diff

  for i in range(5):
    plpy.execute('TRUNCATE table h_gnp')
    plpy.execute('INSERT INTO h_gnp SELECT ARRAY(SELECT gnp FROM country where gnp > ' +  str(gnp_curr_val) + ' order by gnp desc LIMIT 50)')
    gnp_curr_val = gnp_curr_val + 500

  if(opt > 0):
    res = plpy.execute('SELECT gnp_values from h_gnp')
  else:
    res = plpy.execute('SELECT gnp_values from l_gnp')
  
  plpy.execute('DROP TABLE l_gnp')
  plpy.execute('DROP TABLE h_gnp')
 
  return res[0]["gnp_values"]

$$ LANGUAGE plpythonu MODIFIES SQL DATA;
--select list
create table sirv_test14_result1 (field1 text, field2 float[]) distributed by (field1);
--start_ignore
explain insert into sirv_test14_result1 select 'sirv_test1:' || sirv_test14_fun1(),
                                          ARRAY[1.0::float,2.0::float] || sirv_test14_fun2(20000,0);
                       QUERY PLAN                       
--------------------------------------------------------
 Insert (slice0; segments: 2)  (rows=1 width=0)
   ->  Result  (cost=0.03..0.04 rows=1 width=0)
         InitPlan  (slice1)
           ->  Result  (cost=0.00..0.01 rows=1 width=0)
         InitPlan  (slice2)
           ->  Result  (cost=0.00..0.01 rows=1 width=0)
(6 rows)

--end_ignore
insert into sirv_test14_result1 select 'sirv_test1:' || sirv_test14_fun1(),
                                          ARRAY[1.0::float,2.0::float] || sirv_test14_fun2(20000,0);
select * from sirv_test14_result1;
     field1      |                                                                                                                                                                                                                                                                                                                                                                                         field2                                                                                                                                                                                                                                                                                                                                                                                          
-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 sirv_test1:PASS | {1,2,19770,19756,19008,17843,17121,17000,16904,16321,15846,15706,14194,13714,12178,11863,11705,11500,11345,10692,10226,10162,9472,9333,9217,9174,9131,8571,8444,8287,8255,8005,7526,7137,6964,6871,6648,6398,6366,6353,6313,6232,6064,6041,5976,5951,5749,5493,5333,5332,5328,5121,4988,4834,4787,4768,4401,4397,4251,4173,4127,3750,3563,3527,3512,3501,3459,3377,3205,3101,2891,2841,2731,2642,2425,2357,2352,2328,2223,2108,2036,2012,1990,1988,1941,1813,1706,1694,1687,1630,1626,1579,1536,1449,1292,1263,1208,1206,1197,1119,1061,1054,1043,998,935,903,870,828,818,776,746,722,681,650,630,612,612,571,536,510,435,382,372,334,320,318,299,293,285,283,261,258,256,212,199,197,182,146,141,109,105,100,97,96,63.2,60,40.7,9,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
(1 row)

--from clause
--start_ignore
explain insert into sirv_test14_result1 select * from sirv_test14_fun1(),sirv_test14_fun2(20000,0);
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Insert (slice0; segments: 2)  (rows=4 width=64)
   ->  Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.05..0.15 rows=7 width=64)
         Hash Key: sirv_test14_fun1.sirv_test14_fun1
         ->  Nested Loop  (cost=0.05..0.15 rows=7 width=64)
               ->  Result  (cost=0.01..0.02 rows=1 width=0)
                     InitPlan  (slice2)
                       ->  Result  (cost=0.00..0.01 rows=1 width=0)
               ->  Materialize  (cost=0.03..0.05 rows=1 width=32)
                     ->  Result  (cost=0.01..0.02 rows=1 width=0)
                           InitPlan  (slice3)
                             ->  Result  (cost=0.00..0.01 rows=1 width=0)
(11 rows)

--end_ignore
insert into sirv_test14_result1 select * from sirv_test14_fun1(),sirv_test14_fun2(20000,0);
select * from sirv_test14_result1;
     field1      |                                                                                                                                                                                                                                                                                                                                                                                         field2                                                                                                                                                                                                                                                                                                                                                                                          
-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 sirv_test1:PASS | {1,2,19770,19756,19008,17843,17121,17000,16904,16321,15846,15706,14194,13714,12178,11863,11705,11500,11345,10692,10226,10162,9472,9333,9217,9174,9131,8571,8444,8287,8255,8005,7526,7137,6964,6871,6648,6398,6366,6353,6313,6232,6064,6041,5976,5951,5749,5493,5333,5332,5328,5121,4988,4834,4787,4768,4401,4397,4251,4173,4127,3750,3563,3527,3512,3501,3459,3377,3205,3101,2891,2841,2731,2642,2425,2357,2352,2328,2223,2108,2036,2012,1990,1988,1941,1813,1706,1694,1687,1630,1626,1579,1536,1449,1292,1263,1208,1206,1197,1119,1061,1054,1043,998,935,903,870,828,818,776,746,722,681,650,630,612,612,571,536,510,435,382,372,334,320,318,299,293,285,283,261,258,256,212,199,197,182,146,141,109,105,100,97,96,63.2,60,40.7,9,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
 PASS            | {19770,19756,19008,17843,17121,17000,16904,16321,15846,15706,14194,13714,12178,11863,11705,11500,11345,10692,10226,10162,9472,9333,9217,9174,9131,8571,8444,8287,8255,8005,7526,7137,6964,6871,6648,6398,6366,6353,6313,6232,6064,6041,5976,5951,5749,5493,5333,5332,5328,5121,4988,4834,4787,4768,4401,4397,4251,4173,4127,3750,3563,3527,3512,3501,3459,3377,3205,3101,2891,2841,2731,2642,2425,2357,2352,2328,2223,2108,2036,2012,1990,1988,1941,1813,1706,1694,1687,1630,1626,1579,1536,1449,1292,1263,1208,1206,1197,1119,1061,1054,1043,998,935,903,870,828,818,776,746,722,681,650,630,612,612,571,536,510,435,382,372,334,320,318,299,293,285,283,261,258,256,212,199,197,182,146,141,109,105,100,97,96,63.2,60,40.7,9,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
(2 rows)

-- start_matchsubs
-- m/psql:.*ERROR:.*/
-- s/psql:.*ERROR:.*/ERROR_MESSAGE/
-- end_matchsubs
--start_ignore
drop table if exists countries_results;
NOTICE:  table "countries_results" does not exist, skipping
--end_ignore
CREATE OR REPLACE FUNCTION sirv_test17_fun1 (min_languages integer, min_area float8, min_gnp float8, OUT lang_delta int, OUT area_delta float8, OUT gnp_delta float8)
AS $$

BEGIN

  EXECUTE 'CREATE  TABLE countries_results (country_code text, country_name text, lang_count int, area float, gnp float) distributed by (country_code)';

  EXECUTE 'INSERT INTO countries_results 
  	   ( with lang_total as
            ( select count(*) as lang_count,country.code,countrylanguage.countrycode
              from country join countrylanguage on (country.code=countrylanguage.countrycode)
              group by country.code,countrylanguage.countrycode order by country.code
            )
            select country.code,country.name, lang_count, country.surfacearea, country.gnp
            from country left outer join lang_total
            on (lang_total.code = country.code)
            where lang_count > ' || min_languages || ' and country.surfacearea > ' || min_area || ' and country.gnp > ' || min_gnp
            || ' order by lang_total.lang_count desc 
           )';
  

  EXECUTE 'SELECT max(lang_count - ' || min_languages || '), max(area - ' || min_area || '), max(gnp - ' || min_gnp || ') FROM countries_results' into lang_delta,area_delta,gnp_delta;
  EXECUTE 'DROP TABLE countries_results';

  RETURN;

END;
$$
    LANGUAGE plpgsql volatile MODIFIES SQL DATA;
--ctas with a function returning anonymous composite type
--should fail , not supported currently.
--function returning record
CREATE  TABLE countries_results (country_code text, country_name text, lang_count int, area float, gnp float) distributed by (country_code);
CREATE OR REPLACE FUNCTION sirv_test17_fun2 (min_languages integer, min_area float8, min_gnp float8) RETURNS record
AS $$
DECLARE

res record;

BEGIN

  EXECUTE 'INSERT INTO countries_results 
  	   ( with lang_total as
            ( select count(*) as lang_count,country.code,countrylanguage.countrycode
              from country join countrylanguage on (country.code=countrylanguage.countrycode)
              group by country.code,countrylanguage.countrycode order by country.code
            )
            select country.code,country.name, lang_count, country.surfacearea, country.gnp
            from country left outer join lang_total
            on (lang_total.code = country.code)
            where lang_count > ' || min_languages || ' and country.surfacearea > ' || min_area || ' and country.gnp > ' || min_gnp
            || ' order by lang_total.lang_count desc 
           )';
  

  EXECUTE 'SELECT max(lang_count - ' || min_languages || '), max(area - ' || min_area || '), max(gnp - ' || min_gnp || ') FROM countries_results' into res;


  RETURN res;

END;
$$
    LANGUAGE plpgsql volatile MODIFIES SQL DATA;
--ctas with a function returning record
--should fail , not supported currently.
DROP TABLE countries_results;
