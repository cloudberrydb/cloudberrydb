-- This file contains global patterns of messages that should be ignored or
-- masked out, when comparing test results with the expected output.
-- Individual tests can contain additional patterns specific to the test.

-- start_matchignore

# Some tests use the gp_inject_fault extension, and create it at the beginning
# of the test. Ignore the NOTICE if it exists already.
m/^NOTICE:  extension "gp_inject_fault" already exists, skipping/

# Some tests use the gp_debug_numsegments extension, and create it at the beginning
# of the test. Ignore the NOTICE if it exists already.
m/NOTICE:  extension "gp_debug_numsegments" already exists, skipping/

m/^ Optimizer status:.*/
m/^ Optimizer: Pivotal Optimizer \(GPORCA\).*/
m/^ Optimizer: Postgres query optimizer/
m/^ Settings:.*/

# There are a number of NOTICE and HINT messages around table distribution,
# for example to inform the user that the database will pick a particular
# column in order to distribute the data. Merging tests from postgres will
# cause the tests to output these messages and we would need to manually
# modify the corresponding expected output. Hence we want to ignore these.
# Some of the messages include:
#
# NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named '<colname>' as the Greenplum Database data distribution key for this table.
# NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
# HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
#
# The following regex is intended to cover all permutations of the above set
# of messages.
m/^(?:HINT|NOTICE):\s+.+\'DISTRIBUTED BY\' clause.*/

# The following NOTICE is generated when a partitioned table is created. For
# each child partition that gets created, it will generate a NOTICE saying that
# it is creating that particular partition. Certain tests add anonymous
# partitions and the names of these anonymous partitions will change across test
# runs.
# E.g CREATE TABLE will create partition "hhh_1_prt_r1987544232" for table "hhh" 
#     CREATE TABLE will create partition "hhh_1_prt_r1987553186" for table "hhh"
m/^NOTICE:.*CREATE TABLE will create partition ".*" for table ".*"/

# The following NOTICE is generated when creating a role. It is to inform the
# user that the database will assign the default resource queue to the role if
# the user has not explicitly specified one. Merging tests from postgres will
# cause the tests to output these messages and we would need to manually modify
# the corresponding expected output. Hence we want to ignore these.
m/^NOTICE:.*resource queue required -- using default resource queue ".*"/

# The following NOTICE is generated when a user creates an index on the parent
# partition table. For each child partition, it informs the user that the
# database will create an index for that partition. The messages might appear in
# different order for the child partitions.
m/^NOTICE:.*building index for child partition ".*"/

# The following NOTICE is generated when a user tries to split a partition or
# exchange a partition with the default partition.
# In case of split partitions we end up creating temp tables to exchange the partitions
# E.g exchanged partition "p1" of relation "parttest_t" with relation "pg_temp_4062621"
m/^NOTICE:.*exchanged partition ".*" with relation ".*"/

m/^WARNING:  could not close temporary file .*: No such file or directory/

# Messages when resource group is enabled:
# WARNING:  resource queue is disabled
# HINT:  To enable set gp_resource_manager=queue
# NOTICE:  resource group required -- using default resource group "default_group"
m/^WARNING:  resource queue is disabled$/
m/^HINT:  To enable set gp_resource_manager=queue$/
m/^NOTICE:  resource group required -- using .* resource group ".*"$/

# The following WARNING is generated by ANALYZE when some sample tuples are
# from segments outside the [0, numsegments-1] range, however this does not
# indicate the data distribution is wrong.  Take inherited tables for example,
# when inherited tables has greater numsegments than parent this WARNING will
# be raised, and it is expected.  This could happen normally on the
# random_numsegments pipeline job, so ignore this WARNING.
m/^WARNING:  table ".*" contains rows in segment .*, which is outside the # of segments for the table's policy \(\d+ segments\)$/

# The following output is generated by \d on foreign tables, so ignore it.
m/Distributed by: \(.*\)/
-- end_matchignore

-- start_matchsubs
# entry db matches
m/\s+\(entry db(.*)+\spid=\d+\)/
s/\s+\(entry db(.*)+\spid=\d+\)//

# Mask out some numbers (parts of partition names) that vary from run to run.
m/overlaps existing partition "r\d+"/
s/overlaps existing partition "r\d+"/partition "r##########"/

# Mask out some numbers (part of temp table schema) that vary from run to run.
m/Table "pg_temp_\d+.temp/
s/Table "pg_temp_\d+.temp/Table "pg_temp_#####/

# Mask out some numbers (part of temp table schema) that vary from run to run.
m/Hash Cond: \(pg_temp_\d+/
s/Hash Cond: \(pg_temp_\d+/Hash Cond: \(pg_temp_#####/

# Mask out oid in error concurrent drop message
m/\d+ was concurrently dropped/
s/\d+ was concurrently dropped/##### was concurrently dropped/

# Mask out linenumber of the erroring file
m/ERROR:  ANALYZE cannot merge since not all non-empty leaf partitions have consistent hyperloglog statistics for merge.*/
s/ERROR:  ANALYZE cannot merge since not all non-empty leaf partitions have consistent hyperloglog statistics for merge.*/ERROR:  ANALYZE cannot merge since not all non-empty leaf partitions have consistent hyperloglog statistics for merge (analyze.c:XXX)/

m/ERROR:  invalid partition constraint on "[^"]+".*/
s/ERROR:  invalid partition constraint on "[^"]+".*/ERROR:  invalid partition constraint on "[^"]+".*(cdbpartition.c:XXX)/

# Mask out gp_execution_segment()
m/One-Time Filter: \(gp_execution_segment\(\) = \d+/
s/One-Time Filter: \(gp_execution_segment\(\) = \d+/One-Time Filter: \(gp_execution_segment\(\) = ###/

m/ERROR:  infinite recursion detected.*/
s/ERROR:  infinite recursion detected.*/ERROR:  infinite recursion detected/

m/ERROR:  could not find hash function for hash operator.*/
s/ERROR:  could not find hash function for hash operator.*/ERROR:  could not find hash function for hash operator/

m/nodename nor servname provided, or not known/
s/nodename nor servname provided, or not known/Name or service not known/

-- end_matchsubs
