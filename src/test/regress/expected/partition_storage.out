--Create a heap table with partitions ( having diff storage parameters)
 Create table  pt_heap_tab(a int, b text, c int , d int, e numeric,success bool) with ( appendonly=false )
 distributed by (a)
 partition by list(b)
 (
          partition abc values ('abc','abc1','abc2') with (appendonly=false), -- HEAP
          partition def values ('def','def1','def3') with (appendonly=true, compresslevel=1), 
          partition ghi values ('ghi','ghi1','ghi2') with (appendonly=true), -- AO
          default partition dft
 );
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_1_prt_abc" for table "pt_heap_tab"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_1_prt_def" for table "pt_heap_tab"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_1_prt_ghi" for table "pt_heap_tab"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_1_prt_dft" for table "pt_heap_tab"
--Create indexes on the table
 -- Partial index
--start_ignore
drop index if exists heap_idx1 cascade;
NOTICE:  index "heap_idx1" does not exist, skipping
drop index if exists heap_idx2 cascade;
NOTICE:  index "heap_idx2" does not exist, skipping
--end_ignore
 create index heap_idx1 on pt_heap_tab(a) where c > 10;
NOTICE:  building index for child partition "pt_heap_tab_1_prt_abc"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_def"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_ghi"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_dft"
 -- Expression index
 create index heap_idx2 on pt_heap_tab(upper(b));
NOTICE:  building index for child partition "pt_heap_tab_1_prt_abc"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_def"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_ghi"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_dft"
--Drop partition
 alter table pt_heap_tab drop default partition;
NOTICE:  dropped partition "dft" for relation "pt_heap_tab"
--Add partition
 alter table pt_heap_tab add partition xyz values ('xyz','xyz1','xyz2') WITH (appendonly=true, orientation=column, compresslevel=5); -- CO
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_1_prt_xyz" for table "pt_heap_tab"
 alter table pt_heap_tab add partition jkl values ('jkl','jkl1','jkl2') WITH (appendonly=true); -- AO
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_1_prt_jkl" for table "pt_heap_tab"
 alter table pt_heap_tab add partition mno values ('mno','mno1','mno2') WITH (appendonly=false); --Heap
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_1_prt_mno" for table "pt_heap_tab"
--Check properties of the added partition tables
 select oid::regclass, relkind, relstorage, reloptions from pg_class where oid in ( select oid from pg_class where   relname in  ( 'pt_heap_tab_1_prt_xyz', 'pt_heap_tab_1_prt_jkl','pt_heap_tab_1_prt_mno'));
          oid          | relkind | relstorage |                      reloptions                      
-----------------------+---------+------------+------------------------------------------------------
 pt_heap_tab_1_prt_xyz | r       | c          | {appendonly=true,orientation=column,compresslevel=5}
 pt_heap_tab_1_prt_jkl | r       | a          | {appendonly=true}
 pt_heap_tab_1_prt_mno | r       | h          | {appendonly=false}
(3 rows)

--Insert Data
 insert into pt_heap_tab select 1, 'xyz', 1, 1, 1.0 , true from generate_series(1, 10);
 insert into pt_heap_tab select 1, 'abc', 1, 1, 1.0 , true from generate_series(1, 10);
 insert into pt_heap_tab select 1, 'def', 1, 1, 1.0 , true from generate_series(1, 10);
 insert into pt_heap_tab select 1, 'ghi', 1, 1, 1.0 , true from generate_series(1, 10);
 insert into pt_heap_tab select 1, 'jkl', 1, 1, 1.0 , true from generate_series(1, 10);
 insert into pt_heap_tab select 1, 'mno', 1, 1, 1.0 , true from generate_series(1, 10);
--Split partition [Creates new partitions to be of the same type as the parent partition. All heap partitions created]
 alter table pt_heap_tab split partition abc at ('abc1') into ( partition abc1,partition abc2); -- Heap
NOTICE:  exchanged partition "abc" of relation "pt_heap_tab" with relation "pg_temp_3270131"
NOTICE:  dropped partition "abc" for relation "pt_heap_tab"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_1_prt_abc1" for table "pt_heap_tab"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_1_prt_abc2" for table "pt_heap_tab"
 alter table pt_heap_tab split partition ghi at ('ghi1') into ( partition ghi1,partition ghi2); --AO
NOTICE:  exchanged partition "ghi" of relation "pt_heap_tab" with relation "pg_temp_3270131"
NOTICE:  dropped partition "ghi" for relation "pt_heap_tab"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_1_prt_ghi1" for table "pt_heap_tab"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_1_prt_ghi2" for table "pt_heap_tab"
 alter table pt_heap_tab split partition xyz at ('xyz1') into ( partition xyz1,partition xyz2); --CO
NOTICE:  exchanged partition "xyz" of relation "pt_heap_tab" with relation "pg_temp_3270131"
NOTICE:  dropped partition "xyz" for relation "pt_heap_tab"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_1_prt_xyz1" for table "pt_heap_tab"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_1_prt_xyz2" for table "pt_heap_tab"
--Check the storage type and properties of the split partition
 select oid::regclass, relkind, relstorage, reloptions from pg_class where oid in ( select oid from pg_class where   relname in ('pt_heap_tab_1_prt_xyz1','pt_heap_tab_1_prt_xyz2','pt_heap_tab_1_prt_ghi1','pt_heap_tab_1_prt_ghi2','pt_heap_tab_1_prt_abc1','pt_heap_tab_1_prt_abc2'));
          oid           | relkind | relstorage |                      reloptions                      
------------------------+---------+------------+------------------------------------------------------
 pt_heap_tab_1_prt_abc1 | r       | h          | {appendonly=false}
 pt_heap_tab_1_prt_abc2 | r       | h          | {appendonly=false}
 pt_heap_tab_1_prt_ghi1 | r       | a          | {appendonly=true}
 pt_heap_tab_1_prt_ghi2 | r       | a          | {appendonly=true}
 pt_heap_tab_1_prt_xyz1 | r       | c          | {appendonly=true,orientation=column,compresslevel=5}
 pt_heap_tab_1_prt_xyz2 | r       | c          | {appendonly=true,orientation=column,compresslevel=5}
(6 rows)

--Exchange partition
 -- Create candidate table
--start_ignore
drop table if exists heap_can cascade;
drop table if exists ao_can cascade;
drop table if exists co_can cascade;
--end_ignore
 create table heap_can(like pt_heap_tab);  
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
 create table ao_can(like pt_heap_tab) with (appendonly=true);   
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
 create table co_can(like pt_heap_tab)  with (appendonly=true,orientation=column);   
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
 -- Exchange
 alter table pt_heap_tab exchange partition for ('abc') with table ao_can ; -- Heap exchanged with  AO
NOTICE:  exchanged partition "abc1" of relation "pt_heap_tab" with relation "ao_can"
 alter table pt_heap_tab add partition pqr values ('pqr','pqr1','pqr2') WITH (appendonly=true, orientation=column, compresslevel=5);
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_1_prt_pqr" for table "pt_heap_tab"
 alter table pt_heap_tab exchange partition for ('def') with table co_can; -- AO exchanged with CO
NOTICE:  exchanged partition "def" of relation "pt_heap_tab" with relation "co_can"
 alter table pt_heap_tab exchange partition for ('pqr') with table heap_can; -- CO exchanged with Heap
NOTICE:  exchanged partition "pqr" of relation "pt_heap_tab" with relation "heap_can"
--Check for the storage properties and indexes of the two tables involved in the exchange
 \d+ heap_can
                                Append-Only Columnar Table "public.heap_can"
 Column  |  Type   | Modifiers | Storage  | Compression Type | Compression Level | Block Size | Description 
---------+---------+-----------+----------+------------------+-------------------+------------+-------------
 a       | integer |           | plain    | zlib             | 5                 | 32768      | 
 b       | text    |           | extended | zlib             | 5                 | 32768      | 
 c       | integer |           | plain    | zlib             | 5                 | 32768      | 
 d       | integer |           | plain    | zlib             | 5                 | 32768      | 
 e       | numeric |           | main     | zlib             | 5                 | 32768      | 
 success | boolean |           | plain    | zlib             | 5                 | 32768      | 
Checksum: t
Indexes:
    "pt_heap_tab_1_prt_pqr_a_key" btree (a) WHERE c > 10
    "pt_heap_tab_1_prt_pqr_key" btree (upper(b))
Check constraints:
    "pt_heap_tab_1_prt_pqr_check" CHECK (b = 'pqr'::text OR b = 'pqr1'::text OR b = 'pqr2'::text)
Has OIDs: no
Options: appendonly=true, orientation=column, compresslevel=5
Distributed by: (a)

 \d+ co_can
           Append-Only Table "public.co_can"
 Column  |  Type   | Modifiers | Storage  | Description 
---------+---------+-----------+----------+-------------
 a       | integer |           | plain    | 
 b       | text    |           | extended | 
 c       | integer |           | plain    | 
 d       | integer |           | plain    | 
 e       | numeric |           | main     | 
 success | boolean |           | plain    | 
Compression Type: zlib
Compression Level: 1
Block Size: 32768
Checksum: t
Indexes:
    "heap_idx1_1_prt_def" btree (a) WHERE c > 10
    "heap_idx2_1_prt_def" btree (upper(b))
Check constraints:
    "pt_heap_tab_1_prt_def_check" CHECK (b = 'def'::text OR b = 'def1'::text OR b = 'def3'::text)
Has OIDs: no
Options: appendonly=true, compresslevel=1
Distributed by: (a)

 \d+ ao_can
                 Table "public.ao_can"
 Column  |  Type   | Modifiers | Storage  | Description 
---------+---------+-----------+----------+-------------
 a       | integer |           | plain    | 
 b       | text    |           | extended | 
 c       | integer |           | plain    | 
 d       | integer |           | plain    | 
 e       | numeric |           | main     | 
 success | boolean |           | plain    | 
Indexes:
    "pt_heap_tab_1_prt_abc1_a_key" btree (a) WHERE c > 10
    "pt_heap_tab_1_prt_abc1_key" btree (upper(b))
Check constraints:
    "pt_heap_tab_1_prt_abc1_check" CHECK (b = 'abc'::text OR b = 'abc2'::text)
Has OIDs: no
Options: appendonly=false
Distributed by: (a)

--Further operations
 alter table pt_heap_tab drop partition jkl;
 truncate table pt_heap_tab;
--Further create some more indexes
--start_ignore
drop index if exists heap_idx3 cascade;
NOTICE:  index "heap_idx3" does not exist, skipping
drop index if exists heap_idx4 cascade;
NOTICE:  index "heap_idx4" does not exist, skipping
--end_ignore
 create index heap_idx3 on pt_heap_tab(c,d) where a = 40 OR a = 50; -- multicol indx
NOTICE:  building index for child partition "pt_heap_tab_1_prt_mno"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_abc2"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_ghi1"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_ghi2"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_xyz1"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_xyz2"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_abc1"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_def"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_pqr"
 CREATE INDEX heap_idx4 ON pt_heap_tab ((b || ' ' || e)); --Expression
NOTICE:  building index for child partition "pt_heap_tab_1_prt_mno"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_abc2"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_ghi1"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_ghi2"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_xyz1"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_xyz2"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_abc1"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_def"
NOTICE:  building index for child partition "pt_heap_tab_1_prt_pqr"
--Add default partition
 alter table pt_heap_tab add default partition dft;
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_1_prt_dft" for table "pt_heap_tab"
--Split default partition
 alter table pt_heap_tab split default partition at ('uvw') into (partition dft, partition uvw);
NOTICE:  exchanged partition "dft" of relation "pt_heap_tab" with relation "pg_temp_3270131"
NOTICE:  dropped partition "dft" for relation "pt_heap_tab"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_1_prt_uvw" for table "pt_heap_tab"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_1_prt_dft" for table "pt_heap_tab"
--Create an AO table with partitions ( having diff storage parameters)
--start_ignore
 drop table if exists pt_ao_tab cascade;
--end_ignore
 Create table  pt_ao_tab(a int, b text, c int , d int, e numeric,success bool) with ( appendonly=true )
 distributed by (a)
 partition by list(b)
 (
          partition abc values ('abc','abc1','abc2') with (appendonly=false), -- HEAP
          partition def values ('def','def1','def3') with (appendonly=true, compresslevel=1), 
          partition ghi values ('ghi','ghi1','ghi2') with (appendonly=true), -- AO
          default partition dft
 );
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_1_prt_abc" for table "pt_ao_tab"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_1_prt_def" for table "pt_ao_tab"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_1_prt_ghi" for table "pt_ao_tab"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_1_prt_dft" for table "pt_ao_tab"
--Create indexes on the table
 -- Partial index
--start_ignore
drop index if exists ao_idx1 cascade;
NOTICE:  index "ao_idx1" does not exist, skipping
drop index if exists ao_idx2 cascade;
NOTICE:  index "ao_idx2" does not exist, skipping
--end_ignore
 create index ao_idx1 on pt_ao_tab(a) where c > 10;
NOTICE:  building index for child partition "pt_ao_tab_1_prt_abc"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_def"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_ghi"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_dft"
 -- Expression index
 create index ao_idx2 on pt_ao_tab(upper(b));
NOTICE:  building index for child partition "pt_ao_tab_1_prt_abc"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_def"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_ghi"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_dft"
--Drop partition
 alter table pt_ao_tab drop default partition;
NOTICE:  dropped partition "dft" for relation "pt_ao_tab"
--Add partition
 alter table pt_ao_tab add partition xyz values ('xyz','xyz1','xyz2') WITH (appendonly=true,orientation=column,compresslevel=5); --CO
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_1_prt_xyz" for table "pt_ao_tab"
 alter table pt_ao_tab add partition jkl values ('jkl','jkl1','jkl2') WITH (appendonly=true); -- AO
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_1_prt_jkl" for table "pt_ao_tab"
 alter table pt_ao_tab add partition mno values ('mno','mno1','mno2') WITH (appendonly=false); --Heap
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_1_prt_mno" for table "pt_ao_tab"
--Check properties of the added partition tables
 select oid::regclass, relkind, relstorage, reloptions from pg_class where oid in ( select oid from pg_class where   relname in  ( 'pt_ao_tab_1_prt_xyz', 'pt_ao_tab_1_prt_jkl','pt_ao_tab_1_prt_mno'));
         oid         | relkind | relstorage |                      reloptions                      
---------------------+---------+------------+------------------------------------------------------
 pt_ao_tab_1_prt_xyz | r       | c          | {appendonly=true,orientation=column,compresslevel=5}
 pt_ao_tab_1_prt_jkl | r       | a          | {appendonly=true}
 pt_ao_tab_1_prt_mno | r       | h          | {appendonly=false}
(3 rows)

--Insert Data
 insert into pt_ao_tab select 1, 'xyz', 1, 1, 1.0 , true from generate_series(1, 10);
 insert into pt_ao_tab select 1, 'abc', 1, 1, 1.0 , true from generate_series(1, 10);
 insert into pt_ao_tab select 1, 'def', 1, 1, 1.0 , true from generate_series(1, 10);
 insert into pt_ao_tab select 1, 'ghi', 1, 1, 1.0 , true from generate_series(1, 10);
 insert into pt_ao_tab select 1, 'jkl', 1, 1, 1.0 , true from generate_series(1, 10);
 insert into pt_ao_tab select 1, 'mno', 1, 1, 1.0 , true from generate_series(1, 10);
--Split partition [Creates new partitions to be of the same type as the parent partition. All heap partitions created]
 alter table pt_ao_tab split partition abc at ('abc1') into ( partition abc1,partition abc2); -- Heap
NOTICE:  exchanged partition "abc" of relation "pt_ao_tab" with relation "pg_temp_3272908"
NOTICE:  dropped partition "abc" for relation "pt_ao_tab"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_1_prt_abc1" for table "pt_ao_tab"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_1_prt_abc2" for table "pt_ao_tab"
 alter table pt_ao_tab split partition ghi at ('ghi1') into ( partition ghi1,partition ghi2); --AO
NOTICE:  exchanged partition "ghi" of relation "pt_ao_tab" with relation "pg_temp_3272908"
NOTICE:  dropped partition "ghi" for relation "pt_ao_tab"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_1_prt_ghi1" for table "pt_ao_tab"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_1_prt_ghi2" for table "pt_ao_tab"
 alter table pt_ao_tab split partition xyz at ('xyz1') into ( partition xyz1,partition xyz2); --CO
NOTICE:  exchanged partition "xyz" of relation "pt_ao_tab" with relation "pg_temp_3272908"
NOTICE:  dropped partition "xyz" for relation "pt_ao_tab"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_1_prt_xyz1" for table "pt_ao_tab"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_1_prt_xyz2" for table "pt_ao_tab"
--Check the storage type and properties of the split partition
 select oid::regclass, relkind, relstorage, reloptions from pg_class where oid in (select oid from pg_class where relname in ('pt_ao_tab_1_prt_xyz1','pt_ao_tab_1_prt_xyz2','pt_ao_tab_1_prt_ghi1','pt_ao_tab_1_prt_ghi2','pt_ao_tab_1_prt_abc1','pt_ao_tab_1_prt_abc2'));
         oid          | relkind | relstorage |                      reloptions                      
----------------------+---------+------------+------------------------------------------------------
 pt_ao_tab_1_prt_abc1 | r       | h          | {appendonly=false}
 pt_ao_tab_1_prt_abc2 | r       | h          | {appendonly=false}
 pt_ao_tab_1_prt_ghi1 | r       | a          | {appendonly=true}
 pt_ao_tab_1_prt_ghi2 | r       | a          | {appendonly=true}
 pt_ao_tab_1_prt_xyz1 | r       | c          | {appendonly=true,orientation=column,compresslevel=5}
 pt_ao_tab_1_prt_xyz2 | r       | c          | {appendonly=true,orientation=column,compresslevel=5}
(6 rows)

--Exchange partition
 -- Create candidate table
--start_ignore
drop table if exists heap_can cascade;
drop table if exists ao_can cascade;
drop table if exists co_can cascade;
--end_ignore
 create table heap_can(like pt_ao_tab);  
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
 create table ao_can(like pt_ao_tab) with (appendonly=true);   
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
 create table co_can(like pt_ao_tab)  with (appendonly=true,orientation=column);   
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
 -- Exchange
 alter table pt_ao_tab add partition pqr values ('pqr','pqr1','pqr2') WITH (appendonly=true,orientation=column,compresslevel=5);-- CO
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_1_prt_pqr" for table "pt_ao_tab"
 alter table pt_ao_tab add partition stu values ('stu','stu1','stu2') WITH (appendonly=false);-- heap
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_1_prt_stu" for table "pt_ao_tab"
 alter table pt_ao_tab exchange partition for ('stu') with table ao_can ;-- Heap tab exchanged with  AO
NOTICE:  exchanged partition "stu" of relation "pt_ao_tab" with relation "ao_can"
 alter table pt_ao_tab exchange partition for ('def') with table co_can; --AO tab exchanged with CO
NOTICE:  exchanged partition "def" of relation "pt_ao_tab" with relation "co_can"
 alter table pt_ao_tab exchange partition for ('pqr') with table heap_can; --CO tab exchanged with Heap
NOTICE:  exchanged partition "pqr" of relation "pt_ao_tab" with relation "heap_can"
--Check for the storage properties and indexes of the two tables involved in the exchange
 \d+ heap_can
                                Append-Only Columnar Table "public.heap_can"
 Column  |  Type   | Modifiers | Storage  | Compression Type | Compression Level | Block Size | Description 
---------+---------+-----------+----------+------------------+-------------------+------------+-------------
 a       | integer |           | plain    | zlib             | 5                 | 32768      | 
 b       | text    |           | extended | zlib             | 5                 | 32768      | 
 c       | integer |           | plain    | zlib             | 5                 | 32768      | 
 d       | integer |           | plain    | zlib             | 5                 | 32768      | 
 e       | numeric |           | main     | zlib             | 5                 | 32768      | 
 success | boolean |           | plain    | zlib             | 5                 | 32768      | 
Checksum: t
Indexes:
    "pt_ao_tab_1_prt_pqr_a_key" btree (a) WHERE c > 10
    "pt_ao_tab_1_prt_pqr_key" btree (upper(b))
Check constraints:
    "pt_ao_tab_1_prt_pqr_check" CHECK (b = 'pqr'::text OR b = 'pqr1'::text OR b = 'pqr2'::text)
Has OIDs: no
Options: appendonly=true, orientation=column, compresslevel=5
Distributed by: (a)

 \d+ co_can
           Append-Only Table "public.co_can"
 Column  |  Type   | Modifiers | Storage  | Description 
---------+---------+-----------+----------+-------------
 a       | integer |           | plain    | 
 b       | text    |           | extended | 
 c       | integer |           | plain    | 
 d       | integer |           | plain    | 
 e       | numeric |           | main     | 
 success | boolean |           | plain    | 
Compression Type: zlib
Compression Level: 1
Block Size: 32768
Checksum: t
Indexes:
    "ao_idx1_1_prt_def" btree (a) WHERE c > 10
    "ao_idx2_1_prt_def" btree (upper(b))
Check constraints:
    "pt_ao_tab_1_prt_def_check" CHECK (b = 'def'::text OR b = 'def1'::text OR b = 'def3'::text)
Has OIDs: no
Options: appendonly=true, compresslevel=1
Distributed by: (a)

 \d+ ao_can
                 Table "public.ao_can"
 Column  |  Type   | Modifiers | Storage  | Description 
---------+---------+-----------+----------+-------------
 a       | integer |           | plain    | 
 b       | text    |           | extended | 
 c       | integer |           | plain    | 
 d       | integer |           | plain    | 
 e       | numeric |           | main     | 
 success | boolean |           | plain    | 
Indexes:
    "pt_ao_tab_1_prt_stu_a_key" btree (a) WHERE c > 10
    "pt_ao_tab_1_prt_stu_key" btree (upper(b))
Check constraints:
    "pt_ao_tab_1_prt_stu_check" CHECK (b = 'stu'::text OR b = 'stu1'::text OR b = 'stu2'::text)
Has OIDs: no
Options: appendonly=false
Distributed by: (a)

--Further operations
 alter table pt_ao_tab drop partition jkl;
 truncate table pt_ao_tab;
--Further create some more indexes
--start_ignore
drop index if exists ao_idx4 cascade;
NOTICE:  index "ao_idx4" does not exist, skipping
drop index if exists ao_idx3 cascade;
NOTICE:  index "ao_idx3" does not exist, skipping
--end_ignore
 create index ao_idx3 on pt_ao_tab(c,d) where a = 40 OR a = 50; -- multicol indx
NOTICE:  building index for child partition "pt_ao_tab_1_prt_mno"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_abc1"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_abc2"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_ghi1"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_ghi2"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_xyz1"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_xyz2"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_stu"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_def"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_pqr"
 CREATE INDEX ao_idx4 ON pt_ao_tab ((b || ' ' || e)); --Expression
NOTICE:  building index for child partition "pt_ao_tab_1_prt_mno"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_abc1"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_abc2"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_ghi1"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_ghi2"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_xyz1"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_xyz2"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_stu"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_def"
NOTICE:  building index for child partition "pt_ao_tab_1_prt_pqr"
--Add default partition
 alter table pt_ao_tab add default partition dft;
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_1_prt_dft" for table "pt_ao_tab"
--Split default partition
 alter table pt_ao_tab split default partition at ('uvw') into (partition dft, partition uvw);
NOTICE:  exchanged partition "dft" of relation "pt_ao_tab" with relation "pg_temp_3272908"
NOTICE:  dropped partition "dft" for relation "pt_ao_tab"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_1_prt_uvw" for table "pt_ao_tab"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_1_prt_dft" for table "pt_ao_tab"
--Create an CO table with partitions ( having diff storage parameters)
--start_ignore
 drop table if exists pt_co_tab cascade;
--end_ignore
Create table  pt_co_tab(a int, b text, c int , d int, e numeric,success bool) with ( appendonly = true, orientation = column)
 distributed by (a)
 partition by list(b)
 (
          partition abc values ('abc','abc1','abc2') with (appendonly=false), -- HEAP
          partition def values ('def','def1','def3') with (appendonly=true, compresslevel=1), 
          partition ghi values ('ghi','ghi1','ghi2') with (appendonly=true), -- AO
          default partition dft
 );
NOTICE:  CREATE TABLE will create partition "pt_co_tab_1_prt_abc" for table "pt_co_tab"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_1_prt_def" for table "pt_co_tab"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_1_prt_ghi" for table "pt_co_tab"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_1_prt_dft" for table "pt_co_tab"
--Create indexes on the table
--start_ignore
drop index if exists co_idx1 cascade;
NOTICE:  index "co_idx1" does not exist, skipping
drop index if exists co_idx2 cascade;
NOTICE:  index "co_idx2" does not exist, skipping
--end_ignore
 -- Partial index
 create index co_idx1 on pt_co_tab(a) where c > 10;
NOTICE:  building index for child partition "pt_co_tab_1_prt_abc"
NOTICE:  building index for child partition "pt_co_tab_1_prt_def"
NOTICE:  building index for child partition "pt_co_tab_1_prt_ghi"
NOTICE:  building index for child partition "pt_co_tab_1_prt_dft"
 -- Expression index
 create index co_idx2 on pt_co_tab(upper(b));
NOTICE:  building index for child partition "pt_co_tab_1_prt_abc"
NOTICE:  building index for child partition "pt_co_tab_1_prt_def"
NOTICE:  building index for child partition "pt_co_tab_1_prt_ghi"
NOTICE:  building index for child partition "pt_co_tab_1_prt_dft"
--Drop partition
 alter table pt_co_tab drop default partition;
NOTICE:  dropped partition "dft" for relation "pt_co_tab"
--Add partition
 alter table pt_co_tab add partition xyz values ('xyz','xyz1','xyz2') WITH (appendonly=true,orientation=column,compresslevel=5); --CO
NOTICE:  CREATE TABLE will create partition "pt_co_tab_1_prt_xyz" for table "pt_co_tab"
 alter table pt_co_tab add partition jkl values ('jkl','jkl1','jkl2') WITH (appendonly=true,compresslevel=1); -- AO
NOTICE:  CREATE TABLE will create partition "pt_co_tab_1_prt_jkl" for table "pt_co_tab"
 alter table pt_co_tab add partition mno values ('mno','mno1','mno2') WITH (appendonly=false); --Heap
NOTICE:  CREATE TABLE will create partition "pt_co_tab_1_prt_mno" for table "pt_co_tab"
--Check properties of the added partition tables
 select oid::regclass, relkind, relstorage, reloptions from pg_class where oid in ( select oid from pg_class where   relname in  ( 'pt_co_tab_1_prt_xyz', 'pt_co_tab_1_prt_jkl','pt_co_tab_1_prt_mno'));
         oid         | relkind | relstorage |                      reloptions                      
---------------------+---------+------------+------------------------------------------------------
 pt_co_tab_1_prt_xyz | r       | c          | {appendonly=true,orientation=column,compresslevel=5}
 pt_co_tab_1_prt_jkl | r       | a          | {appendonly=true,compresslevel=1}
 pt_co_tab_1_prt_mno | r       | h          | {appendonly=false}
(3 rows)

--Insert Data
 insert into pt_co_tab select 1, 'xyz', 1, 1, 1.0 , true from generate_series(1, 10);
 insert into pt_co_tab select 1, 'abc', 1, 1, 1.0 , true from generate_series(1, 10);
 insert into pt_co_tab select 1, 'def', 1, 1, 1.0 , true from generate_series(1, 10);
 insert into pt_co_tab select 1, 'ghi', 1, 1, 1.0 , true from generate_series(1, 10);
 insert into pt_co_tab select 1, 'jkl', 1, 1, 1.0 , true from generate_series(1, 10);
 insert into pt_co_tab select 1, 'mno', 1, 1, 1.0 , true from generate_series(1, 10);
--Split partition [Creates new partitions to be of the same type as the parent partition. All heap partitions created]
 alter table pt_co_tab split partition abc at ('abc1') into ( partition abc1,partition abc2); -- Heap
NOTICE:  exchanged partition "abc" of relation "pt_co_tab" with relation "pg_temp_3275836"
NOTICE:  dropped partition "abc" for relation "pt_co_tab"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_1_prt_abc1" for table "pt_co_tab"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_1_prt_abc2" for table "pt_co_tab"
 alter table pt_co_tab split partition ghi at ('ghi1') into ( partition ghi1,partition ghi2); --AO
NOTICE:  exchanged partition "ghi" of relation "pt_co_tab" with relation "pg_temp_3275836"
NOTICE:  dropped partition "ghi" for relation "pt_co_tab"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_1_prt_ghi1" for table "pt_co_tab"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_1_prt_ghi2" for table "pt_co_tab"
 alter table pt_co_tab split partition xyz at ('xyz1') into ( partition xyz1,partition xyz2); --CO
NOTICE:  exchanged partition "xyz" of relation "pt_co_tab" with relation "pg_temp_3275836"
NOTICE:  dropped partition "xyz" for relation "pt_co_tab"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_1_prt_xyz1" for table "pt_co_tab"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_1_prt_xyz2" for table "pt_co_tab"
--Check the storage type and properties of the split partition
 select oid::regclass, relkind, relstorage, reloptions from pg_class where oid in (select oid from pg_class where relname in ('pt_co_tab_1_prt_xyz1','pt_co_tab_1_prt_xyz2','pt_co_tab_1_prt_ghi1','pt_co_tab_1_prt_ghi2','pt_co_tab_1_prt_abc1','pt_co_tab_1_prt_abc2'));
         oid          | relkind | relstorage |                      reloptions                      
----------------------+---------+------------+------------------------------------------------------
 pt_co_tab_1_prt_abc1 | r       | h          | {appendonly=false}
 pt_co_tab_1_prt_abc2 | r       | h          | {appendonly=false}
 pt_co_tab_1_prt_ghi1 | r       | a          | {appendonly=true}
 pt_co_tab_1_prt_ghi2 | r       | a          | {appendonly=true}
 pt_co_tab_1_prt_xyz1 | r       | c          | {appendonly=true,orientation=column,compresslevel=5}
 pt_co_tab_1_prt_xyz2 | r       | c          | {appendonly=true,orientation=column,compresslevel=5}
(6 rows)

--Exchange partition
 -- Create candidate table
--start_ignore
drop table if exists heap_can cascade;
drop table if exists ao_can cascade;
drop table if exists co_can cascade;
--end_ignore
 create table heap_can(like pt_co_tab);  
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
 create table ao_can(like pt_co_tab) with (appendonly=true);   
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
 create table co_can(like pt_co_tab)  with (appendonly=true,orientation=column);   
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
 -- Exchange
 alter table pt_co_tab add partition pqr values ('pqr','pqr1','pqr2') WITH (appendonly=true,compresslevel=5);-- AO
NOTICE:  CREATE TABLE will create partition "pt_co_tab_1_prt_pqr" for table "pt_co_tab"
 alter table pt_co_tab add partition stu values ('stu','stu1','stu2') WITH (appendonly=false);-- heap
NOTICE:  CREATE TABLE will create partition "pt_co_tab_1_prt_stu" for table "pt_co_tab"
 alter table pt_co_tab exchange partition for ('stu') with table ao_can ; -- Heap exchanged with AO
NOTICE:  exchanged partition "stu" of relation "pt_co_tab" with relation "ao_can"
 alter table pt_co_tab exchange partition for ('pqr') with table co_can; -- AO exchanged with CO
NOTICE:  exchanged partition "pqr" of relation "pt_co_tab" with relation "co_can"
 alter table pt_co_tab exchange partition for ('xyz1') with table heap_can; -- CO exchanged with Heap
NOTICE:  exchanged partition "xyz2" of relation "pt_co_tab" with relation "heap_can"
--Check for the storage properties and indexes of the two tables involved in the exchange
 \d+ heap_can
                                Append-Only Columnar Table "public.heap_can"
 Column  |  Type   | Modifiers | Storage  | Compression Type | Compression Level | Block Size | Description 
---------+---------+-----------+----------+------------------+-------------------+------------+-------------
 a       | integer |           | plain    | zlib             | 5                 | 32768      | 
 b       | text    |           | extended | zlib             | 5                 | 32768      | 
 c       | integer |           | plain    | zlib             | 5                 | 32768      | 
 d       | integer |           | plain    | zlib             | 5                 | 32768      | 
 e       | numeric |           | main     | zlib             | 5                 | 32768      | 
 success | boolean |           | plain    | zlib             | 5                 | 32768      | 
Checksum: t
Indexes:
    "pt_co_tab_1_prt_xyz2_a_key" btree (a) WHERE c > 10
    "pt_co_tab_1_prt_xyz2_key" btree (upper(b))
Check constraints:
    "pt_co_tab_1_prt_xyz2_check" CHECK (b = 'xyz1'::text)
Has OIDs: no
Options: appendonly=true, orientation=column, compresslevel=5
Distributed by: (a)

 \d+ co_can
           Append-Only Table "public.co_can"
 Column  |  Type   | Modifiers | Storage  | Description 
---------+---------+-----------+----------+-------------
 a       | integer |           | plain    | 
 b       | text    |           | extended | 
 c       | integer |           | plain    | 
 d       | integer |           | plain    | 
 e       | numeric |           | main     | 
 success | boolean |           | plain    | 
Compression Type: zlib
Compression Level: 5
Block Size: 32768
Checksum: t
Indexes:
    "pt_co_tab_1_prt_pqr_a_key" btree (a) WHERE c > 10
    "pt_co_tab_1_prt_pqr_key" btree (upper(b))
Check constraints:
    "pt_co_tab_1_prt_pqr_check" CHECK (b = 'pqr'::text OR b = 'pqr1'::text OR b = 'pqr2'::text)
Has OIDs: no
Options: appendonly=true, compresslevel=5
Distributed by: (a)

 \d+ ao_can
                 Table "public.ao_can"
 Column  |  Type   | Modifiers | Storage  | Description 
---------+---------+-----------+----------+-------------
 a       | integer |           | plain    | 
 b       | text    |           | extended | 
 c       | integer |           | plain    | 
 d       | integer |           | plain    | 
 e       | numeric |           | main     | 
 success | boolean |           | plain    | 
Indexes:
    "pt_co_tab_1_prt_stu_a_key" btree (a) WHERE c > 10
    "pt_co_tab_1_prt_stu_key" btree (upper(b))
Check constraints:
    "pt_co_tab_1_prt_stu_check" CHECK (b = 'stu'::text OR b = 'stu1'::text OR b = 'stu2'::text)
Has OIDs: no
Options: appendonly=false
Distributed by: (a)

-- Further operations
 alter table pt_co_tab drop partition jkl;
 truncate table pt_co_tab;
--Further create some more indexes
 create index idx3 on pt_co_tab(c,d) where a = 40 OR a = 50; -- multicol indx
NOTICE:  building index for child partition "pt_co_tab_1_prt_def"
NOTICE:  building index for child partition "pt_co_tab_1_prt_mno"
NOTICE:  building index for child partition "pt_co_tab_1_prt_abc1"
NOTICE:  building index for child partition "pt_co_tab_1_prt_abc2"
NOTICE:  building index for child partition "pt_co_tab_1_prt_ghi1"
NOTICE:  building index for child partition "pt_co_tab_1_prt_ghi2"
NOTICE:  building index for child partition "pt_co_tab_1_prt_xyz1"
NOTICE:  building index for child partition "pt_co_tab_1_prt_stu"
NOTICE:  building index for child partition "pt_co_tab_1_prt_pqr"
NOTICE:  building index for child partition "pt_co_tab_1_prt_xyz2"
 CREATE INDEX idx5 ON pt_co_tab ((b || ' ' || e)); --Expression
NOTICE:  building index for child partition "pt_co_tab_1_prt_def"
NOTICE:  building index for child partition "pt_co_tab_1_prt_mno"
NOTICE:  building index for child partition "pt_co_tab_1_prt_abc1"
NOTICE:  building index for child partition "pt_co_tab_1_prt_abc2"
NOTICE:  building index for child partition "pt_co_tab_1_prt_ghi1"
NOTICE:  building index for child partition "pt_co_tab_1_prt_ghi2"
NOTICE:  building index for child partition "pt_co_tab_1_prt_xyz1"
NOTICE:  building index for child partition "pt_co_tab_1_prt_stu"
NOTICE:  building index for child partition "pt_co_tab_1_prt_pqr"
NOTICE:  building index for child partition "pt_co_tab_1_prt_xyz2"
--Add default partition
 alter table pt_co_tab add default partition dft;
NOTICE:  CREATE TABLE will create partition "pt_co_tab_1_prt_dft" for table "pt_co_tab"
--Split default partition
 alter table pt_co_tab split default partition at ('uvw') into (partition dft, partition uvw);
NOTICE:  exchanged partition "dft" of relation "pt_co_tab" with relation "pg_temp_3275836"
NOTICE:  dropped partition "dft" for relation "pt_co_tab"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_1_prt_uvw" for table "pt_co_tab"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_1_prt_dft" for table "pt_co_tab"
-- create range partitioned Heap table
--start_ignore
 drop table if exists pt_heap_tab_rng cascade;
--end_ignore
 CREATE TABLE pt_heap_tab_rng (a int, b text, c int , d int, e numeric,success bool) with (appendonly=false)
 distributed by (a)
 partition by range(a)
 (
     start(1) end(20) every(5),
     default partition dft
 );
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_rng_1_prt_dft" for table "pt_heap_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_rng_1_prt_2" for table "pt_heap_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_rng_1_prt_3" for table "pt_heap_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_rng_1_prt_4" for table "pt_heap_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_rng_1_prt_5" for table "pt_heap_tab_rng"
-- Create indexes on the table
--start_ignore
drop index if exists heap_rng_idx1 cascade;
NOTICE:  index "heap_rng_idx1" does not exist, skipping
drop index if exists heap_rng_idx2 cascade;
NOTICE:  index "heap_rng_idx2" does not exist, skipping
--end_ignore
 -- partial index
 create index heap_rng_idx1 on pt_heap_tab_rng(a) where c > 10;
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_dft"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_2"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_3"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_4"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_5"
 -- expression index
 create index heap_rng_idx2 on pt_heap_tab_rng(upper(b));
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_dft"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_2"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_3"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_4"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_5"
-- Drop partition
 Alter table pt_heap_tab_rng drop default partition; 
NOTICE:  dropped partition "dft" for relation "pt_heap_tab_rng"
-- ADD partitions
 alter table pt_heap_tab_rng add partition heap start(21) end(25) with (appendonly=false);
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_rng_1_prt_heap" for table "pt_heap_tab_rng"
 alter table pt_heap_tab_rng add partition ao start(25) end(30) with (appendonly=true);
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_rng_1_prt_ao" for table "pt_heap_tab_rng"
 alter table pt_heap_tab_rng add partition co start(31) end(35) with (appendonly=true,orientation=column);
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_rng_1_prt_co" for table "pt_heap_tab_rng"
 select oid::regclass, relkind, relstorage, reloptions from pg_class where oid in ( select oid from pg_class where   relname in  ( 'pt_heap_tab_rng_1_prt_heap', 'pt_heap_tab_rng_1_prt_ao','pt_heap_tab_rng_1_prt_co'));
            oid             | relkind | relstorage |              reloptions              
----------------------------+---------+------------+--------------------------------------
 pt_heap_tab_rng_1_prt_heap | r       | h          | {appendonly=false}
 pt_heap_tab_rng_1_prt_ao   | r       | a          | {appendonly=true}
 pt_heap_tab_rng_1_prt_co   | r       | c          | {appendonly=true,orientation=column}
(3 rows)

-- Split partition
 alter table pt_heap_tab_rng split partition heap at (23) into (partition heap1,partition heap2);
NOTICE:  exchanged partition "heap" of relation "pt_heap_tab_rng" with relation "pg_temp_3278764"
NOTICE:  dropped partition "heap" for relation "pt_heap_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_rng_1_prt_heap1" for table "pt_heap_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_rng_1_prt_heap2" for table "pt_heap_tab_rng"
 alter table pt_heap_tab_rng split partition ao at (27) into (partition ao1,partition ao2);
NOTICE:  exchanged partition "ao" of relation "pt_heap_tab_rng" with relation "pg_temp_3278764"
NOTICE:  dropped partition "ao" for relation "pt_heap_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_rng_1_prt_ao1" for table "pt_heap_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_rng_1_prt_ao2" for table "pt_heap_tab_rng"
 alter table pt_heap_tab_rng split partition co  at (33) into (partition co1,partition co2);
NOTICE:  exchanged partition "co" of relation "pt_heap_tab_rng" with relation "pg_temp_3278764"
NOTICE:  dropped partition "co" for relation "pt_heap_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_rng_1_prt_co1" for table "pt_heap_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_rng_1_prt_co2" for table "pt_heap_tab_rng"
 select oid::regclass, relkind, relstorage, reloptions from pg_class where oid in ( select oid from pg_class where   relname in ( 'pt_heap_tab_rng_1_prt_heap1' ,'pt_heap_tab_rng_1_prt_heap2' ,'pt_heap_tab_rng_1_prt_ao1', 'pt_heap_tab_rng_1_prt_ao2', 'pt_heap_tab_rng_1_prt_co1', 'pt_heap_tab_rng_1_prt_co2'));
             oid             | relkind | relstorage |              reloptions              
-----------------------------+---------+------------+--------------------------------------
 pt_heap_tab_rng_1_prt_heap1 | r       | h          | {appendonly=false}
 pt_heap_tab_rng_1_prt_heap2 | r       | h          | {appendonly=false}
 pt_heap_tab_rng_1_prt_ao1   | r       | a          | {appendonly=true}
 pt_heap_tab_rng_1_prt_ao2   | r       | a          | {appendonly=true}
 pt_heap_tab_rng_1_prt_co1   | r       | c          | {appendonly=true,orientation=column}
 pt_heap_tab_rng_1_prt_co2   | r       | c          | {appendonly=true,orientation=column}
(6 rows)

-- Exchange
 -- Create candidate table
--start_ignore
  drop table if exists heap_can;
  drop table if exists ao_can;
  drop table if exists co_can;
--end_ignore
  create table heap_can(like pt_heap_tab_rng);  
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
  create table ao_can(like pt_heap_tab_rng) with (appendonly=true);   
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
  create table co_can(like pt_heap_tab_rng)  with (appendonly=true,orientation=column);   
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
 alter table pt_heap_tab_rng add partition newco start(36) end(40) with (appendonly= true, orientation = column);
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_rng_1_prt_newco" for table "pt_heap_tab_rng"
 alter table pt_heap_tab_rng add partition newao start(40) end(45) with (appendonly= true);
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_rng_1_prt_newao" for table "pt_heap_tab_rng"
 -- Exchange
 alter table pt_heap_tab_rng exchange partition heap1 with table ao_can; -- HEAP <=> AO
 alter table pt_heap_tab_rng exchange partition newao with table co_can; -- AO <=> CO
 alter table pt_heap_tab_rng exchange partition newco with table heap_can; -- CO <=> HEAP
 \d+ ao_can 
                 Table "public.ao_can"
 Column  |  Type   | Modifiers | Storage  | Description 
---------+---------+-----------+----------+-------------
 a       | integer |           | plain    | 
 b       | text    |           | extended | 
 c       | integer |           | plain    | 
 d       | integer |           | plain    | 
 e       | numeric |           | main     | 
 success | boolean |           | plain    | 
Indexes:
    "pt_heap_tab_rng_1_prt_heap1_a_key" btree (a) WHERE c > 10
    "pt_heap_tab_rng_1_prt_heap1_key" btree (upper(b))
Check constraints:
    "pt_heap_tab_rng_1_prt_heap1_check" CHECK (a >= 21 AND a < 23)
Has OIDs: no
Options: appendonly=false
Distributed by: (a)

 \d+ co_can
           Append-Only Table "public.co_can"
 Column  |  Type   | Modifiers | Storage  | Description 
---------+---------+-----------+----------+-------------
 a       | integer |           | plain    | 
 b       | text    |           | extended | 
 c       | integer |           | plain    | 
 d       | integer |           | plain    | 
 e       | numeric |           | main     | 
 success | boolean |           | plain    | 
Compression Type: None
Compression Level: 0
Block Size: 32768
Checksum: t
Indexes:
    "pt_heap_tab_rng_1_prt_newao_a_key" btree (a) WHERE c > 10
    "pt_heap_tab_rng_1_prt_newao_key" btree (upper(b))
Check constraints:
    "pt_heap_tab_rng_1_prt_newao_check" CHECK (a >= 40 AND a < 45)
Has OIDs: no
Options: appendonly=true
Distributed by: (a)

 \d+ heap_can
                                Append-Only Columnar Table "public.heap_can"
 Column  |  Type   | Modifiers | Storage  | Compression Type | Compression Level | Block Size | Description 
---------+---------+-----------+----------+------------------+-------------------+------------+-------------
 a       | integer |           | plain    | none             | 0                 | 32768      | 
 b       | text    |           | extended | none             | 0                 | 32768      | 
 c       | integer |           | plain    | none             | 0                 | 32768      | 
 d       | integer |           | plain    | none             | 0                 | 32768      | 
 e       | numeric |           | main     | none             | 0                 | 32768      | 
 success | boolean |           | plain    | none             | 0                 | 32768      | 
Checksum: t
Indexes:
    "pt_heap_tab_rng_1_prt_newco_a_key" btree (a) WHERE c > 10
    "pt_heap_tab_rng_1_prt_newco_key" btree (upper(b))
Check constraints:
    "pt_heap_tab_rng_1_prt_newco_check" CHECK (a >= 36 AND a < 40)
Has OIDs: no
Options: appendonly=true, orientation=column
Distributed by: (a)

-- Create more index indexes
--start_ignore
drop index if exists heap_rng_idx4 cascade;
NOTICE:  index "heap_rng_idx4" does not exist, skipping
drop index if exists heap_rng_idx3 cascade;
NOTICE:  index "heap_rng_idx3" does not exist, skipping
--end_ignore
 create index heap_rng_idx3 on pt_heap_tab_rng(c,d) where a = 40 OR a = 50; -- multicol indx
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_2"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_3"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_4"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_5"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_heap2"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_ao1"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_ao2"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_co1"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_co2"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_heap1"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_newao"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_newco"
 CREATE INDEX heap_rng_idx4 ON pt_heap_tab_rng ((b || ' ' || e)); --Expression
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_2"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_3"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_4"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_5"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_heap2"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_ao1"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_ao2"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_co1"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_co2"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_heap1"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_newao"
NOTICE:  building index for child partition "pt_heap_tab_rng_1_prt_newco"
-- Add default partition
 alter table pt_heap_tab_rng add default partition dft;
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_rng_1_prt_dft" for table "pt_heap_tab_rng"
--Split default partition
 alter table pt_heap_tab_rng split default partition start(45) end(60) into (partition dft, partition two);
NOTICE:  exchanged partition "dft" of relation "pt_heap_tab_rng" with relation "pg_temp_3278764"
NOTICE:  dropped partition "dft" for relation "pt_heap_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_rng_1_prt_two" for table "pt_heap_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_heap_tab_rng_1_prt_dft" for table "pt_heap_tab_rng"
-- create range partitioned AO table
--start_ignore
 drop table if exists pt_ao_tab_rng cascade;
--end_ignore
 CREATE TABLE pt_ao_tab_rng (a int, b text, c int , d int, e numeric,success bool) with (appendonly=true,compresstype=zlib, compresslevel=1)
 distributed by (a)
 partition by range(a)
 (
     start(1) end(20) every(5),
     default partition dft
 );
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_rng_1_prt_dft" for table "pt_ao_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_rng_1_prt_2" for table "pt_ao_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_rng_1_prt_3" for table "pt_ao_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_rng_1_prt_4" for table "pt_ao_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_rng_1_prt_5" for table "pt_ao_tab_rng"
--Create indexes on the table
--start_ignore
drop index if exists ao_rng_idx1 cascade;
NOTICE:  index "ao_rng_idx1" does not exist, skipping
drop index if exists ao_rng_idx2 cascade;
NOTICE:  index "ao_rng_idx2" does not exist, skipping
--end_ignore
 -- partial index
 create index ao_rng_idx1 on pt_ao_tab_rng(a) where c > 10;
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_dft"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_2"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_3"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_4"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_5"
 -- expression index
 create index ao_rng_idx2 on pt_ao_tab_rng(upper(b));
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_dft"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_2"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_3"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_4"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_5"
--Drop partition
 Alter table pt_ao_tab_rng drop default partition; 
NOTICE:  dropped partition "dft" for relation "pt_ao_tab_rng"
--ADD partitions
 alter table pt_ao_tab_rng add partition heap start(21) end(25) with (appendonly=false);
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_rng_1_prt_heap" for table "pt_ao_tab_rng"
 alter table pt_ao_tab_rng add partition ao start(25) end(30) with (appendonly=true);
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_rng_1_prt_ao" for table "pt_ao_tab_rng"
 alter table pt_ao_tab_rng add partition co start(31) end(35) with (appendonly=true,orientation=column);
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_rng_1_prt_co" for table "pt_ao_tab_rng"
 select oid::regclass, relkind, relstorage, reloptions from pg_class where oid in ( select oid from pg_class where   relname in  ( 'pt_ao_tab_rng_1_prt_heap', 'pt_ao_tab_rng_1_prt_ao','pt_ao_tab_rng_1_prt_co'));
           oid            | relkind | relstorage |              reloptions              
--------------------------+---------+------------+--------------------------------------
 pt_ao_tab_rng_1_prt_heap | r       | h          | {appendonly=false}
 pt_ao_tab_rng_1_prt_ao   | r       | a          | {appendonly=true}
 pt_ao_tab_rng_1_prt_co   | r       | c          | {appendonly=true,orientation=column}
(3 rows)

--Split partition
 alter table pt_ao_tab_rng split partition heap at (23) into (partition heap1,partition heap2);
NOTICE:  exchanged partition "heap" of relation "pt_ao_tab_rng" with relation "pg_temp_3281719"
NOTICE:  dropped partition "heap" for relation "pt_ao_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_rng_1_prt_heap1" for table "pt_ao_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_rng_1_prt_heap2" for table "pt_ao_tab_rng"
 alter table pt_ao_tab_rng split partition ao at (27) into (partition ao1,partition ao2);
NOTICE:  exchanged partition "ao" of relation "pt_ao_tab_rng" with relation "pg_temp_3281719"
NOTICE:  dropped partition "ao" for relation "pt_ao_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_rng_1_prt_ao1" for table "pt_ao_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_rng_1_prt_ao2" for table "pt_ao_tab_rng"
 alter table pt_ao_tab_rng split partition co  at (33) into (partition co1,partition co2);
NOTICE:  exchanged partition "co" of relation "pt_ao_tab_rng" with relation "pg_temp_3281719"
NOTICE:  dropped partition "co" for relation "pt_ao_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_rng_1_prt_co1" for table "pt_ao_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_rng_1_prt_co2" for table "pt_ao_tab_rng"
 select oid::regclass, relkind, relstorage, reloptions from pg_class where oid in ( select oid from pg_class where   relname in ( 'pt_ao_tab_rng_1_prt_heap1' ,'pt_ao_tab_rng_1_prt_heap2' ,'pt_ao_tab_rng_1_prt_ao1', 'pt_ao_tab_rng_1_prt_ao2', 'pt_ao_tab_rng_1_prt_co1', 'pt_ao_tab_rng_1_prt_co2'));
            oid            | relkind | relstorage |              reloptions              
---------------------------+---------+------------+--------------------------------------
 pt_ao_tab_rng_1_prt_heap1 | r       | h          | {appendonly=false}
 pt_ao_tab_rng_1_prt_heap2 | r       | h          | {appendonly=false}
 pt_ao_tab_rng_1_prt_ao1   | r       | a          | {appendonly=true}
 pt_ao_tab_rng_1_prt_ao2   | r       | a          | {appendonly=true}
 pt_ao_tab_rng_1_prt_co1   | r       | c          | {appendonly=true,orientation=column}
 pt_ao_tab_rng_1_prt_co2   | r       | c          | {appendonly=true,orientation=column}
(6 rows)

--Exchange
 -- Create candidate table
--start_ignore
drop table if exists heap_can cascade;
drop table if exists ao_can cascade;
drop table if exists co_can cascade;
--end_ignore
  create table heap_can(like pt_ao_tab_rng);  
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
  create table ao_can(like pt_ao_tab_rng) with (appendonly=true);   
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
  create table co_can(like pt_ao_tab_rng)  with (appendonly=true,orientation=column);   
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
 alter table pt_ao_tab_rng add partition newco start(36) end(40) with (appendonly= true, orientation = column);
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_rng_1_prt_newco" for table "pt_ao_tab_rng"
 alter table pt_ao_tab_rng add partition newheap start(40) end(45) with (appendonly= false);
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_rng_1_prt_newheap" for table "pt_ao_tab_rng"
 -- Exchange
 alter table pt_ao_tab_rng exchange partition newheap with table ao_can; -- HEAP <=> AO
 alter table pt_ao_tab_rng exchange partition ao1 with table co_can;-- AO <=> CO
 alter table pt_ao_tab_rng exchange partition newco with table heap_can; --CO <=> HEAP
 \d+ ao_can 
                 Table "public.ao_can"
 Column  |  Type   | Modifiers | Storage  | Description 
---------+---------+-----------+----------+-------------
 a       | integer |           | plain    | 
 b       | text    |           | extended | 
 c       | integer |           | plain    | 
 d       | integer |           | plain    | 
 e       | numeric |           | main     | 
 success | boolean |           | plain    | 
Indexes:
    "pt_ao_tab_rng_1_prt_newheap_a_key" btree (a) WHERE c > 10
    "pt_ao_tab_rng_1_prt_newheap_key" btree (upper(b))
Check constraints:
    "pt_ao_tab_rng_1_prt_newheap_check" CHECK (a >= 40 AND a < 45)
Has OIDs: no
Options: appendonly=false
Distributed by: (a)

 \d+ co_can
           Append-Only Table "public.co_can"
 Column  |  Type   | Modifiers | Storage  | Description 
---------+---------+-----------+----------+-------------
 a       | integer |           | plain    | 
 b       | text    |           | extended | 
 c       | integer |           | plain    | 
 d       | integer |           | plain    | 
 e       | numeric |           | main     | 
 success | boolean |           | plain    | 
Compression Type: None
Compression Level: 0
Block Size: 32768
Checksum: t
Indexes:
    "pt_ao_tab_rng_1_prt_ao1_a_key" btree (a) WHERE c > 10
    "pt_ao_tab_rng_1_prt_ao1_key" btree (upper(b))
Check constraints:
    "pt_ao_tab_rng_1_prt_ao1_check" CHECK (a >= 25 AND a < 27)
Has OIDs: no
Options: appendonly=true
Distributed by: (a)

 \d+ heap_can
                                Append-Only Columnar Table "public.heap_can"
 Column  |  Type   | Modifiers | Storage  | Compression Type | Compression Level | Block Size | Description 
---------+---------+-----------+----------+------------------+-------------------+------------+-------------
 a       | integer |           | plain    | none             | 0                 | 32768      | 
 b       | text    |           | extended | none             | 0                 | 32768      | 
 c       | integer |           | plain    | none             | 0                 | 32768      | 
 d       | integer |           | plain    | none             | 0                 | 32768      | 
 e       | numeric |           | main     | none             | 0                 | 32768      | 
 success | boolean |           | plain    | none             | 0                 | 32768      | 
Checksum: t
Indexes:
    "pt_ao_tab_rng_1_prt_newco_a_key" btree (a) WHERE c > 10
    "pt_ao_tab_rng_1_prt_newco_key" btree (upper(b))
Check constraints:
    "pt_ao_tab_rng_1_prt_newco_check" CHECK (a >= 36 AND a < 40)
Has OIDs: no
Options: appendonly=true, orientation=column
Distributed by: (a)

-- Create more index indexes
--start_ignore
drop index if exists ao_rng_idx4 cascade;
NOTICE:  index "ao_rng_idx4" does not exist, skipping
drop index if exists ao_rng_idx3 cascade;
NOTICE:  index "ao_rng_idx3" does not exist, skipping
--end_ignore
 create index ao_rng_idx3 on pt_ao_tab_rng(c,d) where a = 40 OR a = 50; -- multicol indx
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_2"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_3"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_4"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_5"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_heap1"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_heap2"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_ao2"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_co1"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_co2"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_newheap"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_ao1"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_newco"
 CREATE INDEX ao_rng_idx4 ON pt_ao_tab_rng ((b || ' ' || e)); --Expression
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_2"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_3"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_4"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_5"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_heap1"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_heap2"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_ao2"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_co1"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_co2"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_newheap"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_ao1"
NOTICE:  building index for child partition "pt_ao_tab_rng_1_prt_newco"
--Add default partition
 alter table pt_ao_tab_rng add default partition dft;
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_rng_1_prt_dft" for table "pt_ao_tab_rng"
--Split default partition
 alter table pt_ao_tab_rng split default partition start(45) end(60) into (partition dft, partition two);
NOTICE:  exchanged partition "dft" of relation "pt_ao_tab_rng" with relation "pg_temp_3281719"
NOTICE:  dropped partition "dft" for relation "pt_ao_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_rng_1_prt_two" for table "pt_ao_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_ao_tab_rng_1_prt_dft" for table "pt_ao_tab_rng"
--create range partitioned CO table
--start_ignore
 drop table if exists pt_co_tab_rng cascade;
--end_ignore
 CREATE TABLE pt_co_tab_rng (a int, b text, c int , d int, e numeric,success bool) with (appendonly=true, orientation=column, compresstype=zlib, compresslevel=1)
 distributed by (a)
 partition by range(a)
 (
     start(1) end(20) every(5),
     default partition dft
 );
NOTICE:  CREATE TABLE will create partition "pt_co_tab_rng_1_prt_dft" for table "pt_co_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_rng_1_prt_2" for table "pt_co_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_rng_1_prt_3" for table "pt_co_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_rng_1_prt_4" for table "pt_co_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_rng_1_prt_5" for table "pt_co_tab_rng"
--Create indexes on the table
--start_ignore
drop index if exists co_rng_idx1 cascade;
NOTICE:  index "co_rng_idx1" does not exist, skipping
drop index if exists co_rng_idx2 cascade;
NOTICE:  index "co_rng_idx2" does not exist, skipping
--end_ignore
 -- partial index
 create index co_rng_idx1 on pt_co_tab_rng(a) where c > 10;
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_dft"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_2"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_3"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_4"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_5"
 -- expression index
 create index co_rng_idx2 on pt_co_tab_rng(upper(b));
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_dft"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_2"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_3"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_4"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_5"
--Drop partition
 Alter table pt_co_tab_rng drop default partition; 
NOTICE:  dropped partition "dft" for relation "pt_co_tab_rng"
--ADD partitions
 alter table pt_co_tab_rng add partition heap start(21) end(25) with (appendonly=false);
NOTICE:  CREATE TABLE will create partition "pt_co_tab_rng_1_prt_heap" for table "pt_co_tab_rng"
 alter table pt_co_tab_rng add partition ao start(25) end(30) with (appendonly=true);
NOTICE:  CREATE TABLE will create partition "pt_co_tab_rng_1_prt_ao" for table "pt_co_tab_rng"
 alter table pt_co_tab_rng add partition co start(31) end(35) with (appendonly=true,orientation=column);
NOTICE:  CREATE TABLE will create partition "pt_co_tab_rng_1_prt_co" for table "pt_co_tab_rng"
 select oid::regclass, relkind, relstorage, reloptions from pg_class where oid in ( select oid from pg_class where   relname in  ( 'pt_co_tab_rng_1_prt_heap', 'pt_co_tab_rng_1_prt_ao','pt_co_tab_rng_1_prt_co'));
           oid            | relkind | relstorage |              reloptions              
--------------------------+---------+------------+--------------------------------------
 pt_co_tab_rng_1_prt_heap | r       | h          | {appendonly=false}
 pt_co_tab_rng_1_prt_ao   | r       | a          | {appendonly=true}
 pt_co_tab_rng_1_prt_co   | r       | c          | {appendonly=true,orientation=column}
(3 rows)

--Split partition
 alter table pt_co_tab_rng split partition heap at (23) into (partition heap1,partition heap2);
NOTICE:  exchanged partition "heap" of relation "pt_co_tab_rng" with relation "pg_temp_3284704"
NOTICE:  dropped partition "heap" for relation "pt_co_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_rng_1_prt_heap1" for table "pt_co_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_rng_1_prt_heap2" for table "pt_co_tab_rng"
 alter table pt_co_tab_rng split partition ao at (27) into (partition ao1,partition ao2);
NOTICE:  exchanged partition "ao" of relation "pt_co_tab_rng" with relation "pg_temp_3284704"
NOTICE:  dropped partition "ao" for relation "pt_co_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_rng_1_prt_ao1" for table "pt_co_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_rng_1_prt_ao2" for table "pt_co_tab_rng"
 alter table pt_co_tab_rng split partition co  at (33) into (partition co1,partition co2);
NOTICE:  exchanged partition "co" of relation "pt_co_tab_rng" with relation "pg_temp_3284704"
NOTICE:  dropped partition "co" for relation "pt_co_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_rng_1_prt_co1" for table "pt_co_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_rng_1_prt_co2" for table "pt_co_tab_rng"
 select oid::regclass, relkind, relstorage, reloptions from pg_class where oid in ( select oid from pg_class where   relname in ( 'pt_co_tab_rng_1_prt_heap1' ,'pt_co_tab_rng_1_prt_heap2' ,'pt_co_tab_rng_1_prt_ao1', 'pt_co_tab_rng_1_prt_ao2', 'pt_co_tab_rng_1_prt_co1', 'pt_co_tab_rng_1_prt_co2'));
            oid            | relkind | relstorage |              reloptions              
---------------------------+---------+------------+--------------------------------------
 pt_co_tab_rng_1_prt_heap1 | r       | h          | {appendonly=false}
 pt_co_tab_rng_1_prt_heap2 | r       | h          | {appendonly=false}
 pt_co_tab_rng_1_prt_ao1   | r       | a          | {appendonly=true}
 pt_co_tab_rng_1_prt_ao2   | r       | a          | {appendonly=true}
 pt_co_tab_rng_1_prt_co1   | r       | c          | {appendonly=true,orientation=column}
 pt_co_tab_rng_1_prt_co2   | r       | c          | {appendonly=true,orientation=column}
(6 rows)

--Exchange
 -- Create candidate table
--start_ignore
drop table if exists heap_can cascade;
drop table if exists ao_can cascade;
drop table if exists co_can cascade;
--end_ignore
  create table heap_can(like pt_co_tab_rng);  
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
  create table ao_can(like pt_co_tab_rng) with (appendonly=true);   
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
  create table co_can(like pt_co_tab_rng)  with (appendonly=true,orientation=column);   
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
 alter table pt_co_tab_rng add partition newao start(36) end(40) with (appendonly= true);
NOTICE:  CREATE TABLE will create partition "pt_co_tab_rng_1_prt_newao" for table "pt_co_tab_rng"
 alter table pt_co_tab_rng add partition newheap start(40) end(45) with (appendonly= false);
NOTICE:  CREATE TABLE will create partition "pt_co_tab_rng_1_prt_newheap" for table "pt_co_tab_rng"
 -- Exchange
 alter table pt_co_tab_rng exchange partition newheap with table ao_can;-- HEAP <=> AO
 alter table pt_co_tab_rng exchange partition newao with table co_can; -- AO <=> CO
 alter table pt_co_tab_rng exchange partition co1 with table heap_can; -- CO <=> HEAP
 \d+ ao_can 
                 Table "public.ao_can"
 Column  |  Type   | Modifiers | Storage  | Description 
---------+---------+-----------+----------+-------------
 a       | integer |           | plain    | 
 b       | text    |           | extended | 
 c       | integer |           | plain    | 
 d       | integer |           | plain    | 
 e       | numeric |           | main     | 
 success | boolean |           | plain    | 
Indexes:
    "pt_co_tab_rng_1_prt_newheap_a_key" btree (a) WHERE c > 10
    "pt_co_tab_rng_1_prt_newheap_key" btree (upper(b))
Check constraints:
    "pt_co_tab_rng_1_prt_newheap_check" CHECK (a >= 40 AND a < 45)
Has OIDs: no
Options: appendonly=false
Distributed by: (a)

 \d+ co_can
           Append-Only Table "public.co_can"
 Column  |  Type   | Modifiers | Storage  | Description 
---------+---------+-----------+----------+-------------
 a       | integer |           | plain    | 
 b       | text    |           | extended | 
 c       | integer |           | plain    | 
 d       | integer |           | plain    | 
 e       | numeric |           | main     | 
 success | boolean |           | plain    | 
Compression Type: None
Compression Level: 0
Block Size: 32768
Checksum: t
Indexes:
    "pt_co_tab_rng_1_prt_newao_a_key" btree (a) WHERE c > 10
    "pt_co_tab_rng_1_prt_newao_key" btree (upper(b))
Check constraints:
    "pt_co_tab_rng_1_prt_newao_check" CHECK (a >= 36 AND a < 40)
Has OIDs: no
Options: appendonly=true
Distributed by: (a)

 \d+ heap_can
                                Append-Only Columnar Table "public.heap_can"
 Column  |  Type   | Modifiers | Storage  | Compression Type | Compression Level | Block Size | Description 
---------+---------+-----------+----------+------------------+-------------------+------------+-------------
 a       | integer |           | plain    | none             | 0                 | 32768      | 
 b       | text    |           | extended | none             | 0                 | 32768      | 
 c       | integer |           | plain    | none             | 0                 | 32768      | 
 d       | integer |           | plain    | none             | 0                 | 32768      | 
 e       | numeric |           | main     | none             | 0                 | 32768      | 
 success | boolean |           | plain    | none             | 0                 | 32768      | 
Checksum: t
Indexes:
    "pt_co_tab_rng_1_prt_co1_a_key" btree (a) WHERE c > 10
    "pt_co_tab_rng_1_prt_co1_key" btree (upper(b))
Check constraints:
    "pt_co_tab_rng_1_prt_co1_check" CHECK (a >= 31 AND a < 33)
Has OIDs: no
Options: appendonly=true, orientation=column
Distributed by: (a)

-- Create more index indexes
--start_ignore
drop index if exists co_rng_idx4 cascade;
NOTICE:  index "co_rng_idx4" does not exist, skipping
drop index if exists co_rng_idx3 cascade;
NOTICE:  index "co_rng_idx3" does not exist, skipping
--end_ignore
 create index co_rng_idx3 on pt_co_tab_rng(c,d) where a = 40 OR a = 50; -- multicol indx
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_2"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_3"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_4"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_5"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_heap1"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_heap2"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_ao1"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_ao2"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_co2"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_newheap"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_newao"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_co1"
 CREATE INDEX co_rng_idx4 ON pt_co_tab_rng ((b || ' ' || e)); --Expression
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_2"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_3"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_4"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_5"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_heap1"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_heap2"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_ao1"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_ao2"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_co2"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_newheap"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_newao"
NOTICE:  building index for child partition "pt_co_tab_rng_1_prt_co1"
-- Add default partition
 alter table pt_co_tab_rng add default partition dft;
NOTICE:  CREATE TABLE will create partition "pt_co_tab_rng_1_prt_dft" for table "pt_co_tab_rng"
-- Split default partition
 alter table pt_co_tab_rng split default partition start(45) end(60) into (partition dft, partition two);
NOTICE:  exchanged partition "dft" of relation "pt_co_tab_rng" with relation "pg_temp_3284704"
NOTICE:  dropped partition "dft" for relation "pt_co_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_rng_1_prt_two" for table "pt_co_tab_rng"
NOTICE:  CREATE TABLE will create partition "pt_co_tab_rng_1_prt_dft" for table "pt_co_tab_rng"
