--
-- JOIN
-- Test JOIN clauses
--
CREATE TABLE J1_TBL (
  i integer,
  j integer,
  t text
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE J2_TBL (
  i integer,
  k integer
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO J1_TBL VALUES (1, 4, 'one');
INSERT INTO J1_TBL VALUES (2, 3, 'two');
INSERT INTO J1_TBL VALUES (3, 2, 'three');
INSERT INTO J1_TBL VALUES (4, 1, 'four');
INSERT INTO J1_TBL VALUES (5, 0, 'five');
INSERT INTO J1_TBL VALUES (6, 6, 'six');
INSERT INTO J1_TBL VALUES (7, 7, 'seven');
INSERT INTO J1_TBL VALUES (8, 8, 'eight');
INSERT INTO J1_TBL VALUES (0, NULL, 'zero');
INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');
INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');
INSERT INTO J2_TBL VALUES (1, -1);
INSERT INTO J2_TBL VALUES (2, 2);
INSERT INTO J2_TBL VALUES (3, -3);
INSERT INTO J2_TBL VALUES (2, 4);
INSERT INTO J2_TBL VALUES (5, -5);
INSERT INTO J2_TBL VALUES (5, -5);
INSERT INTO J2_TBL VALUES (0, NULL);
INSERT INTO J2_TBL VALUES (NULL, NULL);
INSERT INTO J2_TBL VALUES (NULL, 0);
-- useful in some tests below
create temp table onerow();
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, and no column type is suitable for a distribution key. Creating a NULL policy entry.
insert into onerow default values;
analyze onerow;
--
-- CORRELATION NAMES
-- Make sure that table/column aliases are supported
-- before diving into more complex join syntax.
--
SELECT *
  FROM J1_TBL AS tx;
 i | j |   t   
---+---+-------
 1 | 4 | one
 2 | 3 | two
 3 | 2 | three
 4 | 1 | four
 5 | 0 | five
 6 | 6 | six
 7 | 7 | seven
 8 | 8 | eight
 0 |   | zero
   |   | null
   | 0 | zero
(11 rows)

SELECT *
  FROM J1_TBL tx;
 i | j |   t   
---+---+-------
 1 | 4 | one
 2 | 3 | two
 3 | 2 | three
 4 | 1 | four
 5 | 0 | five
 6 | 6 | six
 7 | 7 | seven
 8 | 8 | eight
 0 |   | zero
   |   | null
   | 0 | zero
(11 rows)

SELECT *
  FROM J1_TBL AS t1 (a, b, c);
 a | b |   c   
---+---+-------
 1 | 4 | one
 2 | 3 | two
 3 | 2 | three
 4 | 1 | four
 5 | 0 | five
 6 | 6 | six
 7 | 7 | seven
 8 | 8 | eight
 0 |   | zero
   |   | null
   | 0 | zero
(11 rows)

SELECT *
  FROM J1_TBL t1 (a, b, c);
 a | b |   c   
---+---+-------
 1 | 4 | one
 2 | 3 | two
 3 | 2 | three
 4 | 1 | four
 5 | 0 | five
 6 | 6 | six
 7 | 7 | seven
 8 | 8 | eight
 0 |   | zero
   |   | null
   | 0 | zero
(11 rows)

SELECT *
  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);
 a | b |   c   | d | e  
---+---+-------+---+----
 1 | 4 | one   | 1 | -1
 2 | 3 | two   | 1 | -1
 3 | 2 | three | 1 | -1
 4 | 1 | four  | 1 | -1
 5 | 0 | five  | 1 | -1
 6 | 6 | six   | 1 | -1
 7 | 7 | seven | 1 | -1
 8 | 8 | eight | 1 | -1
 0 |   | zero  | 1 | -1
   |   | null  | 1 | -1
   | 0 | zero  | 1 | -1
 1 | 4 | one   | 2 |  2
 2 | 3 | two   | 2 |  2
 3 | 2 | three | 2 |  2
 4 | 1 | four  | 2 |  2
 5 | 0 | five  | 2 |  2
 6 | 6 | six   | 2 |  2
 7 | 7 | seven | 2 |  2
 8 | 8 | eight | 2 |  2
 0 |   | zero  | 2 |  2
   |   | null  | 2 |  2
   | 0 | zero  | 2 |  2
 1 | 4 | one   | 3 | -3
 2 | 3 | two   | 3 | -3
 3 | 2 | three | 3 | -3
 4 | 1 | four  | 3 | -3
 5 | 0 | five  | 3 | -3
 6 | 6 | six   | 3 | -3
 7 | 7 | seven | 3 | -3
 8 | 8 | eight | 3 | -3
 0 |   | zero  | 3 | -3
   |   | null  | 3 | -3
   | 0 | zero  | 3 | -3
 1 | 4 | one   | 2 |  4
 2 | 3 | two   | 2 |  4
 3 | 2 | three | 2 |  4
 4 | 1 | four  | 2 |  4
 5 | 0 | five  | 2 |  4
 6 | 6 | six   | 2 |  4
 7 | 7 | seven | 2 |  4
 8 | 8 | eight | 2 |  4
 0 |   | zero  | 2 |  4
   |   | null  | 2 |  4
   | 0 | zero  | 2 |  4
 1 | 4 | one   | 5 | -5
 2 | 3 | two   | 5 | -5
 3 | 2 | three | 5 | -5
 4 | 1 | four  | 5 | -5
 5 | 0 | five  | 5 | -5
 6 | 6 | six   | 5 | -5
 7 | 7 | seven | 5 | -5
 8 | 8 | eight | 5 | -5
 0 |   | zero  | 5 | -5
   |   | null  | 5 | -5
   | 0 | zero  | 5 | -5
 1 | 4 | one   | 5 | -5
 2 | 3 | two   | 5 | -5
 3 | 2 | three | 5 | -5
 4 | 1 | four  | 5 | -5
 5 | 0 | five  | 5 | -5
 6 | 6 | six   | 5 | -5
 7 | 7 | seven | 5 | -5
 8 | 8 | eight | 5 | -5
 0 |   | zero  | 5 | -5
   |   | null  | 5 | -5
   | 0 | zero  | 5 | -5
 1 | 4 | one   | 0 |   
 2 | 3 | two   | 0 |   
 3 | 2 | three | 0 |   
 4 | 1 | four  | 0 |   
 5 | 0 | five  | 0 |   
 6 | 6 | six   | 0 |   
 7 | 7 | seven | 0 |   
 8 | 8 | eight | 0 |   
 0 |   | zero  | 0 |   
   |   | null  | 0 |   
   | 0 | zero  | 0 |   
 1 | 4 | one   |   |   
 2 | 3 | two   |   |   
 3 | 2 | three |   |   
 4 | 1 | four  |   |   
 5 | 0 | five  |   |   
 6 | 6 | six   |   |   
 7 | 7 | seven |   |   
 8 | 8 | eight |   |   
 0 |   | zero  |   |   
   |   | null  |   |   
   | 0 | zero  |   |   
 1 | 4 | one   |   |  0
 2 | 3 | two   |   |  0
 3 | 2 | three |   |  0
 4 | 1 | four  |   |  0
 5 | 0 | five  |   |  0
 6 | 6 | six   |   |  0
 7 | 7 | seven |   |  0
 8 | 8 | eight |   |  0
 0 |   | zero  |   |  0
   |   | null  |   |  0
   | 0 | zero  |   |  0
(99 rows)

SELECT t1.a, t2.e
  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)
  WHERE t1.a = t2.d;
 a | e  
---+----
 0 |   
 1 | -1
 2 |  2
 2 |  4
 3 | -3
 5 | -5
 5 | -5
(7 rows)

--
-- CROSS JOIN
-- Qualifications are not allowed on cross joins,
-- which degenerate into a standard unqualified inner join.
--
SELECT *
  FROM J1_TBL CROSS JOIN J2_TBL;
 i | j |   t   | i | k  
---+---+-------+---+----
 1 | 4 | one   | 1 | -1
 2 | 3 | two   | 1 | -1
 3 | 2 | three | 1 | -1
 4 | 1 | four  | 1 | -1
 5 | 0 | five  | 1 | -1
 6 | 6 | six   | 1 | -1
 7 | 7 | seven | 1 | -1
 8 | 8 | eight | 1 | -1
 0 |   | zero  | 1 | -1
   |   | null  | 1 | -1
   | 0 | zero  | 1 | -1
 1 | 4 | one   | 2 |  2
 2 | 3 | two   | 2 |  2
 3 | 2 | three | 2 |  2
 4 | 1 | four  | 2 |  2
 5 | 0 | five  | 2 |  2
 6 | 6 | six   | 2 |  2
 7 | 7 | seven | 2 |  2
 8 | 8 | eight | 2 |  2
 0 |   | zero  | 2 |  2
   |   | null  | 2 |  2
   | 0 | zero  | 2 |  2
 1 | 4 | one   | 3 | -3
 2 | 3 | two   | 3 | -3
 3 | 2 | three | 3 | -3
 4 | 1 | four  | 3 | -3
 5 | 0 | five  | 3 | -3
 6 | 6 | six   | 3 | -3
 7 | 7 | seven | 3 | -3
 8 | 8 | eight | 3 | -3
 0 |   | zero  | 3 | -3
   |   | null  | 3 | -3
   | 0 | zero  | 3 | -3
 1 | 4 | one   | 2 |  4
 2 | 3 | two   | 2 |  4
 3 | 2 | three | 2 |  4
 4 | 1 | four  | 2 |  4
 5 | 0 | five  | 2 |  4
 6 | 6 | six   | 2 |  4
 7 | 7 | seven | 2 |  4
 8 | 8 | eight | 2 |  4
 0 |   | zero  | 2 |  4
   |   | null  | 2 |  4
   | 0 | zero  | 2 |  4
 1 | 4 | one   | 5 | -5
 2 | 3 | two   | 5 | -5
 3 | 2 | three | 5 | -5
 4 | 1 | four  | 5 | -5
 5 | 0 | five  | 5 | -5
 6 | 6 | six   | 5 | -5
 7 | 7 | seven | 5 | -5
 8 | 8 | eight | 5 | -5
 0 |   | zero  | 5 | -5
   |   | null  | 5 | -5
   | 0 | zero  | 5 | -5
 1 | 4 | one   | 5 | -5
 2 | 3 | two   | 5 | -5
 3 | 2 | three | 5 | -5
 4 | 1 | four  | 5 | -5
 5 | 0 | five  | 5 | -5
 6 | 6 | six   | 5 | -5
 7 | 7 | seven | 5 | -5
 8 | 8 | eight | 5 | -5
 0 |   | zero  | 5 | -5
   |   | null  | 5 | -5
   | 0 | zero  | 5 | -5
 1 | 4 | one   | 0 |   
 2 | 3 | two   | 0 |   
 3 | 2 | three | 0 |   
 4 | 1 | four  | 0 |   
 5 | 0 | five  | 0 |   
 6 | 6 | six   | 0 |   
 7 | 7 | seven | 0 |   
 8 | 8 | eight | 0 |   
 0 |   | zero  | 0 |   
   |   | null  | 0 |   
   | 0 | zero  | 0 |   
 1 | 4 | one   |   |   
 2 | 3 | two   |   |   
 3 | 2 | three |   |   
 4 | 1 | four  |   |   
 5 | 0 | five  |   |   
 6 | 6 | six   |   |   
 7 | 7 | seven |   |   
 8 | 8 | eight |   |   
 0 |   | zero  |   |   
   |   | null  |   |   
   | 0 | zero  |   |   
 1 | 4 | one   |   |  0
 2 | 3 | two   |   |  0
 3 | 2 | three |   |  0
 4 | 1 | four  |   |  0
 5 | 0 | five  |   |  0
 6 | 6 | six   |   |  0
 7 | 7 | seven |   |  0
 8 | 8 | eight |   |  0
 0 |   | zero  |   |  0
   |   | null  |   |  0
   | 0 | zero  |   |  0
(99 rows)

-- ambiguous column
SELECT i, k, t
  FROM J1_TBL CROSS JOIN J2_TBL;
ERROR:  column reference "i" is ambiguous
LINE 1: SELECT i, k, t
               ^
-- resolve previous ambiguity by specifying the table name
SELECT t1.i, k, t
  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;
 i | k  |   t   
---+----+-------
 1 | -1 | one
 2 | -1 | two
 3 | -1 | three
 4 | -1 | four
 5 | -1 | five
 6 | -1 | six
 7 | -1 | seven
 8 | -1 | eight
 0 | -1 | zero
   | -1 | null
   | -1 | zero
 1 |  2 | one
 2 |  2 | two
 3 |  2 | three
 4 |  2 | four
 5 |  2 | five
 6 |  2 | six
 7 |  2 | seven
 8 |  2 | eight
 0 |  2 | zero
   |  2 | null
   |  2 | zero
 1 | -3 | one
 2 | -3 | two
 3 | -3 | three
 4 | -3 | four
 5 | -3 | five
 6 | -3 | six
 7 | -3 | seven
 8 | -3 | eight
 0 | -3 | zero
   | -3 | null
   | -3 | zero
 1 |  4 | one
 2 |  4 | two
 3 |  4 | three
 4 |  4 | four
 5 |  4 | five
 6 |  4 | six
 7 |  4 | seven
 8 |  4 | eight
 0 |  4 | zero
   |  4 | null
   |  4 | zero
 1 | -5 | one
 2 | -5 | two
 3 | -5 | three
 4 | -5 | four
 5 | -5 | five
 6 | -5 | six
 7 | -5 | seven
 8 | -5 | eight
 0 | -5 | zero
   | -5 | null
   | -5 | zero
 1 | -5 | one
 2 | -5 | two
 3 | -5 | three
 4 | -5 | four
 5 | -5 | five
 6 | -5 | six
 7 | -5 | seven
 8 | -5 | eight
 0 | -5 | zero
   | -5 | null
   | -5 | zero
 1 |    | one
 2 |    | two
 3 |    | three
 4 |    | four
 5 |    | five
 6 |    | six
 7 |    | seven
 8 |    | eight
 0 |    | zero
   |    | null
   |    | zero
 1 |    | one
 2 |    | two
 3 |    | three
 4 |    | four
 5 |    | five
 6 |    | six
 7 |    | seven
 8 |    | eight
 0 |    | zero
   |    | null
   |    | zero
 1 |  0 | one
 2 |  0 | two
 3 |  0 | three
 4 |  0 | four
 5 |  0 | five
 6 |  0 | six
 7 |  0 | seven
 8 |  0 | eight
 0 |  0 | zero
   |  0 | null
   |  0 | zero
(99 rows)

SELECT ii, tt, kk
  FROM (J1_TBL CROSS JOIN J2_TBL)
    AS tx (ii, jj, tt, ii2, kk);
 ii |  tt   | kk 
----+-------+----
  1 | one   | -1
  2 | two   | -1
  3 | three | -1
  4 | four  | -1
  5 | five  | -1
  6 | six   | -1
  7 | seven | -1
  8 | eight | -1
  0 | zero  | -1
    | null  | -1
    | zero  | -1
  1 | one   |  2
  2 | two   |  2
  3 | three |  2
  4 | four  |  2
  5 | five  |  2
  6 | six   |  2
  7 | seven |  2
  8 | eight |  2
  0 | zero  |  2
    | null  |  2
    | zero  |  2
  1 | one   | -3
  2 | two   | -3
  3 | three | -3
  4 | four  | -3
  5 | five  | -3
  6 | six   | -3
  7 | seven | -3
  8 | eight | -3
  0 | zero  | -3
    | null  | -3
    | zero  | -3
  1 | one   |  4
  2 | two   |  4
  3 | three |  4
  4 | four  |  4
  5 | five  |  4
  6 | six   |  4
  7 | seven |  4
  8 | eight |  4
  0 | zero  |  4
    | null  |  4
    | zero  |  4
  1 | one   | -5
  2 | two   | -5
  3 | three | -5
  4 | four  | -5
  5 | five  | -5
  6 | six   | -5
  7 | seven | -5
  8 | eight | -5
  0 | zero  | -5
    | null  | -5
    | zero  | -5
  1 | one   | -5
  2 | two   | -5
  3 | three | -5
  4 | four  | -5
  5 | five  | -5
  6 | six   | -5
  7 | seven | -5
  8 | eight | -5
  0 | zero  | -5
    | null  | -5
    | zero  | -5
  1 | one   |   
  2 | two   |   
  3 | three |   
  4 | four  |   
  5 | five  |   
  6 | six   |   
  7 | seven |   
  8 | eight |   
  0 | zero  |   
    | null  |   
    | zero  |   
  1 | one   |   
  2 | two   |   
  3 | three |   
  4 | four  |   
  5 | five  |   
  6 | six   |   
  7 | seven |   
  8 | eight |   
  0 | zero  |   
    | null  |   
    | zero  |   
  1 | one   |  0
  2 | two   |  0
  3 | three |  0
  4 | four  |  0
  5 | five  |  0
  6 | six   |  0
  7 | seven |  0
  8 | eight |  0
  0 | zero  |  0
    | null  |  0
    | zero  |  0
(99 rows)

SELECT tx.ii, tx.jj, tx.kk
  FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))
    AS tx (ii, jj, tt, ii2, kk);
 ii | jj | kk 
----+----+----
  1 |  4 | -1
  2 |  3 | -1
  3 |  2 | -1
  4 |  1 | -1
  5 |  0 | -1
  6 |  6 | -1
  7 |  7 | -1
  8 |  8 | -1
  0 |    | -1
    |    | -1
    |  0 | -1
  1 |  4 |  2
  2 |  3 |  2
  3 |  2 |  2
  4 |  1 |  2
  5 |  0 |  2
  6 |  6 |  2
  7 |  7 |  2
  8 |  8 |  2
  0 |    |  2
    |    |  2
    |  0 |  2
  1 |  4 | -3
  2 |  3 | -3
  3 |  2 | -3
  4 |  1 | -3
  5 |  0 | -3
  6 |  6 | -3
  7 |  7 | -3
  8 |  8 | -3
  0 |    | -3
    |    | -3
    |  0 | -3
  1 |  4 |  4
  2 |  3 |  4
  3 |  2 |  4
  4 |  1 |  4
  5 |  0 |  4
  6 |  6 |  4
  7 |  7 |  4
  8 |  8 |  4
  0 |    |  4
    |    |  4
    |  0 |  4
  1 |  4 | -5
  2 |  3 | -5
  3 |  2 | -5
  4 |  1 | -5
  5 |  0 | -5
  6 |  6 | -5
  7 |  7 | -5
  8 |  8 | -5
  0 |    | -5
    |    | -5
    |  0 | -5
  1 |  4 | -5
  2 |  3 | -5
  3 |  2 | -5
  4 |  1 | -5
  5 |  0 | -5
  6 |  6 | -5
  7 |  7 | -5
  8 |  8 | -5
  0 |    | -5
    |    | -5
    |  0 | -5
  1 |  4 |   
  2 |  3 |   
  3 |  2 |   
  4 |  1 |   
  5 |  0 |   
  6 |  6 |   
  7 |  7 |   
  8 |  8 |   
  0 |    |   
    |    |   
    |  0 |   
  1 |  4 |   
  2 |  3 |   
  3 |  2 |   
  4 |  1 |   
  5 |  0 |   
  6 |  6 |   
  7 |  7 |   
  8 |  8 |   
  0 |    |   
    |    |   
    |  0 |   
  1 |  4 |  0
  2 |  3 |  0
  3 |  2 |  0
  4 |  1 |  0
  5 |  0 |  0
  6 |  6 |  0
  7 |  7 |  0
  8 |  8 |  0
  0 |    |  0
    |    |  0
    |  0 |  0
(99 rows)

SELECT *
  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;
 i | j |   t   | i | k  | i | k  
---+---+-------+---+----+---+----
 1 | 4 | one   | 1 | -1 | 1 | -1
 1 | 4 | one   | 1 | -1 | 2 |  2
 1 | 4 | one   | 1 | -1 | 3 | -3
 1 | 4 | one   | 1 | -1 | 2 |  4
 1 | 4 | one   | 1 | -1 | 5 | -5
 1 | 4 | one   | 1 | -1 | 5 | -5
 1 | 4 | one   | 1 | -1 | 0 |   
 1 | 4 | one   | 1 | -1 |   |   
 1 | 4 | one   | 1 | -1 |   |  0
 2 | 3 | two   | 1 | -1 | 1 | -1
 2 | 3 | two   | 1 | -1 | 2 |  2
 2 | 3 | two   | 1 | -1 | 3 | -3
 2 | 3 | two   | 1 | -1 | 2 |  4
 2 | 3 | two   | 1 | -1 | 5 | -5
 2 | 3 | two   | 1 | -1 | 5 | -5
 2 | 3 | two   | 1 | -1 | 0 |   
 2 | 3 | two   | 1 | -1 |   |   
 2 | 3 | two   | 1 | -1 |   |  0
 3 | 2 | three | 1 | -1 | 1 | -1
 3 | 2 | three | 1 | -1 | 2 |  2
 3 | 2 | three | 1 | -1 | 3 | -3
 3 | 2 | three | 1 | -1 | 2 |  4
 3 | 2 | three | 1 | -1 | 5 | -5
 3 | 2 | three | 1 | -1 | 5 | -5
 3 | 2 | three | 1 | -1 | 0 |   
 3 | 2 | three | 1 | -1 |   |   
 3 | 2 | three | 1 | -1 |   |  0
 4 | 1 | four  | 1 | -1 | 1 | -1
 4 | 1 | four  | 1 | -1 | 2 |  2
 4 | 1 | four  | 1 | -1 | 3 | -3
 4 | 1 | four  | 1 | -1 | 2 |  4
 4 | 1 | four  | 1 | -1 | 5 | -5
 4 | 1 | four  | 1 | -1 | 5 | -5
 4 | 1 | four  | 1 | -1 | 0 |   
 4 | 1 | four  | 1 | -1 |   |   
 4 | 1 | four  | 1 | -1 |   |  0
 5 | 0 | five  | 1 | -1 | 1 | -1
 5 | 0 | five  | 1 | -1 | 2 |  2
 5 | 0 | five  | 1 | -1 | 3 | -3
 5 | 0 | five  | 1 | -1 | 2 |  4
 5 | 0 | five  | 1 | -1 | 5 | -5
 5 | 0 | five  | 1 | -1 | 5 | -5
 5 | 0 | five  | 1 | -1 | 0 |   
 5 | 0 | five  | 1 | -1 |   |   
 5 | 0 | five  | 1 | -1 |   |  0
 6 | 6 | six   | 1 | -1 | 1 | -1
 6 | 6 | six   | 1 | -1 | 2 |  2
 6 | 6 | six   | 1 | -1 | 3 | -3
 6 | 6 | six   | 1 | -1 | 2 |  4
 6 | 6 | six   | 1 | -1 | 5 | -5
 6 | 6 | six   | 1 | -1 | 5 | -5
 6 | 6 | six   | 1 | -1 | 0 |   
 6 | 6 | six   | 1 | -1 |   |   
 6 | 6 | six   | 1 | -1 |   |  0
 7 | 7 | seven | 1 | -1 | 1 | -1
 7 | 7 | seven | 1 | -1 | 2 |  2
 7 | 7 | seven | 1 | -1 | 3 | -3
 7 | 7 | seven | 1 | -1 | 2 |  4
 7 | 7 | seven | 1 | -1 | 5 | -5
 7 | 7 | seven | 1 | -1 | 5 | -5
 7 | 7 | seven | 1 | -1 | 0 |   
 7 | 7 | seven | 1 | -1 |   |   
 7 | 7 | seven | 1 | -1 |   |  0
 8 | 8 | eight | 1 | -1 | 1 | -1
 8 | 8 | eight | 1 | -1 | 2 |  2
 8 | 8 | eight | 1 | -1 | 3 | -3
 8 | 8 | eight | 1 | -1 | 2 |  4
 8 | 8 | eight | 1 | -1 | 5 | -5
 8 | 8 | eight | 1 | -1 | 5 | -5
 8 | 8 | eight | 1 | -1 | 0 |   
 8 | 8 | eight | 1 | -1 |   |   
 8 | 8 | eight | 1 | -1 |   |  0
 0 |   | zero  | 1 | -1 | 1 | -1
 0 |   | zero  | 1 | -1 | 2 |  2
 0 |   | zero  | 1 | -1 | 3 | -3
 0 |   | zero  | 1 | -1 | 2 |  4
 0 |   | zero  | 1 | -1 | 5 | -5
 0 |   | zero  | 1 | -1 | 5 | -5
 0 |   | zero  | 1 | -1 | 0 |   
 0 |   | zero  | 1 | -1 |   |   
 0 |   | zero  | 1 | -1 |   |  0
   |   | null  | 1 | -1 | 1 | -1
   |   | null  | 1 | -1 | 2 |  2
   |   | null  | 1 | -1 | 3 | -3
   |   | null  | 1 | -1 | 2 |  4
   |   | null  | 1 | -1 | 5 | -5
   |   | null  | 1 | -1 | 5 | -5
   |   | null  | 1 | -1 | 0 |   
   |   | null  | 1 | -1 |   |   
   |   | null  | 1 | -1 |   |  0
   | 0 | zero  | 1 | -1 | 1 | -1
   | 0 | zero  | 1 | -1 | 2 |  2
   | 0 | zero  | 1 | -1 | 3 | -3
   | 0 | zero  | 1 | -1 | 2 |  4
   | 0 | zero  | 1 | -1 | 5 | -5
   | 0 | zero  | 1 | -1 | 5 | -5
   | 0 | zero  | 1 | -1 | 0 |   
   | 0 | zero  | 1 | -1 |   |   
   | 0 | zero  | 1 | -1 |   |  0
 1 | 4 | one   | 2 |  2 | 1 | -1
 1 | 4 | one   | 2 |  2 | 2 |  2
 1 | 4 | one   | 2 |  2 | 3 | -3
 1 | 4 | one   | 2 |  2 | 2 |  4
 1 | 4 | one   | 2 |  2 | 5 | -5
 1 | 4 | one   | 2 |  2 | 5 | -5
 1 | 4 | one   | 2 |  2 | 0 |   
 1 | 4 | one   | 2 |  2 |   |   
 1 | 4 | one   | 2 |  2 |   |  0
 2 | 3 | two   | 2 |  2 | 1 | -1
 2 | 3 | two   | 2 |  2 | 2 |  2
 2 | 3 | two   | 2 |  2 | 3 | -3
 2 | 3 | two   | 2 |  2 | 2 |  4
 2 | 3 | two   | 2 |  2 | 5 | -5
 2 | 3 | two   | 2 |  2 | 5 | -5
 2 | 3 | two   | 2 |  2 | 0 |   
 2 | 3 | two   | 2 |  2 |   |   
 2 | 3 | two   | 2 |  2 |   |  0
 3 | 2 | three | 2 |  2 | 1 | -1
 3 | 2 | three | 2 |  2 | 2 |  2
 3 | 2 | three | 2 |  2 | 3 | -3
 3 | 2 | three | 2 |  2 | 2 |  4
 3 | 2 | three | 2 |  2 | 5 | -5
 3 | 2 | three | 2 |  2 | 5 | -5
 3 | 2 | three | 2 |  2 | 0 |   
 3 | 2 | three | 2 |  2 |   |   
 3 | 2 | three | 2 |  2 |   |  0
 4 | 1 | four  | 2 |  2 | 1 | -1
 4 | 1 | four  | 2 |  2 | 2 |  2
 4 | 1 | four  | 2 |  2 | 3 | -3
 4 | 1 | four  | 2 |  2 | 2 |  4
 4 | 1 | four  | 2 |  2 | 5 | -5
 4 | 1 | four  | 2 |  2 | 5 | -5
 4 | 1 | four  | 2 |  2 | 0 |   
 4 | 1 | four  | 2 |  2 |   |   
 4 | 1 | four  | 2 |  2 |   |  0
 5 | 0 | five  | 2 |  2 | 1 | -1
 5 | 0 | five  | 2 |  2 | 2 |  2
 5 | 0 | five  | 2 |  2 | 3 | -3
 5 | 0 | five  | 2 |  2 | 2 |  4
 5 | 0 | five  | 2 |  2 | 5 | -5
 5 | 0 | five  | 2 |  2 | 5 | -5
 5 | 0 | five  | 2 |  2 | 0 |   
 5 | 0 | five  | 2 |  2 |   |   
 5 | 0 | five  | 2 |  2 |   |  0
 6 | 6 | six   | 2 |  2 | 1 | -1
 6 | 6 | six   | 2 |  2 | 2 |  2
 6 | 6 | six   | 2 |  2 | 3 | -3
 6 | 6 | six   | 2 |  2 | 2 |  4
 6 | 6 | six   | 2 |  2 | 5 | -5
 6 | 6 | six   | 2 |  2 | 5 | -5
 6 | 6 | six   | 2 |  2 | 0 |   
 6 | 6 | six   | 2 |  2 |   |   
 6 | 6 | six   | 2 |  2 |   |  0
 7 | 7 | seven | 2 |  2 | 1 | -1
 7 | 7 | seven | 2 |  2 | 2 |  2
 7 | 7 | seven | 2 |  2 | 3 | -3
 7 | 7 | seven | 2 |  2 | 2 |  4
 7 | 7 | seven | 2 |  2 | 5 | -5
 7 | 7 | seven | 2 |  2 | 5 | -5
 7 | 7 | seven | 2 |  2 | 0 |   
 7 | 7 | seven | 2 |  2 |   |   
 7 | 7 | seven | 2 |  2 |   |  0
 8 | 8 | eight | 2 |  2 | 1 | -1
 8 | 8 | eight | 2 |  2 | 2 |  2
 8 | 8 | eight | 2 |  2 | 3 | -3
 8 | 8 | eight | 2 |  2 | 2 |  4
 8 | 8 | eight | 2 |  2 | 5 | -5
 8 | 8 | eight | 2 |  2 | 5 | -5
 8 | 8 | eight | 2 |  2 | 0 |   
 8 | 8 | eight | 2 |  2 |   |   
 8 | 8 | eight | 2 |  2 |   |  0
 0 |   | zero  | 2 |  2 | 1 | -1
 0 |   | zero  | 2 |  2 | 2 |  2
 0 |   | zero  | 2 |  2 | 3 | -3
 0 |   | zero  | 2 |  2 | 2 |  4
 0 |   | zero  | 2 |  2 | 5 | -5
 0 |   | zero  | 2 |  2 | 5 | -5
 0 |   | zero  | 2 |  2 | 0 |   
 0 |   | zero  | 2 |  2 |   |   
 0 |   | zero  | 2 |  2 |   |  0
   |   | null  | 2 |  2 | 1 | -1
   |   | null  | 2 |  2 | 2 |  2
   |   | null  | 2 |  2 | 3 | -3
   |   | null  | 2 |  2 | 2 |  4
   |   | null  | 2 |  2 | 5 | -5
   |   | null  | 2 |  2 | 5 | -5
   |   | null  | 2 |  2 | 0 |   
   |   | null  | 2 |  2 |   |   
   |   | null  | 2 |  2 |   |  0
   | 0 | zero  | 2 |  2 | 1 | -1
   | 0 | zero  | 2 |  2 | 2 |  2
   | 0 | zero  | 2 |  2 | 3 | -3
   | 0 | zero  | 2 |  2 | 2 |  4
   | 0 | zero  | 2 |  2 | 5 | -5
   | 0 | zero  | 2 |  2 | 5 | -5
   | 0 | zero  | 2 |  2 | 0 |   
   | 0 | zero  | 2 |  2 |   |   
   | 0 | zero  | 2 |  2 |   |  0
 1 | 4 | one   | 3 | -3 | 1 | -1
 1 | 4 | one   | 3 | -3 | 2 |  2
 1 | 4 | one   | 3 | -3 | 3 | -3
 1 | 4 | one   | 3 | -3 | 2 |  4
 1 | 4 | one   | 3 | -3 | 5 | -5
 1 | 4 | one   | 3 | -3 | 5 | -5
 1 | 4 | one   | 3 | -3 | 0 |   
 1 | 4 | one   | 3 | -3 |   |   
 1 | 4 | one   | 3 | -3 |   |  0
 2 | 3 | two   | 3 | -3 | 1 | -1
 2 | 3 | two   | 3 | -3 | 2 |  2
 2 | 3 | two   | 3 | -3 | 3 | -3
 2 | 3 | two   | 3 | -3 | 2 |  4
 2 | 3 | two   | 3 | -3 | 5 | -5
 2 | 3 | two   | 3 | -3 | 5 | -5
 2 | 3 | two   | 3 | -3 | 0 |   
 2 | 3 | two   | 3 | -3 |   |   
 2 | 3 | two   | 3 | -3 |   |  0
 3 | 2 | three | 3 | -3 | 1 | -1
 3 | 2 | three | 3 | -3 | 2 |  2
 3 | 2 | three | 3 | -3 | 3 | -3
 3 | 2 | three | 3 | -3 | 2 |  4
 3 | 2 | three | 3 | -3 | 5 | -5
 3 | 2 | three | 3 | -3 | 5 | -5
 3 | 2 | three | 3 | -3 | 0 |   
 3 | 2 | three | 3 | -3 |   |   
 3 | 2 | three | 3 | -3 |   |  0
 4 | 1 | four  | 3 | -3 | 1 | -1
 4 | 1 | four  | 3 | -3 | 2 |  2
 4 | 1 | four  | 3 | -3 | 3 | -3
 4 | 1 | four  | 3 | -3 | 2 |  4
 4 | 1 | four  | 3 | -3 | 5 | -5
 4 | 1 | four  | 3 | -3 | 5 | -5
 4 | 1 | four  | 3 | -3 | 0 |   
 4 | 1 | four  | 3 | -3 |   |   
 4 | 1 | four  | 3 | -3 |   |  0
 5 | 0 | five  | 3 | -3 | 1 | -1
 5 | 0 | five  | 3 | -3 | 2 |  2
 5 | 0 | five  | 3 | -3 | 3 | -3
 5 | 0 | five  | 3 | -3 | 2 |  4
 5 | 0 | five  | 3 | -3 | 5 | -5
 5 | 0 | five  | 3 | -3 | 5 | -5
 5 | 0 | five  | 3 | -3 | 0 |   
 5 | 0 | five  | 3 | -3 |   |   
 5 | 0 | five  | 3 | -3 |   |  0
 6 | 6 | six   | 3 | -3 | 1 | -1
 6 | 6 | six   | 3 | -3 | 2 |  2
 6 | 6 | six   | 3 | -3 | 3 | -3
 6 | 6 | six   | 3 | -3 | 2 |  4
 6 | 6 | six   | 3 | -3 | 5 | -5
 6 | 6 | six   | 3 | -3 | 5 | -5
 6 | 6 | six   | 3 | -3 | 0 |   
 6 | 6 | six   | 3 | -3 |   |   
 6 | 6 | six   | 3 | -3 |   |  0
 7 | 7 | seven | 3 | -3 | 1 | -1
 7 | 7 | seven | 3 | -3 | 2 |  2
 7 | 7 | seven | 3 | -3 | 3 | -3
 7 | 7 | seven | 3 | -3 | 2 |  4
 7 | 7 | seven | 3 | -3 | 5 | -5
 7 | 7 | seven | 3 | -3 | 5 | -5
 7 | 7 | seven | 3 | -3 | 0 |   
 7 | 7 | seven | 3 | -3 |   |   
 7 | 7 | seven | 3 | -3 |   |  0
 8 | 8 | eight | 3 | -3 | 1 | -1
 8 | 8 | eight | 3 | -3 | 2 |  2
 8 | 8 | eight | 3 | -3 | 3 | -3
 8 | 8 | eight | 3 | -3 | 2 |  4
 8 | 8 | eight | 3 | -3 | 5 | -5
 8 | 8 | eight | 3 | -3 | 5 | -5
 8 | 8 | eight | 3 | -3 | 0 |   
 8 | 8 | eight | 3 | -3 |   |   
 8 | 8 | eight | 3 | -3 |   |  0
 0 |   | zero  | 3 | -3 | 1 | -1
 0 |   | zero  | 3 | -3 | 2 |  2
 0 |   | zero  | 3 | -3 | 3 | -3
 0 |   | zero  | 3 | -3 | 2 |  4
 0 |   | zero  | 3 | -3 | 5 | -5
 0 |   | zero  | 3 | -3 | 5 | -5
 0 |   | zero  | 3 | -3 | 0 |   
 0 |   | zero  | 3 | -3 |   |   
 0 |   | zero  | 3 | -3 |   |  0
   |   | null  | 3 | -3 | 1 | -1
   |   | null  | 3 | -3 | 2 |  2
   |   | null  | 3 | -3 | 3 | -3
   |   | null  | 3 | -3 | 2 |  4
   |   | null  | 3 | -3 | 5 | -5
   |   | null  | 3 | -3 | 5 | -5
   |   | null  | 3 | -3 | 0 |   
   |   | null  | 3 | -3 |   |   
   |   | null  | 3 | -3 |   |  0
   | 0 | zero  | 3 | -3 | 1 | -1
   | 0 | zero  | 3 | -3 | 2 |  2
   | 0 | zero  | 3 | -3 | 3 | -3
   | 0 | zero  | 3 | -3 | 2 |  4
   | 0 | zero  | 3 | -3 | 5 | -5
   | 0 | zero  | 3 | -3 | 5 | -5
   | 0 | zero  | 3 | -3 | 0 |   
   | 0 | zero  | 3 | -3 |   |   
   | 0 | zero  | 3 | -3 |   |  0
 1 | 4 | one   | 2 |  4 | 1 | -1
 1 | 4 | one   | 2 |  4 | 2 |  2
 1 | 4 | one   | 2 |  4 | 3 | -3
 1 | 4 | one   | 2 |  4 | 2 |  4
 1 | 4 | one   | 2 |  4 | 5 | -5
 1 | 4 | one   | 2 |  4 | 5 | -5
 1 | 4 | one   | 2 |  4 | 0 |   
 1 | 4 | one   | 2 |  4 |   |   
 1 | 4 | one   | 2 |  4 |   |  0
 2 | 3 | two   | 2 |  4 | 1 | -1
 2 | 3 | two   | 2 |  4 | 2 |  2
 2 | 3 | two   | 2 |  4 | 3 | -3
 2 | 3 | two   | 2 |  4 | 2 |  4
 2 | 3 | two   | 2 |  4 | 5 | -5
 2 | 3 | two   | 2 |  4 | 5 | -5
 2 | 3 | two   | 2 |  4 | 0 |   
 2 | 3 | two   | 2 |  4 |   |   
 2 | 3 | two   | 2 |  4 |   |  0
 3 | 2 | three | 2 |  4 | 1 | -1
 3 | 2 | three | 2 |  4 | 2 |  2
 3 | 2 | three | 2 |  4 | 3 | -3
 3 | 2 | three | 2 |  4 | 2 |  4
 3 | 2 | three | 2 |  4 | 5 | -5
 3 | 2 | three | 2 |  4 | 5 | -5
 3 | 2 | three | 2 |  4 | 0 |   
 3 | 2 | three | 2 |  4 |   |   
 3 | 2 | three | 2 |  4 |   |  0
 4 | 1 | four  | 2 |  4 | 1 | -1
 4 | 1 | four  | 2 |  4 | 2 |  2
 4 | 1 | four  | 2 |  4 | 3 | -3
 4 | 1 | four  | 2 |  4 | 2 |  4
 4 | 1 | four  | 2 |  4 | 5 | -5
 4 | 1 | four  | 2 |  4 | 5 | -5
 4 | 1 | four  | 2 |  4 | 0 |   
 4 | 1 | four  | 2 |  4 |   |   
 4 | 1 | four  | 2 |  4 |   |  0
 5 | 0 | five  | 2 |  4 | 1 | -1
 5 | 0 | five  | 2 |  4 | 2 |  2
 5 | 0 | five  | 2 |  4 | 3 | -3
 5 | 0 | five  | 2 |  4 | 2 |  4
 5 | 0 | five  | 2 |  4 | 5 | -5
 5 | 0 | five  | 2 |  4 | 5 | -5
 5 | 0 | five  | 2 |  4 | 0 |   
 5 | 0 | five  | 2 |  4 |   |   
 5 | 0 | five  | 2 |  4 |   |  0
 6 | 6 | six   | 2 |  4 | 1 | -1
 6 | 6 | six   | 2 |  4 | 2 |  2
 6 | 6 | six   | 2 |  4 | 3 | -3
 6 | 6 | six   | 2 |  4 | 2 |  4
 6 | 6 | six   | 2 |  4 | 5 | -5
 6 | 6 | six   | 2 |  4 | 5 | -5
 6 | 6 | six   | 2 |  4 | 0 |   
 6 | 6 | six   | 2 |  4 |   |   
 6 | 6 | six   | 2 |  4 |   |  0
 7 | 7 | seven | 2 |  4 | 1 | -1
 7 | 7 | seven | 2 |  4 | 2 |  2
 7 | 7 | seven | 2 |  4 | 3 | -3
 7 | 7 | seven | 2 |  4 | 2 |  4
 7 | 7 | seven | 2 |  4 | 5 | -5
 7 | 7 | seven | 2 |  4 | 5 | -5
 7 | 7 | seven | 2 |  4 | 0 |   
 7 | 7 | seven | 2 |  4 |   |   
 7 | 7 | seven | 2 |  4 |   |  0
 8 | 8 | eight | 2 |  4 | 1 | -1
 8 | 8 | eight | 2 |  4 | 2 |  2
 8 | 8 | eight | 2 |  4 | 3 | -3
 8 | 8 | eight | 2 |  4 | 2 |  4
 8 | 8 | eight | 2 |  4 | 5 | -5
 8 | 8 | eight | 2 |  4 | 5 | -5
 8 | 8 | eight | 2 |  4 | 0 |   
 8 | 8 | eight | 2 |  4 |   |   
 8 | 8 | eight | 2 |  4 |   |  0
 0 |   | zero  | 2 |  4 | 1 | -1
 0 |   | zero  | 2 |  4 | 2 |  2
 0 |   | zero  | 2 |  4 | 3 | -3
 0 |   | zero  | 2 |  4 | 2 |  4
 0 |   | zero  | 2 |  4 | 5 | -5
 0 |   | zero  | 2 |  4 | 5 | -5
 0 |   | zero  | 2 |  4 | 0 |   
 0 |   | zero  | 2 |  4 |   |   
 0 |   | zero  | 2 |  4 |   |  0
   |   | null  | 2 |  4 | 1 | -1
   |   | null  | 2 |  4 | 2 |  2
   |   | null  | 2 |  4 | 3 | -3
   |   | null  | 2 |  4 | 2 |  4
   |   | null  | 2 |  4 | 5 | -5
   |   | null  | 2 |  4 | 5 | -5
   |   | null  | 2 |  4 | 0 |   
   |   | null  | 2 |  4 |   |   
   |   | null  | 2 |  4 |   |  0
   | 0 | zero  | 2 |  4 | 1 | -1
   | 0 | zero  | 2 |  4 | 2 |  2
   | 0 | zero  | 2 |  4 | 3 | -3
   | 0 | zero  | 2 |  4 | 2 |  4
   | 0 | zero  | 2 |  4 | 5 | -5
   | 0 | zero  | 2 |  4 | 5 | -5
   | 0 | zero  | 2 |  4 | 0 |   
   | 0 | zero  | 2 |  4 |   |   
   | 0 | zero  | 2 |  4 |   |  0
 1 | 4 | one   | 5 | -5 | 1 | -1
 1 | 4 | one   | 5 | -5 | 2 |  2
 1 | 4 | one   | 5 | -5 | 3 | -3
 1 | 4 | one   | 5 | -5 | 2 |  4
 1 | 4 | one   | 5 | -5 | 5 | -5
 1 | 4 | one   | 5 | -5 | 5 | -5
 1 | 4 | one   | 5 | -5 | 0 |   
 1 | 4 | one   | 5 | -5 |   |   
 1 | 4 | one   | 5 | -5 |   |  0
 2 | 3 | two   | 5 | -5 | 1 | -1
 2 | 3 | two   | 5 | -5 | 2 |  2
 2 | 3 | two   | 5 | -5 | 3 | -3
 2 | 3 | two   | 5 | -5 | 2 |  4
 2 | 3 | two   | 5 | -5 | 5 | -5
 2 | 3 | two   | 5 | -5 | 5 | -5
 2 | 3 | two   | 5 | -5 | 0 |   
 2 | 3 | two   | 5 | -5 |   |   
 2 | 3 | two   | 5 | -5 |   |  0
 3 | 2 | three | 5 | -5 | 1 | -1
 3 | 2 | three | 5 | -5 | 2 |  2
 3 | 2 | three | 5 | -5 | 3 | -3
 3 | 2 | three | 5 | -5 | 2 |  4
 3 | 2 | three | 5 | -5 | 5 | -5
 3 | 2 | three | 5 | -5 | 5 | -5
 3 | 2 | three | 5 | -5 | 0 |   
 3 | 2 | three | 5 | -5 |   |   
 3 | 2 | three | 5 | -5 |   |  0
 4 | 1 | four  | 5 | -5 | 1 | -1
 4 | 1 | four  | 5 | -5 | 2 |  2
 4 | 1 | four  | 5 | -5 | 3 | -3
 4 | 1 | four  | 5 | -5 | 2 |  4
 4 | 1 | four  | 5 | -5 | 5 | -5
 4 | 1 | four  | 5 | -5 | 5 | -5
 4 | 1 | four  | 5 | -5 | 0 |   
 4 | 1 | four  | 5 | -5 |   |   
 4 | 1 | four  | 5 | -5 |   |  0
 5 | 0 | five  | 5 | -5 | 1 | -1
 5 | 0 | five  | 5 | -5 | 2 |  2
 5 | 0 | five  | 5 | -5 | 3 | -3
 5 | 0 | five  | 5 | -5 | 2 |  4
 5 | 0 | five  | 5 | -5 | 5 | -5
 5 | 0 | five  | 5 | -5 | 5 | -5
 5 | 0 | five  | 5 | -5 | 0 |   
 5 | 0 | five  | 5 | -5 |   |   
 5 | 0 | five  | 5 | -5 |   |  0
 6 | 6 | six   | 5 | -5 | 1 | -1
 6 | 6 | six   | 5 | -5 | 2 |  2
 6 | 6 | six   | 5 | -5 | 3 | -3
 6 | 6 | six   | 5 | -5 | 2 |  4
 6 | 6 | six   | 5 | -5 | 5 | -5
 6 | 6 | six   | 5 | -5 | 5 | -5
 6 | 6 | six   | 5 | -5 | 0 |   
 6 | 6 | six   | 5 | -5 |   |   
 6 | 6 | six   | 5 | -5 |   |  0
 7 | 7 | seven | 5 | -5 | 1 | -1
 7 | 7 | seven | 5 | -5 | 2 |  2
 7 | 7 | seven | 5 | -5 | 3 | -3
 7 | 7 | seven | 5 | -5 | 2 |  4
 7 | 7 | seven | 5 | -5 | 5 | -5
 7 | 7 | seven | 5 | -5 | 5 | -5
 7 | 7 | seven | 5 | -5 | 0 |   
 7 | 7 | seven | 5 | -5 |   |   
 7 | 7 | seven | 5 | -5 |   |  0
 8 | 8 | eight | 5 | -5 | 1 | -1
 8 | 8 | eight | 5 | -5 | 2 |  2
 8 | 8 | eight | 5 | -5 | 3 | -3
 8 | 8 | eight | 5 | -5 | 2 |  4
 8 | 8 | eight | 5 | -5 | 5 | -5
 8 | 8 | eight | 5 | -5 | 5 | -5
 8 | 8 | eight | 5 | -5 | 0 |   
 8 | 8 | eight | 5 | -5 |   |   
 8 | 8 | eight | 5 | -5 |   |  0
 0 |   | zero  | 5 | -5 | 1 | -1
 0 |   | zero  | 5 | -5 | 2 |  2
 0 |   | zero  | 5 | -5 | 3 | -3
 0 |   | zero  | 5 | -5 | 2 |  4
 0 |   | zero  | 5 | -5 | 5 | -5
 0 |   | zero  | 5 | -5 | 5 | -5
 0 |   | zero  | 5 | -5 | 0 |   
 0 |   | zero  | 5 | -5 |   |   
 0 |   | zero  | 5 | -5 |   |  0
   |   | null  | 5 | -5 | 1 | -1
   |   | null  | 5 | -5 | 2 |  2
   |   | null  | 5 | -5 | 3 | -3
   |   | null  | 5 | -5 | 2 |  4
   |   | null  | 5 | -5 | 5 | -5
   |   | null  | 5 | -5 | 5 | -5
   |   | null  | 5 | -5 | 0 |   
   |   | null  | 5 | -5 |   |   
   |   | null  | 5 | -5 |   |  0
   | 0 | zero  | 5 | -5 | 1 | -1
   | 0 | zero  | 5 | -5 | 2 |  2
   | 0 | zero  | 5 | -5 | 3 | -3
   | 0 | zero  | 5 | -5 | 2 |  4
   | 0 | zero  | 5 | -5 | 5 | -5
   | 0 | zero  | 5 | -5 | 5 | -5
   | 0 | zero  | 5 | -5 | 0 |   
   | 0 | zero  | 5 | -5 |   |   
   | 0 | zero  | 5 | -5 |   |  0
 1 | 4 | one   | 5 | -5 | 1 | -1
 1 | 4 | one   | 5 | -5 | 2 |  2
 1 | 4 | one   | 5 | -5 | 3 | -3
 1 | 4 | one   | 5 | -5 | 2 |  4
 1 | 4 | one   | 5 | -5 | 5 | -5
 1 | 4 | one   | 5 | -5 | 5 | -5
 1 | 4 | one   | 5 | -5 | 0 |   
 1 | 4 | one   | 5 | -5 |   |   
 1 | 4 | one   | 5 | -5 |   |  0
 2 | 3 | two   | 5 | -5 | 1 | -1
 2 | 3 | two   | 5 | -5 | 2 |  2
 2 | 3 | two   | 5 | -5 | 3 | -3
 2 | 3 | two   | 5 | -5 | 2 |  4
 2 | 3 | two   | 5 | -5 | 5 | -5
 2 | 3 | two   | 5 | -5 | 5 | -5
 2 | 3 | two   | 5 | -5 | 0 |   
 2 | 3 | two   | 5 | -5 |   |   
 2 | 3 | two   | 5 | -5 |   |  0
 3 | 2 | three | 5 | -5 | 1 | -1
 3 | 2 | three | 5 | -5 | 2 |  2
 3 | 2 | three | 5 | -5 | 3 | -3
 3 | 2 | three | 5 | -5 | 2 |  4
 3 | 2 | three | 5 | -5 | 5 | -5
 3 | 2 | three | 5 | -5 | 5 | -5
 3 | 2 | three | 5 | -5 | 0 |   
 3 | 2 | three | 5 | -5 |   |   
 3 | 2 | three | 5 | -5 |   |  0
 4 | 1 | four  | 5 | -5 | 1 | -1
 4 | 1 | four  | 5 | -5 | 2 |  2
 4 | 1 | four  | 5 | -5 | 3 | -3
 4 | 1 | four  | 5 | -5 | 2 |  4
 4 | 1 | four  | 5 | -5 | 5 | -5
 4 | 1 | four  | 5 | -5 | 5 | -5
 4 | 1 | four  | 5 | -5 | 0 |   
 4 | 1 | four  | 5 | -5 |   |   
 4 | 1 | four  | 5 | -5 |   |  0
 5 | 0 | five  | 5 | -5 | 1 | -1
 5 | 0 | five  | 5 | -5 | 2 |  2
 5 | 0 | five  | 5 | -5 | 3 | -3
 5 | 0 | five  | 5 | -5 | 2 |  4
 5 | 0 | five  | 5 | -5 | 5 | -5
 5 | 0 | five  | 5 | -5 | 5 | -5
 5 | 0 | five  | 5 | -5 | 0 |   
 5 | 0 | five  | 5 | -5 |   |   
 5 | 0 | five  | 5 | -5 |   |  0
 6 | 6 | six   | 5 | -5 | 1 | -1
 6 | 6 | six   | 5 | -5 | 2 |  2
 6 | 6 | six   | 5 | -5 | 3 | -3
 6 | 6 | six   | 5 | -5 | 2 |  4
 6 | 6 | six   | 5 | -5 | 5 | -5
 6 | 6 | six   | 5 | -5 | 5 | -5
 6 | 6 | six   | 5 | -5 | 0 |   
 6 | 6 | six   | 5 | -5 |   |   
 6 | 6 | six   | 5 | -5 |   |  0
 7 | 7 | seven | 5 | -5 | 1 | -1
 7 | 7 | seven | 5 | -5 | 2 |  2
 7 | 7 | seven | 5 | -5 | 3 | -3
 7 | 7 | seven | 5 | -5 | 2 |  4
 7 | 7 | seven | 5 | -5 | 5 | -5
 7 | 7 | seven | 5 | -5 | 5 | -5
 7 | 7 | seven | 5 | -5 | 0 |   
 7 | 7 | seven | 5 | -5 |   |   
 7 | 7 | seven | 5 | -5 |   |  0
 8 | 8 | eight | 5 | -5 | 1 | -1
 8 | 8 | eight | 5 | -5 | 2 |  2
 8 | 8 | eight | 5 | -5 | 3 | -3
 8 | 8 | eight | 5 | -5 | 2 |  4
 8 | 8 | eight | 5 | -5 | 5 | -5
 8 | 8 | eight | 5 | -5 | 5 | -5
 8 | 8 | eight | 5 | -5 | 0 |   
 8 | 8 | eight | 5 | -5 |   |   
 8 | 8 | eight | 5 | -5 |   |  0
 0 |   | zero  | 5 | -5 | 1 | -1
 0 |   | zero  | 5 | -5 | 2 |  2
 0 |   | zero  | 5 | -5 | 3 | -3
 0 |   | zero  | 5 | -5 | 2 |  4
 0 |   | zero  | 5 | -5 | 5 | -5
 0 |   | zero  | 5 | -5 | 5 | -5
 0 |   | zero  | 5 | -5 | 0 |   
 0 |   | zero  | 5 | -5 |   |   
 0 |   | zero  | 5 | -5 |   |  0
   |   | null  | 5 | -5 | 1 | -1
   |   | null  | 5 | -5 | 2 |  2
   |   | null  | 5 | -5 | 3 | -3
   |   | null  | 5 | -5 | 2 |  4
   |   | null  | 5 | -5 | 5 | -5
   |   | null  | 5 | -5 | 5 | -5
   |   | null  | 5 | -5 | 0 |   
   |   | null  | 5 | -5 |   |   
   |   | null  | 5 | -5 |   |  0
   | 0 | zero  | 5 | -5 | 1 | -1
   | 0 | zero  | 5 | -5 | 2 |  2
   | 0 | zero  | 5 | -5 | 3 | -3
   | 0 | zero  | 5 | -5 | 2 |  4
   | 0 | zero  | 5 | -5 | 5 | -5
   | 0 | zero  | 5 | -5 | 5 | -5
   | 0 | zero  | 5 | -5 | 0 |   
   | 0 | zero  | 5 | -5 |   |   
   | 0 | zero  | 5 | -5 |   |  0
 1 | 4 | one   | 0 |    | 1 | -1
 1 | 4 | one   | 0 |    | 2 |  2
 1 | 4 | one   | 0 |    | 3 | -3
 1 | 4 | one   | 0 |    | 2 |  4
 1 | 4 | one   | 0 |    | 5 | -5
 1 | 4 | one   | 0 |    | 5 | -5
 1 | 4 | one   | 0 |    | 0 |   
 1 | 4 | one   | 0 |    |   |   
 1 | 4 | one   | 0 |    |   |  0
 2 | 3 | two   | 0 |    | 1 | -1
 2 | 3 | two   | 0 |    | 2 |  2
 2 | 3 | two   | 0 |    | 3 | -3
 2 | 3 | two   | 0 |    | 2 |  4
 2 | 3 | two   | 0 |    | 5 | -5
 2 | 3 | two   | 0 |    | 5 | -5
 2 | 3 | two   | 0 |    | 0 |   
 2 | 3 | two   | 0 |    |   |   
 2 | 3 | two   | 0 |    |   |  0
 3 | 2 | three | 0 |    | 1 | -1
 3 | 2 | three | 0 |    | 2 |  2
 3 | 2 | three | 0 |    | 3 | -3
 3 | 2 | three | 0 |    | 2 |  4
 3 | 2 | three | 0 |    | 5 | -5
 3 | 2 | three | 0 |    | 5 | -5
 3 | 2 | three | 0 |    | 0 |   
 3 | 2 | three | 0 |    |   |   
 3 | 2 | three | 0 |    |   |  0
 4 | 1 | four  | 0 |    | 1 | -1
 4 | 1 | four  | 0 |    | 2 |  2
 4 | 1 | four  | 0 |    | 3 | -3
 4 | 1 | four  | 0 |    | 2 |  4
 4 | 1 | four  | 0 |    | 5 | -5
 4 | 1 | four  | 0 |    | 5 | -5
 4 | 1 | four  | 0 |    | 0 |   
 4 | 1 | four  | 0 |    |   |   
 4 | 1 | four  | 0 |    |   |  0
 5 | 0 | five  | 0 |    | 1 | -1
 5 | 0 | five  | 0 |    | 2 |  2
 5 | 0 | five  | 0 |    | 3 | -3
 5 | 0 | five  | 0 |    | 2 |  4
 5 | 0 | five  | 0 |    | 5 | -5
 5 | 0 | five  | 0 |    | 5 | -5
 5 | 0 | five  | 0 |    | 0 |   
 5 | 0 | five  | 0 |    |   |   
 5 | 0 | five  | 0 |    |   |  0
 6 | 6 | six   | 0 |    | 1 | -1
 6 | 6 | six   | 0 |    | 2 |  2
 6 | 6 | six   | 0 |    | 3 | -3
 6 | 6 | six   | 0 |    | 2 |  4
 6 | 6 | six   | 0 |    | 5 | -5
 6 | 6 | six   | 0 |    | 5 | -5
 6 | 6 | six   | 0 |    | 0 |   
 6 | 6 | six   | 0 |    |   |   
 6 | 6 | six   | 0 |    |   |  0
 7 | 7 | seven | 0 |    | 1 | -1
 7 | 7 | seven | 0 |    | 2 |  2
 7 | 7 | seven | 0 |    | 3 | -3
 7 | 7 | seven | 0 |    | 2 |  4
 7 | 7 | seven | 0 |    | 5 | -5
 7 | 7 | seven | 0 |    | 5 | -5
 7 | 7 | seven | 0 |    | 0 |   
 7 | 7 | seven | 0 |    |   |   
 7 | 7 | seven | 0 |    |   |  0
 8 | 8 | eight | 0 |    | 1 | -1
 8 | 8 | eight | 0 |    | 2 |  2
 8 | 8 | eight | 0 |    | 3 | -3
 8 | 8 | eight | 0 |    | 2 |  4
 8 | 8 | eight | 0 |    | 5 | -5
 8 | 8 | eight | 0 |    | 5 | -5
 8 | 8 | eight | 0 |    | 0 |   
 8 | 8 | eight | 0 |    |   |   
 8 | 8 | eight | 0 |    |   |  0
 0 |   | zero  | 0 |    | 1 | -1
 0 |   | zero  | 0 |    | 2 |  2
 0 |   | zero  | 0 |    | 3 | -3
 0 |   | zero  | 0 |    | 2 |  4
 0 |   | zero  | 0 |    | 5 | -5
 0 |   | zero  | 0 |    | 5 | -5
 0 |   | zero  | 0 |    | 0 |   
 0 |   | zero  | 0 |    |   |   
 0 |   | zero  | 0 |    |   |  0
   |   | null  | 0 |    | 1 | -1
   |   | null  | 0 |    | 2 |  2
   |   | null  | 0 |    | 3 | -3
   |   | null  | 0 |    | 2 |  4
   |   | null  | 0 |    | 5 | -5
   |   | null  | 0 |    | 5 | -5
   |   | null  | 0 |    | 0 |   
   |   | null  | 0 |    |   |   
   |   | null  | 0 |    |   |  0
   | 0 | zero  | 0 |    | 1 | -1
   | 0 | zero  | 0 |    | 2 |  2
   | 0 | zero  | 0 |    | 3 | -3
   | 0 | zero  | 0 |    | 2 |  4
   | 0 | zero  | 0 |    | 5 | -5
   | 0 | zero  | 0 |    | 5 | -5
   | 0 | zero  | 0 |    | 0 |   
   | 0 | zero  | 0 |    |   |   
   | 0 | zero  | 0 |    |   |  0
 1 | 4 | one   |   |    | 1 | -1
 1 | 4 | one   |   |    | 2 |  2
 1 | 4 | one   |   |    | 3 | -3
 1 | 4 | one   |   |    | 2 |  4
 1 | 4 | one   |   |    | 5 | -5
 1 | 4 | one   |   |    | 5 | -5
 1 | 4 | one   |   |    | 0 |   
 1 | 4 | one   |   |    |   |   
 1 | 4 | one   |   |    |   |  0
 2 | 3 | two   |   |    | 1 | -1
 2 | 3 | two   |   |    | 2 |  2
 2 | 3 | two   |   |    | 3 | -3
 2 | 3 | two   |   |    | 2 |  4
 2 | 3 | two   |   |    | 5 | -5
 2 | 3 | two   |   |    | 5 | -5
 2 | 3 | two   |   |    | 0 |   
 2 | 3 | two   |   |    |   |   
 2 | 3 | two   |   |    |   |  0
 3 | 2 | three |   |    | 1 | -1
 3 | 2 | three |   |    | 2 |  2
 3 | 2 | three |   |    | 3 | -3
 3 | 2 | three |   |    | 2 |  4
 3 | 2 | three |   |    | 5 | -5
 3 | 2 | three |   |    | 5 | -5
 3 | 2 | three |   |    | 0 |   
 3 | 2 | three |   |    |   |   
 3 | 2 | three |   |    |   |  0
 4 | 1 | four  |   |    | 1 | -1
 4 | 1 | four  |   |    | 2 |  2
 4 | 1 | four  |   |    | 3 | -3
 4 | 1 | four  |   |    | 2 |  4
 4 | 1 | four  |   |    | 5 | -5
 4 | 1 | four  |   |    | 5 | -5
 4 | 1 | four  |   |    | 0 |   
 4 | 1 | four  |   |    |   |   
 4 | 1 | four  |   |    |   |  0
 5 | 0 | five  |   |    | 1 | -1
 5 | 0 | five  |   |    | 2 |  2
 5 | 0 | five  |   |    | 3 | -3
 5 | 0 | five  |   |    | 2 |  4
 5 | 0 | five  |   |    | 5 | -5
 5 | 0 | five  |   |    | 5 | -5
 5 | 0 | five  |   |    | 0 |   
 5 | 0 | five  |   |    |   |   
 5 | 0 | five  |   |    |   |  0
 6 | 6 | six   |   |    | 1 | -1
 6 | 6 | six   |   |    | 2 |  2
 6 | 6 | six   |   |    | 3 | -3
 6 | 6 | six   |   |    | 2 |  4
 6 | 6 | six   |   |    | 5 | -5
 6 | 6 | six   |   |    | 5 | -5
 6 | 6 | six   |   |    | 0 |   
 6 | 6 | six   |   |    |   |   
 6 | 6 | six   |   |    |   |  0
 7 | 7 | seven |   |    | 1 | -1
 7 | 7 | seven |   |    | 2 |  2
 7 | 7 | seven |   |    | 3 | -3
 7 | 7 | seven |   |    | 2 |  4
 7 | 7 | seven |   |    | 5 | -5
 7 | 7 | seven |   |    | 5 | -5
 7 | 7 | seven |   |    | 0 |   
 7 | 7 | seven |   |    |   |   
 7 | 7 | seven |   |    |   |  0
 8 | 8 | eight |   |    | 1 | -1
 8 | 8 | eight |   |    | 2 |  2
 8 | 8 | eight |   |    | 3 | -3
 8 | 8 | eight |   |    | 2 |  4
 8 | 8 | eight |   |    | 5 | -5
 8 | 8 | eight |   |    | 5 | -5
 8 | 8 | eight |   |    | 0 |   
 8 | 8 | eight |   |    |   |   
 8 | 8 | eight |   |    |   |  0
 0 |   | zero  |   |    | 1 | -1
 0 |   | zero  |   |    | 2 |  2
 0 |   | zero  |   |    | 3 | -3
 0 |   | zero  |   |    | 2 |  4
 0 |   | zero  |   |    | 5 | -5
 0 |   | zero  |   |    | 5 | -5
 0 |   | zero  |   |    | 0 |   
 0 |   | zero  |   |    |   |   
 0 |   | zero  |   |    |   |  0
   |   | null  |   |    | 1 | -1
   |   | null  |   |    | 2 |  2
   |   | null  |   |    | 3 | -3
   |   | null  |   |    | 2 |  4
   |   | null  |   |    | 5 | -5
   |   | null  |   |    | 5 | -5
   |   | null  |   |    | 0 |   
   |   | null  |   |    |   |   
   |   | null  |   |    |   |  0
   | 0 | zero  |   |    | 1 | -1
   | 0 | zero  |   |    | 2 |  2
   | 0 | zero  |   |    | 3 | -3
   | 0 | zero  |   |    | 2 |  4
   | 0 | zero  |   |    | 5 | -5
   | 0 | zero  |   |    | 5 | -5
   | 0 | zero  |   |    | 0 |   
   | 0 | zero  |   |    |   |   
   | 0 | zero  |   |    |   |  0
 1 | 4 | one   |   |  0 | 1 | -1
 1 | 4 | one   |   |  0 | 2 |  2
 1 | 4 | one   |   |  0 | 3 | -3
 1 | 4 | one   |   |  0 | 2 |  4
 1 | 4 | one   |   |  0 | 5 | -5
 1 | 4 | one   |   |  0 | 5 | -5
 1 | 4 | one   |   |  0 | 0 |   
 1 | 4 | one   |   |  0 |   |   
 1 | 4 | one   |   |  0 |   |  0
 2 | 3 | two   |   |  0 | 1 | -1
 2 | 3 | two   |   |  0 | 2 |  2
 2 | 3 | two   |   |  0 | 3 | -3
 2 | 3 | two   |   |  0 | 2 |  4
 2 | 3 | two   |   |  0 | 5 | -5
 2 | 3 | two   |   |  0 | 5 | -5
 2 | 3 | two   |   |  0 | 0 |   
 2 | 3 | two   |   |  0 |   |   
 2 | 3 | two   |   |  0 |   |  0
 3 | 2 | three |   |  0 | 1 | -1
 3 | 2 | three |   |  0 | 2 |  2
 3 | 2 | three |   |  0 | 3 | -3
 3 | 2 | three |   |  0 | 2 |  4
 3 | 2 | three |   |  0 | 5 | -5
 3 | 2 | three |   |  0 | 5 | -5
 3 | 2 | three |   |  0 | 0 |   
 3 | 2 | three |   |  0 |   |   
 3 | 2 | three |   |  0 |   |  0
 4 | 1 | four  |   |  0 | 1 | -1
 4 | 1 | four  |   |  0 | 2 |  2
 4 | 1 | four  |   |  0 | 3 | -3
 4 | 1 | four  |   |  0 | 2 |  4
 4 | 1 | four  |   |  0 | 5 | -5
 4 | 1 | four  |   |  0 | 5 | -5
 4 | 1 | four  |   |  0 | 0 |   
 4 | 1 | four  |   |  0 |   |   
 4 | 1 | four  |   |  0 |   |  0
 5 | 0 | five  |   |  0 | 1 | -1
 5 | 0 | five  |   |  0 | 2 |  2
 5 | 0 | five  |   |  0 | 3 | -3
 5 | 0 | five  |   |  0 | 2 |  4
 5 | 0 | five  |   |  0 | 5 | -5
 5 | 0 | five  |   |  0 | 5 | -5
 5 | 0 | five  |   |  0 | 0 |   
 5 | 0 | five  |   |  0 |   |   
 5 | 0 | five  |   |  0 |   |  0
 6 | 6 | six   |   |  0 | 1 | -1
 6 | 6 | six   |   |  0 | 2 |  2
 6 | 6 | six   |   |  0 | 3 | -3
 6 | 6 | six   |   |  0 | 2 |  4
 6 | 6 | six   |   |  0 | 5 | -5
 6 | 6 | six   |   |  0 | 5 | -5
 6 | 6 | six   |   |  0 | 0 |   
 6 | 6 | six   |   |  0 |   |   
 6 | 6 | six   |   |  0 |   |  0
 7 | 7 | seven |   |  0 | 1 | -1
 7 | 7 | seven |   |  0 | 2 |  2
 7 | 7 | seven |   |  0 | 3 | -3
 7 | 7 | seven |   |  0 | 2 |  4
 7 | 7 | seven |   |  0 | 5 | -5
 7 | 7 | seven |   |  0 | 5 | -5
 7 | 7 | seven |   |  0 | 0 |   
 7 | 7 | seven |   |  0 |   |   
 7 | 7 | seven |   |  0 |   |  0
 8 | 8 | eight |   |  0 | 1 | -1
 8 | 8 | eight |   |  0 | 2 |  2
 8 | 8 | eight |   |  0 | 3 | -3
 8 | 8 | eight |   |  0 | 2 |  4
 8 | 8 | eight |   |  0 | 5 | -5
 8 | 8 | eight |   |  0 | 5 | -5
 8 | 8 | eight |   |  0 | 0 |   
 8 | 8 | eight |   |  0 |   |   
 8 | 8 | eight |   |  0 |   |  0
 0 |   | zero  |   |  0 | 1 | -1
 0 |   | zero  |   |  0 | 2 |  2
 0 |   | zero  |   |  0 | 3 | -3
 0 |   | zero  |   |  0 | 2 |  4
 0 |   | zero  |   |  0 | 5 | -5
 0 |   | zero  |   |  0 | 5 | -5
 0 |   | zero  |   |  0 | 0 |   
 0 |   | zero  |   |  0 |   |   
 0 |   | zero  |   |  0 |   |  0
   |   | null  |   |  0 | 1 | -1
   |   | null  |   |  0 | 2 |  2
   |   | null  |   |  0 | 3 | -3
   |   | null  |   |  0 | 2 |  4
   |   | null  |   |  0 | 5 | -5
   |   | null  |   |  0 | 5 | -5
   |   | null  |   |  0 | 0 |   
   |   | null  |   |  0 |   |   
   |   | null  |   |  0 |   |  0
   | 0 | zero  |   |  0 | 1 | -1
   | 0 | zero  |   |  0 | 2 |  2
   | 0 | zero  |   |  0 | 3 | -3
   | 0 | zero  |   |  0 | 2 |  4
   | 0 | zero  |   |  0 | 5 | -5
   | 0 | zero  |   |  0 | 5 | -5
   | 0 | zero  |   |  0 | 0 |   
   | 0 | zero  |   |  0 |   |   
   | 0 | zero  |   |  0 |   |  0
(891 rows)

--
--
-- Inner joins (equi-joins)
--
--
--
-- Inner joins (equi-joins) with USING clause
-- The USING syntax changes the shape of the resulting table
-- by including a column in the USING clause only once in the result.
--
-- Inner equi-join on specified column
SELECT *
  FROM J1_TBL INNER JOIN J2_TBL USING (i);
 i | j |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 5 | 0 | five  | -5
 5 | 0 | five  | -5
(7 rows)

-- Same as above, slightly different syntax
SELECT *
  FROM J1_TBL JOIN J2_TBL USING (i);
 i | j |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 5 | 0 | five  | -5
 5 | 0 | five  | -5
(7 rows)

SELECT *
  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)
  ORDER BY a, d;
 a | b |   c   | d  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 5 | 0 | five  | -5
 5 | 0 | five  | -5
(7 rows)

SELECT *
  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)
  ORDER BY b, t1.a;
 b | a |   c   | a 
---+---+-------+---
 0 | 5 | five  |  
 0 |   | zero  |  
 2 | 3 | three | 2
 4 | 1 | one   | 2
(4 rows)

-- test join using aliases
SELECT * FROM J1_TBL JOIN J2_TBL USING (i) WHERE J1_TBL.t = 'one';  -- ok
 i | j |  t  | k  
---+---+-----+----
 1 | 4 | one | -1
(1 row)

SELECT * FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE J1_TBL.t = 'one';  -- ok
 i | j |  t  | k  
---+---+-----+----
 1 | 4 | one | -1
(1 row)

SELECT * FROM (J1_TBL JOIN J2_TBL USING (i)) AS x WHERE J1_TBL.t = 'one';  -- error
ERROR:  invalid reference to FROM-clause entry for table "j1_tbl"
LINE 1: ... * FROM (J1_TBL JOIN J2_TBL USING (i)) AS x WHERE J1_TBL.t =...
                                                             ^
HINT:  There is an entry for table "j1_tbl", but it cannot be referenced from this part of the query.
SELECT * FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE x.i = 1;  -- ok
 i | j |  t  | k  
---+---+-----+----
 1 | 4 | one | -1
(1 row)

SELECT * FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE x.t = 'one';  -- error
ERROR:  column x.t does not exist
LINE 1: ...CT * FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE x.t = 'one...
                                                             ^
SELECT * FROM (J1_TBL JOIN J2_TBL USING (i) AS x) AS xx WHERE x.i = 1;  -- error (XXX could use better hint)
ERROR:  missing FROM-clause entry for table "x"
LINE 1: ...ROM (J1_TBL JOIN J2_TBL USING (i) AS x) AS xx WHERE x.i = 1;
                                                               ^
SELECT * FROM J1_TBL a1 JOIN J2_TBL a2 USING (i) AS a1;  -- error
ERROR:  table name "a1" specified more than once
SELECT x.* FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE J1_TBL.t = 'one';
 i 
---
 1
(1 row)

SELECT ROW(x.*) FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE J1_TBL.t = 'one';
 row 
-----
 (1)
(1 row)

SELECT row_to_json(x.*) FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE J1_TBL.t = 'one';
 row_to_json 
-------------
 {"i":1}
(1 row)

--
-- NATURAL JOIN
-- Inner equi-join on all columns with the same name
--
SELECT *
  FROM J1_TBL NATURAL JOIN J2_TBL;
 i | j |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 5 | 0 | five  | -5
 5 | 0 | five  | -5
(7 rows)

SELECT *
  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);
 a | b |   c   | d  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 5 | 0 | five  | -5
 5 | 0 | five  | -5
(7 rows)

SELECT *
  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);
 a | b |  c   | d 
---+---+------+---
 0 |   | zero |  
 2 | 3 | two  | 2
 4 | 1 | four | 2
(3 rows)

-- mismatch number of columns
-- currently, Postgres will fill in with underlying names
SELECT *
  FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);
 a | b |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 5 | 0 | five  | -5
 5 | 0 | five  | -5
(7 rows)

--
-- Inner joins (equi-joins)
--
SELECT *
  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);
 i | j |   t   | i | k  
---+---+-------+---+----
 0 |   | zero  | 0 |   
 1 | 4 | one   | 1 | -1
 2 | 3 | two   | 2 |  2
 2 | 3 | two   | 2 |  4
 3 | 2 | three | 3 | -3
 5 | 0 | five  | 5 | -5
 5 | 0 | five  | 5 | -5
(7 rows)

SELECT *
  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);
 i | j |  t   | i | k 
---+---+------+---+---
 0 |   | zero |   | 0
 2 | 3 | two  | 2 | 2
 4 | 1 | four | 2 | 4
(3 rows)

--
-- Non-equi-joins
--
SELECT *
  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);
 i | j |   t   | i | k 
---+---+-------+---+---
 1 | 4 | one   | 2 | 2
 2 | 3 | two   | 2 | 2
 0 |   | zero  | 2 | 2
 1 | 4 | one   | 2 | 4
 2 | 3 | two   | 2 | 4
 3 | 2 | three | 2 | 4
 4 | 1 | four  | 2 | 4
 0 |   | zero  | 2 | 4
 0 |   | zero  |   | 0
(9 rows)

--
-- Outer joins
-- Note that OUTER is a noise word
--
SELECT *
  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
 i | j |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 4 | 1 | four  |   
 5 | 0 | five  | -5
 5 | 0 | five  | -5
 6 | 6 | six   |   
 7 | 7 | seven |   
 8 | 8 | eight |   
   |   | null  |   
   | 0 | zero  |   
(13 rows)

SELECT *
  FROM J1_TBL LEFT JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
 i | j |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 4 | 1 | four  |   
 5 | 0 | five  | -5
 5 | 0 | five  | -5
 6 | 6 | six   |   
 7 | 7 | seven |   
 8 | 8 | eight |   
   |   | null  |   
   | 0 | zero  |   
(13 rows)

SELECT *
  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);
 i | j |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 5 | 0 | five  | -5
 5 | 0 | five  | -5
   |   |       |   
   |   |       |  0
(9 rows)

SELECT *
  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);
 i | j |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 5 | 0 | five  | -5
 5 | 0 | five  | -5
   |   |       |   
   |   |       |  0
(9 rows)

SELECT *
  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
 i | j |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 4 | 1 | four  |   
 5 | 0 | five  | -5
 5 | 0 | five  | -5
 6 | 6 | six   |   
 7 | 7 | seven |   
 8 | 8 | eight |   
   |   |       |  0
   |   | null  |   
   | 0 | zero  |   
   |   |       |   
(15 rows)

SELECT *
  FROM J1_TBL FULL JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
 i | j |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 4 | 1 | four  |   
 5 | 0 | five  | -5
 5 | 0 | five  | -5
 6 | 6 | six   |   
 7 | 7 | seven |   
 8 | 8 | eight |   
   |   |       |  0
   |   | null  |   
   | 0 | zero  |   
   |   |       |   
(15 rows)

SELECT *
  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);
 i | j | t | k 
---+---+---+---
(0 rows)

SELECT *
  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);
 i | j |  t  | k  
---+---+-----+----
 1 | 4 | one | -1
(1 row)

--
-- semijoin selectivity for <>
--
explain (costs off)
select * from int4_tbl i4, tenk1 a
where exists(select * from tenk1 b
             where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)
      and i4.f1 = a.tenthous;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  HashAggregate
         Group Key: (RowIdExpr)
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: (RowIdExpr)
               ->  Hash Join
                     Hash Cond: (b.twothousand = a.twothousand)
                     Join Filter: (a.fivethous <> b.fivethous)
                     ->  Seq Scan on tenk1 b
                     ->  Hash
                           ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                 ->  Hash Join
                                       Hash Cond: (a.tenthous = i4.f1)
                                       ->  Seq Scan on tenk1 a
                                       ->  Hash
                                             ->  Broadcast Motion 3:3  (slice4; segments: 3)
                                                   ->  Seq Scan on int4_tbl i4
 Optimizer: Postgres query optimizer
(18 rows)

--
-- More complicated constructs
--
--
-- Multiway full join
--
CREATE TABLE t1 (name TEXT, n INTEGER);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'name' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE t2 (name TEXT, n INTEGER);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'name' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE t3 (name TEXT, n INTEGER);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'name' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO t1 VALUES ( 'bb', 11 );
INSERT INTO t2 VALUES ( 'bb', 12 );
INSERT INTO t2 VALUES ( 'cc', 22 );
INSERT INTO t2 VALUES ( 'ee', 42 );
INSERT INTO t3 VALUES ( 'bb', 13 );
INSERT INTO t3 VALUES ( 'cc', 23 );
INSERT INTO t3 VALUES ( 'dd', 33 );
SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);
 name | n  | n  | n  
------+----+----+----
 bb   | 11 | 12 | 13
 cc   |    | 22 | 23
 dd   |    |    | 33
 ee   |    | 42 |   
(4 rows)

--
-- Test interactions of join syntax and subqueries
--
-- Basic cases (we expect planner to pull up the subquery here)
SELECT * FROM
(SELECT * FROM t2) as s2
INNER JOIN
(SELECT * FROM t3) s3
USING (name);
 name | n  | n  
------+----+----
 bb   | 12 | 13
 cc   | 22 | 23
(2 rows)

SELECT * FROM
(SELECT * FROM t2) as s2
LEFT JOIN
(SELECT * FROM t3) s3
USING (name);
 name | n  | n  
------+----+----
 bb   | 12 | 13
 ee   | 42 |   
 cc   | 22 | 23
(3 rows)

SELECT * FROM
(SELECT * FROM t2) as s2
FULL JOIN
(SELECT * FROM t3) s3
USING (name);
 name | n  | n  
------+----+----
 bb   | 12 | 13
 dd   |    | 33
 ee   | 42 |   
 cc   | 22 | 23
(4 rows)

-- Cases with non-nullable expressions in subquery results;
-- make sure these go to null as expected
SELECT * FROM
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL INNER JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
 name | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------
 bb   |   12 |    2 |   13 |    3
 cc   |   22 |    2 |   23 |    3
(2 rows)

SELECT * FROM
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL LEFT JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
 name | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------
 ee   |   42 |    2 |      |     
 bb   |   12 |    2 |   13 |    3
 cc   |   22 |    2 |   23 |    3
(3 rows)

SELECT * FROM
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL FULL JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
 name | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------
 bb   |   12 |    2 |   13 |    3
 dd   |      |      |   33 |    3
 ee   |   42 |    2 |      |     
 cc   |   22 |    2 |   23 |    3
(4 rows)

SELECT * FROM
(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1
NATURAL INNER JOIN
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL INNER JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
 name | s1_n | s1_1 | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------+------+------
 bb   |   11 |    1 |   12 |    2 |   13 |    3
(1 row)

SELECT * FROM
(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1
NATURAL FULL JOIN
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL FULL JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
 name | s1_n | s1_1 | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------+------+------
 bb   |   11 |    1 |   12 |    2 |   13 |    3
 cc   |      |      |   22 |    2 |   23 |    3
 dd   |      |      |      |      |   33 |    3
 ee   |      |      |   42 |    2 |      |     
(4 rows)

SELECT * FROM
(SELECT name, n as s1_n FROM t1) as s1
NATURAL FULL JOIN
  (SELECT * FROM
    (SELECT name, n as s2_n FROM t2) as s2
    NATURAL FULL JOIN
    (SELECT name, n as s3_n FROM t3) as s3
  ) ss2;
 name | s1_n | s2_n | s3_n 
------+------+------+------
 bb   |   11 |   12 |   13
 dd   |      |      |   33
 ee   |      |   42 |     
 cc   |      |   22 |   23
(4 rows)

SELECT * FROM
(SELECT name, n as s1_n FROM t1) as s1
NATURAL FULL JOIN
  (SELECT * FROM
    (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
    NATURAL FULL JOIN
    (SELECT name, n as s3_n FROM t3) as s3
  ) ss2;
 name | s1_n | s2_n | s2_2 | s3_n 
------+------+------+------+------
 bb   |   11 |   12 |    2 |   13
 dd   |      |      |      |   33
 ee   |      |   42 |    2 |     
 cc   |      |   22 |    2 |   23
(4 rows)

-- Constants as join keys can also be problematic
SELECT * FROM
  (SELECT name, n as s1_n FROM t1) as s1
FULL JOIN
  (SELECT name, 2 as s2_n FROM t2) as s2
ON (s1_n = s2_n);
 name | s1_n | name | s2_n 
------+------+------+------
      |      | ee   |    2
      |      | bb   |    2
      |      | cc   |    2
 bb   |   11 |      |     
(4 rows)

-- Test for propagation of nullability constraints into sub-joins
create temp table x (x1 int, x2 int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'x1' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into x values (1,11);
insert into x values (2,22);
insert into x values (3,null);
insert into x values (4,44);
insert into x values (5,null);
create temp table y (y1 int, y2 int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'y1' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into y values (1,111);
insert into y values (2,222);
insert into y values (3,333);
insert into y values (4,null);
select * from x;
 x1 | x2 
----+----
  2 | 22
  3 |   
  4 | 44
  1 | 11
  5 |   
(5 rows)

select * from y;
 y1 | y2  
----+-----
  2 | 222
  3 | 333
  4 |    
  1 | 111
(4 rows)

select * from x left join y on (x1 = y1 and x2 is not null);
 x1 | x2 | y1 | y2  
----+----+----+-----
  1 | 11 |  1 | 111
  5 |    |    |    
  2 | 22 |  2 | 222
  3 |    |    |    
  4 | 44 |  4 |    
(5 rows)

select * from x left join y on (x1 = y1 and y2 is not null);
 x1 | x2 | y1 | y2  
----+----+----+-----
  2 | 22 |  2 | 222
  3 |    |  3 | 333
  4 | 44 |    |    
  1 | 11 |  1 | 111
  5 |    |    |    
(5 rows)

select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1);
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  1 | 11 |  1 | 111 |   1 |  11
  5 |    |    |     |   5 |    
  2 | 22 |  2 | 222 |   2 |  22
  3 |    |  3 | 333 |   3 |    
  4 | 44 |  4 |     |   4 |  44
(5 rows)

select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1 and x2 is not null);
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  1 | 11 |  1 | 111 |   1 |  11
  2 | 22 |  2 | 222 |   2 |  22
  3 |    |  3 | 333 |     |    
  4 | 44 |  4 |     |   4 |  44
  5 |    |    |     |     |    
(5 rows)

select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1 and y2 is not null);
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  5 |    |    |     |     |    
  2 | 22 |  2 | 222 |   2 |  22
  3 |    |  3 | 333 |   3 |    
  4 | 44 |  4 |     |     |    
  1 | 11 |  1 | 111 |   1 |  11
(5 rows)

select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1 and xx2 is not null);
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  1 | 11 |  1 | 111 |   1 |  11
  5 |    |    |     |     |    
  2 | 22 |  2 | 222 |   2 |  22
  3 |    |  3 | 333 |     |    
  4 | 44 |  4 |     |   4 |  44
(5 rows)

-- these should NOT give the same answers as above
select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1) where (x2 is not null);
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  1 | 11 |  1 | 111 |   1 |  11
  2 | 22 |  2 | 222 |   2 |  22
  4 | 44 |  4 |     |   4 |  44
(3 rows)

select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1) where (y2 is not null);
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  1 | 11 |  1 | 111 |   1 |  11
  2 | 22 |  2 | 222 |   2 |  22
  3 |    |  3 | 333 |   3 |    
(3 rows)

select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1) where (xx2 is not null);
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  2 | 22 |  2 | 222 |   2 |  22
  4 | 44 |  4 |     |   4 |  44
  1 | 11 |  1 | 111 |   1 |  11
(3 rows)

--
-- regression test: check for bug with propagation of implied equality
-- to outside an IN
--
select count(*) from tenk1 a where unique1 in
  (select unique1 from tenk1 b join tenk1 c using (unique1)
   where b.unique2 = 42);
 count 
-------
     1
(1 row)

--
-- regression test: check for failure to generate a plan with multiple
-- degenerate IN clauses
--
select count(*) from tenk1 x where
  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and
  x.unique1 = 0 and
  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);
 count 
-------
     1
(1 row)

-- try that with GEQO too
begin;
set geqo = on;
WARNING:  "geqo": setting is ignored because it is defunct
set geqo_threshold = 2;
WARNING:  "geqo_threshold": setting is ignored because it is defunct
select count(*) from tenk1 x where
  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and
  x.unique1 = 0 and
  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);
 count 
-------
     1
(1 row)

rollback;
--
-- regression test: be sure we cope with proven-dummy append rels
--
explain (costs off)
select aa, bb, unique1, unique1
  from tenk1 right join b on aa = unique1
  where bb < bb and bb is null;
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

select aa, bb, unique1, unique1
  from tenk1 right join b on aa = unique1
  where bb < bb and bb is null;
 aa | bb | unique1 | unique1 
----+----+---------+---------
(0 rows)

--
-- regression test: check handling of empty-FROM subquery underneath outer join
--
explain (costs off)
select * from int8_tbl i1 left join (int8_tbl i2 join
  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2
order by 1, 2;
                            QUERY PLAN                            
------------------------------------------------------------------
 Sort
   Sort Key: int8_tbl.q1, int8_tbl.q2
   ->  Hash Left Join
         Hash Cond: (int8_tbl.q2 = int8_tbl_1.q2)
         ->  Gather Motion 3:1  (slice1; segments: 3)
               ->  Seq Scan on int8_tbl
         ->  Hash
               ->  Hash Join
                     Hash Cond: (int8_tbl_1.q1 = ((123))::bigint)
                     ->  Gather Motion 3:1  (slice2; segments: 3)
                           ->  Seq Scan on int8_tbl int8_tbl_1
                                 Filter: (q1 = 123)
                     ->  Hash
                           ->  Result
                                 Filter: ((123) = 123)
                                 ->  Result
 Optimizer: Pivotal Optimizer (GPORCA)
(17 rows)

select * from int8_tbl i1 left join (int8_tbl i2 join
  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2
order by 1, 2;
        q1        |        q2         | q1  |        q2        |  x  
------------------+-------------------+-----+------------------+-----
              123 |               456 | 123 |              456 | 123
              123 |  4567890123456789 | 123 | 4567890123456789 | 123
 4567890123456789 | -4567890123456789 |     |                  |    
 4567890123456789 |               123 |     |                  |    
 4567890123456789 |  4567890123456789 | 123 | 4567890123456789 | 123
(5 rows)

--
-- regression test: check a case where join_clause_is_movable_into() gives
-- an imprecise result, causing an assertion failure
--
select count(*)
from
  (select t3.tenthous as x1, coalesce(t1.stringu1, t2.stringu1) as x2
   from tenk1 t1
   left join tenk1 t2 on t1.unique1 = t2.unique1
   join tenk1 t3 on t1.unique2 = t3.unique2) ss,
  tenk1 t4,
  tenk1 t5
where t4.thousand = t5.unique1 and ss.x1 = t4.tenthous and ss.x2 = t5.stringu1;
 count 
-------
  1000
(1 row)

--
-- regression test: check a case where we formerly missed including an EC
-- enforcement clause because it was expected to be handled at scan level
--
set enable_hashjoin = false;
set enable_nestloop = true;
explain (costs off)
select a.f1, b.f1, t.thousand, t.tenthous from
  tenk1 t,
  (select sum(f1)+1 as f1 from int4_tbl i4a) a,
  (select sum(f1) as f1 from int4_tbl i4b) b
where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Broadcast Motion 1:3  (slice2; segments: 1)
               ->  Finalize Aggregate
                     ->  Gather Motion 3:1  (slice3; segments: 3)
                           ->  Partial Aggregate
                                 ->  Seq Scan on int4_tbl i4b
         ->  Materialize
               ->  Nested Loop
                     Join Filter: ((sum(i4b.f1)) = ((sum(i4a.f1) + 1)))
                     ->  Materialize
                           ->  Broadcast Motion 1:3  (slice4; segments: 1)
                                 ->  Finalize Aggregate
                                       ->  Gather Motion 3:1  (slice5; segments: 3)
                                             ->  Partial Aggregate
                                                   ->  Seq Scan on int4_tbl i4a
                     ->  Index Only Scan using tenk1_thous_tenthous on tenk1 t
                           Index Cond: ((thousand = (sum(i4b.f1))) AND (tenthous = ((((sum(i4a.f1) + 1)) + (sum(i4b.f1))) + 999)))
 Optimizer: Postgres query optimizer
(19 rows)

select a.f1, b.f1, t.thousand, t.tenthous from
  tenk1 t,
  (select sum(f1)+1 as f1 from int4_tbl i4a) a,
  (select sum(f1) as f1 from int4_tbl i4b) b
where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;
 f1 | f1 | thousand | tenthous 
----+----+----------+----------
(0 rows)

reset enable_hashjoin;
reset enable_nestloop;
--
-- check a case where we formerly got confused by conflicting sort orders
-- in redundant merge join path keys
--
set enable_mergejoin = true;
set enable_hashjoin = false;
explain (costs off)
select * from
  j1_tbl full join
  (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl
  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Full Join
         Merge Cond: ((j1_tbl.i = j2_tbl.i) AND (j1_tbl.i = j2_tbl.k))
         ->  Sort
               Sort Key: j1_tbl.i, j1_tbl.i
               ->  Seq Scan on j1_tbl
         ->  Sort
               Sort Key: j2_tbl.i, j2_tbl.k
               ->  Seq Scan on j2_tbl
 Optimizer: Pivotal Optimizer (GPORCA)
(10 rows)

select * from
  j1_tbl full join
  (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl
  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k; --order none
 i | j |   t   | i | k  
---+---+-------+---+----
   |   |       | 0 |   
 0 |   | zero  |   |   
   |   |       | 1 | -1
 1 | 4 | one   |   |   
   |   |       | 5 | -5
   |   |       | 5 | -5
 5 | 0 | five  |   |   
 6 | 6 | six   |   |   
 2 | 3 | two   | 2 |  2
   |   |       | 2 |  4
   |   |       | 3 | -3
   |   |       |   |  0
   |   |       |   |   
 3 | 2 | three |   |   
 4 | 1 | four  |   |   
 7 | 7 | seven |   |   
 8 | 8 | eight |   |   
   |   | null  |   |   
   | 0 | zero  |   |   
(19 rows)

reset enable_mergejoin;
reset enable_hashjoin;
--
-- a different check for handling of redundant sort keys in merge joins
--
set enable_mergejoin = true;
set enable_hashjoin = false;
explain (costs off)
select count(*) from
  (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x
  left join
  (select * from tenk1 y order by y.unique2) y
  on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Partial Aggregate
               ->  Hash Left Join
                     Hash Cond: ((tenk1.thousand = tenk1_1.unique2) AND (tenk1.twothousand = tenk1_1.hundred) AND (tenk1.fivethous = tenk1_1.unique2))
                     ->  Redistribute Motion 3:3  (slice2; segments: 3)
                           Hash Key: tenk1.thousand, tenk1.twothousand, tenk1.thousand
                           ->  Seq Scan on tenk1
                     ->  Hash
                           ->  Redistribute Motion 3:3  (slice3; segments: 3)
                                 Hash Key: tenk1_1.unique2, tenk1_1.hundred, tenk1_1.unique2
                                 ->  Seq Scan on tenk1 tenk1_1
 Optimizer: Pivotal Optimizer (GPORCA)
(13 rows)

select count(*) from
  (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x
  left join
  (select * from tenk1 y order by y.unique2) y
  on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;
 count 
-------
 10000
(1 row)

reset enable_mergejoin;
reset enable_hashjoin;
--
-- Clean up
--
DROP TABLE t1;
DROP TABLE t2;
DROP TABLE t3;
DROP TABLE J1_TBL;
DROP TABLE J2_TBL;
-- Both DELETE and UPDATE allow the specification of additional tables
-- to "join" against to determine which rows should be modified.
CREATE TEMP TABLE t1 (a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TEMP TABLE t2 (a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TEMP TABLE t3 (x int, y int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'x' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TEMP TABLE t4 (x int, y int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'x' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO t1 VALUES (5, 10);
INSERT INTO t1 VALUES (15, 20);
INSERT INTO t1 VALUES (100, 100);
INSERT INTO t1 VALUES (200, 1000);
INSERT INTO t2 VALUES (200, 2000);
INSERT INTO t3 VALUES (5, 20);
INSERT INTO t3 VALUES (6, 7);
INSERT INTO t3 VALUES (7, 8);
INSERT INTO t3 VALUES (500, 100);
INSERT INTO t4 SELECT * FROM t3;
DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;
SELECT * FROM t3;
  x  |  y  
-----+-----
   7 |   8
 500 | 100
   6 |   7
(3 rows)

DELETE FROM t4 USING t1 JOIN t2 USING (a) WHERE t4.x > t1.a;
SELECT * FROM t4;
 x | y  
---+----
 7 |  8
 5 | 20
 6 |  7
(3 rows)

DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;
SELECT * FROM t3;
 x | y 
---+---
(0 rows)

-- Test join against inheritance tree
create temp table t2a () inherits (t2);
NOTICE:  table has parent, setting distribution columns to match parent table
insert into t2a values (200, 2001);
select * from t1 left join t2 on (t1.a = t2.a);
  a  |  b   |  a  |  b   
-----+------+-----+------
  15 |   20 |     |     
 200 | 1000 | 200 | 2000
 200 | 1000 | 200 | 2001
 100 |  100 |     |     
   5 |   10 |     |     
(5 rows)

-- Test matching of column name with wrong alias
select t1.x from t1 join t3 on (t1.a = t3.x);
ERROR:  column t1.x does not exist
LINE 1: select t1.x from t1 join t3 on (t1.a = t3.x);
               ^
HINT:  Perhaps you meant to reference the column "t3.x".
--
-- regression test for 8.1 merge right join bug
--
CREATE TEMP TABLE tt1 ( tt1_id int4, joincol int4 );
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'tt1_id' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO tt1 VALUES (1, 11);
INSERT INTO tt1 VALUES (2, NULL);
CREATE TEMP TABLE tt2 ( tt2_id int4, joincol int4 );
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'tt2_id' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO tt2 VALUES (21, 11);
INSERT INTO tt2 VALUES (22, 11);
set enable_hashjoin to off;
set enable_nestloop to off;
-- these should give the same results
select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;
 tt1_id | joincol | tt2_id | joincol 
--------+---------+--------+---------
      2 |         |        |        
      1 |      11 |     21 |      11
      1 |      11 |     22 |      11
(3 rows)

select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;
 tt1_id | joincol | tt2_id | joincol 
--------+---------+--------+---------
      2 |         |        |        
      1 |      11 |     21 |      11
      1 |      11 |     22 |      11
(3 rows)

reset enable_hashjoin;
reset enable_nestloop;
--
-- regression test for bug #13908 (hash join with skew tuples & nbatch increase)
--
set work_mem to '64kB';
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
set enable_mergejoin to off;
set enable_memoize to off;
explain (costs off)
select count(*) from tenk1 a, tenk1 b
  where a.hundred = b.thousand and (b.fivethous % 10) < 10;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Finalize Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Partial Aggregate
               ->  Hash Join
                     Hash Cond: (b.thousand = a.hundred)
                     ->  Broadcast Motion 3:3  (slice2; segments: 3)
                           ->  Seq Scan on tenk1 b
                                 Filter: ((fivethous % 10) < 10)
                     ->  Hash
                           ->  Seq Scan on tenk1 a
 Optimizer: Postgres query optimizer
(11 rows)

select count(*) from tenk1 a, tenk1 b
  where a.hundred = b.thousand and (b.fivethous % 10) < 10;
 count  
--------
 100000
(1 row)

reset work_mem;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
reset enable_mergejoin;
reset enable_memoize;
--
-- regression test for 8.2 bug with improper re-ordering of left joins
--
create temp table tt3(f1 int, f2 text);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'f1' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into tt3 select x, repeat('xyzzy', 100) from generate_series(1,10000) x;
create index tt3i on tt3(f1);
analyze tt3;
create temp table tt4(f1 int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'f1' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into tt4 values (0),(1),(9999);
analyze tt4;
SELECT a.f1
FROM tt4 a
LEFT JOIN (
        SELECT b.f1
        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)
        WHERE c.f1 IS NULL
) AS d ON (a.f1 = d.f1)
WHERE d.f1 IS NULL;
  f1  
------
 9999
    0
    1
(3 rows)

--
-- regression test for proper handling of outer joins within antijoins
--
create temp table tt4x(c1 int, c2 int, c3 int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'c1' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
explain (costs off)
select * from tt4x t1
where not exists (
  select 1 from tt4x t2
    left join tt4x t3 on t2.c3 = t3.c1
    left join ( select t5.c1 as c1
                from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1
              ) a1 on t3.c2 = a1.c1
  where t1.c1 = t2.c2
);
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Result
         Filter: (COALESCE((count()), '0'::bigint) = '0'::bigint)
         ->  Hash Left Join
               Hash Cond: (tt4x.c1 = tt4x_1.c2)
               ->  Seq Scan on tt4x
               ->  Hash
                     ->  Finalize GroupAggregate
                           Group Key: tt4x_1.c2
                           ->  Sort
                                 Sort Key: tt4x_1.c2
                                 ->  Redistribute Motion 3:3  (slice2; segments: 3)
                                       Hash Key: tt4x_1.c2
                                       ->  Partial GroupAggregate
                                             Group Key: tt4x_1.c2
                                             ->  Sort
                                                   Sort Key: tt4x_1.c2
                                                   ->  Hash Left Join
                                                         Hash Cond: (tt4x_2.c2 = tt4x_4.c1)
                                                         ->  Hash Left Join
                                                               Hash Cond: (tt4x_1.c3 = tt4x_2.c1)
                                                               ->  Redistribute Motion 3:3  (slice3; segments: 3)
                                                                     Hash Key: tt4x_1.c3
                                                                     ->  Seq Scan on tt4x tt4x_1
                                                               ->  Hash
                                                                     ->  Seq Scan on tt4x tt4x_2
                                                         ->  Hash
                                                               ->  Broadcast Motion 3:3  (slice4; segments: 3)
                                                                     ->  Hash Left Join
                                                                           Hash Cond: (tt4x_3.c2 = tt4x_4.c1)
                                                                           ->  Redistribute Motion 3:3  (slice5; segments: 3)
                                                                                 Hash Key: tt4x_3.c2
                                                                                 ->  Seq Scan on tt4x tt4x_3
                                                                           ->  Hash
                                                                                 ->  Seq Scan on tt4x tt4x_4
 Optimizer: Pivotal Optimizer (GPORCA)
(36 rows)

--
-- regression test for problems of the sort depicted in bug #3494
--
create temp table tt5(f1 int, f2 int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'f1' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
create temp table tt6(f1 int, f2 int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'f1' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into tt5 values(1, 10);
insert into tt5 values(1, 11);
insert into tt6 values(1, 9);
insert into tt6 values(1, 2);
insert into tt6 values(2, 9);
select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2;
 f1 | f2 | f1 | f2 
----+----+----+----
  1 | 10 |  1 |  9
(1 row)

--
-- regression test for problems of the sort depicted in bug #3588
--
create temp table xx (pkxx int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'pkxx' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
create temp table yy (pkyy int, pkxx int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'pkyy' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into xx values (1);
insert into xx values (2);
insert into xx values (3);
insert into yy values (101, 1);
insert into yy values (201, 2);
insert into yy values (301, NULL);
select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,
       xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx
from yy
     left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy
     left join xx xxa on yya.pkxx = xxa.pkxx
     left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx;
 yy_pkyy | yy_pkxx | yya_pkyy | xxa_pkxx | xxb_pkxx 
---------+---------+----------+----------+----------
     201 |       2 |          |          |        1
     101 |       1 |      101 |        1 |        1
     301 |         |          |          |        1
(3 rows)

--
-- regression test for improper pushing of constants across outer-join clauses
-- (as seen in early 8.2.x releases)
--
create temp table zt1 (f1 int primary key);
create temp table zt2 (f2 int primary key);
create temp table zt3 (f3 int primary key);
insert into zt1 values(53);
insert into zt2 values(53);
select * from
  zt2 left join zt3 on (f2 = f3)
      left join zt1 on (f3 = f1)
where f2 = 53;
 f2 | f3 | f1 
----+----+----
 53 |    |   
(1 row)

create temp view zv1 as select *,'dummy'::text AS junk from zt1;
select * from
  zt2 left join zt3 on (f2 = f3)
      left join zv1 on (f3 = f1)
where f2 = 53;
 f2 | f3 | f1 | junk 
----+----+----+------
 53 |    |    | 
(1 row)

--
-- regression test for improper extraction of OR indexqual conditions
-- (as seen in early 8.3.x releases)
--
select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred
from tenk1 a left join tenk1 b on a.unique2 = b.tenthous
where a.unique1 = 42 and
      ((b.unique2 is null and a.ten = 2) or b.hundred = 3);
 unique2 | ten | tenthous | unique2 | hundred 
---------+-----+----------+---------+---------
(0 rows)

--
-- test proper positioning of one-time quals in EXISTS (8.4devel bug)
--
prepare foo(bool) as
  select count(*) from tenk1 a left join tenk1 b
    on (a.unique2 = b.unique1 and exists
        (select 1 from tenk1 c where c.thousand = b.unique2 and $1));
execute foo(true);
 count 
-------
 10000
(1 row)

execute foo(false);
 count 
-------
 10000
(1 row)

--
-- test for sane behavior with noncanonical merge clauses, per bug #4926
--
begin;
set enable_mergejoin = 1;
set enable_hashjoin = 0;
set enable_nestloop = 0;
create temp table a (i integer);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
create temp table b (x integer, y integer);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'x' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
select * from a left join b on i = x and i = y and x = i;
 i | x | y 
---+---+---
(0 rows)

rollback;
--
-- test handling of merge clauses using record_ops
--
begin;
create type mycomptype as (id int, v bigint);
create temp table tidv (idv mycomptype);
create index on tidv (idv);
explain (costs off)
select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (a.idv = b.idv)
         ->  Seq Scan on tidv a
         ->  Hash
               ->  Seq Scan on tidv b
 Optimizer: Postgres query optimizer
(7 rows)

set enable_mergejoin = 0;
set enable_hashjoin = 0;
set enable_nestloop = 1;
explain (costs off)
select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;
                        QUERY PLAN                        
----------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Seq Scan on tidv a
         ->  Index Only Scan using tidv_idv_idx on tidv b
               Index Cond: (idv = a.idv)
 Optimizer: Postgres query optimizer
(6 rows)

rollback;
--
-- test NULL behavior of whole-row Vars, per bug #5025
--
select t1.q2, count(t2.*)
from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     0
               123 |     2
               456 |     0
  4567890123456789 |     6
(4 rows)

select t1.q2, count(t2.*)
from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     0
               123 |     2
               456 |     0
  4567890123456789 |     6
(4 rows)

select t1.q2, count(t2.*)
from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     0
               123 |     2
               456 |     0
  4567890123456789 |     6
(4 rows)

select t1.q2, count(t2.*)
from int8_tbl t1 left join
  (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2
  on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     0
               123 |     2
               456 |     0
  4567890123456789 |     6
(4 rows)

--
-- test incorrect failure to NULL pulled-up subexpressions
--
begin;
create temp table a (
     code char not null,
     constraint a_pk primary key (code)
);
create temp table b (
     a char not null,
     num integer not null,
     constraint b_pk primary key (a, num)
);
create temp table c (
     name char not null,
     a char,
     constraint c_pk primary key (name)
);
insert into a (code) values ('p');
insert into a (code) values ('q');
insert into b (a, num) values ('p', 1);
insert into b (a, num) values ('p', 2);
insert into c (name, a) values ('A', 'p');
insert into c (name, a) values ('B', 'q');
insert into c (name, a) values ('C', null);
select c.name, ss.code, ss.b_cnt, ss.const
from c left join
  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const
   from a left join
     (select count(1) as cnt, b.a from b group by b.a) as b_grp
     on a.code = b_grp.a
  ) as ss
  on (c.a = ss.code)
order by c.name;
 name | code | b_cnt | const 
------+------+-------+-------
 A    | p    |     2 |    -1
 B    | q    |     0 |    -1
 C    |      |       |      
(3 rows)

rollback;
--
-- test incorrect handling of placeholders that only appear in targetlists,
-- per bug #6154
--
SELECT * FROM
( SELECT 1 as key1 ) sub1
LEFT JOIN
( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM
    ( SELECT 1 as key3 ) sub3
    LEFT JOIN
    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM
        ( SELECT 1 as key5 ) sub5
        LEFT JOIN
        ( SELECT 2 as key6, 42 as value1 ) sub6
        ON sub5.key5 = sub6.key6
    ) sub4
    ON sub4.key5 = sub3.key3
) sub2
ON sub1.key1 = sub2.key3;
 key1 | key3 | value2 | value3 
------+------+--------+--------
    1 |    1 |      1 |      1
(1 row)

-- test the path using join aliases, too
SELECT * FROM
( SELECT 1 as key1 ) sub1
LEFT JOIN
( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM
    ( SELECT 1 as key3 ) sub3
    LEFT JOIN
    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM
        ( SELECT 1 as key5 ) sub5
        LEFT JOIN
        ( SELECT 2 as key6, 42 as value1 ) sub6
        ON sub5.key5 = sub6.key6
    ) sub4
    ON sub4.key5 = sub3.key3
) sub2
ON sub1.key1 = sub2.key3;
 key1 | key3 | value2 | value3 
------+------+--------+--------
    1 |    1 |      1 |      1
(1 row)

--
-- test case where a PlaceHolderVar is used as a nestloop parameter
--
EXPLAIN (COSTS OFF)
SELECT qq, unique1
  FROM
  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1
  FULL OUTER JOIN
  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2
  USING (qq)
  INNER JOIN tenk1 c ON qq = unique2;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (c.unique2 = COALESCE((COALESCE(a.q1, '0'::bigint)), (COALESCE(b.q2, '-1'::bigint))))
         ->  Seq Scan on tenk1 c
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Full Join
                           Hash Cond: ((COALESCE(a.q1, '0'::bigint)) = (COALESCE(b.q2, '-1'::bigint)))
                           ->  Redistribute Motion 3:3  (slice3; segments: 3)
                                 Hash Key: (COALESCE(a.q1, '0'::bigint))
                                 ->  Seq Scan on int8_tbl a
                           ->  Hash
                                 ->  Redistribute Motion 3:3  (slice4; segments: 3)
                                       Hash Key: (COALESCE(b.q2, '-1'::bigint))
                                       ->  Seq Scan on int8_tbl b
 Optimizer: Postgres query optimizer
(16 rows)

SELECT qq, unique1
  FROM
  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1
  FULL OUTER JOIN
  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2
  USING (qq)
  INNER JOIN tenk1 c ON qq = unique2;
 qq  | unique1 
-----+---------
 456 |    7318
 123 |    4596
 123 |    4596
(3 rows)

--
-- nested nestloops can require nested PlaceHolderVars
--
create temp table nt1 (
  id int primary key,
  a1 boolean,
  a2 boolean
);
create temp table nt2 (
  id int primary key,
  nt1_id int,
  b1 boolean,
  b2 boolean,
  foreign key (nt1_id) references nt1(id)
);
WARNING:  referential integrity (FOREIGN KEY) constraints are not supported in Cloudberry Database, will not be enforced
create temp table nt3 (
  id int primary key,
  nt2_id int,
  c1 boolean,
  foreign key (nt2_id) references nt2(id)
);
WARNING:  referential integrity (FOREIGN KEY) constraints are not supported in Cloudberry Database, will not be enforced
insert into nt1 values (1,true,true);
ANALYZE nt1;
insert into nt1 values (2,true,false);
insert into nt1 values (3,false,false);
insert into nt2 values (1,1,true,true);
ANALYZE nt2;
insert into nt2 values (2,2,true,false);
insert into nt2 values (3,3,false,false);
insert into nt3 values (1,1,true);
ANALYZE nt3;
insert into nt3 values (2,2,false);
insert into nt3 values (3,3,true);
explain (costs off)
select nt3.id
from nt3 as nt3
  left join
    (select nt2.*, (nt2.b1 and ss1.a3) AS b3
     from nt2 as nt2
       left join
         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1
         on ss1.id = nt2.nt1_id
    ) as ss2
    on ss2.id = nt3.nt2_id
where nt3.id = 1 and ss2.b3;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (nt2.id = nt3.nt2_id)
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: 1
               ->  Hash Join
                     Hash Cond: (nt2.nt1_id = nt1.id)
                     Join Filter: (nt2.b1 AND ((nt1.id IS NOT NULL)))
                     ->  Redistribute Motion 3:3  (slice3; segments: 3)
                           Hash Key: nt2.nt1_id
                           ->  Seq Scan on nt2
                     ->  Hash
                           ->  Seq Scan on nt1
         ->  Hash
               ->  Seq Scan on nt3
                     Filter: (id = 1)
 Optimizer: Postgres query optimizer
(17 rows)

select nt3.id
from nt3 as nt3
  left join
    (select nt2.*, (nt2.b1 and ss1.a3) AS b3
     from nt2 as nt2
       left join
         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1
         on ss1.id = nt2.nt1_id
    ) as ss2
    on ss2.id = nt3.nt2_id
where nt3.id = 1 and ss2.b3;
 id 
----
  1
(1 row)

--
-- test case where a PlaceHolderVar is propagated into a subquery
--
explain (costs off)
select * from
  int8_tbl t1 left join
  (select q1 as x, 42 as y from int8_tbl t2) ss
  on t1.q2 = ss.x
where
  1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)
order by 1,2;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: int8_tbl.q1, int8_tbl.q2
   ->  Sort
         Sort Key: int8_tbl.q1, int8_tbl.q2
         ->  Result
               Filter: (SubPlan 1)
               ->  Hash Left Join
                     Hash Cond: (int8_tbl.q2 = int8_tbl_1.q1)
                     ->  Redistribute Motion 3:3  (slice2; segments: 3)
                           Hash Key: int8_tbl.q2
                           ->  Seq Scan on int8_tbl
                     ->  Hash
                           ->  Seq Scan on int8_tbl int8_tbl_1
               SubPlan 1
                 ->  Result
                       Filter: (1 = (1))
                       ->  Result
                             ->  Limit
                                   ->  Result
                                         One-Time Filter: (NOT ((42) IS NULL))
                                         ->  Materialize
                                               ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                                     ->  Seq Scan on int8_tbl int8_tbl_2
 Optimizer: Pivotal Optimizer (GPORCA)
(24 rows)

--
-- test case where a PlaceHolderVar is propagated into a subquery
--
select * from
  int8_tbl t1 left join
  (select q1 as x, 42 as y from int8_tbl t2) ss
  on t1.q2 = ss.x
where
  1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)
order by 1,2;
        q1        |        q2        |        x         | y  
------------------+------------------+------------------+----
              123 | 4567890123456789 | 4567890123456789 | 42
              123 | 4567890123456789 | 4567890123456789 | 42
              123 | 4567890123456789 | 4567890123456789 | 42
 4567890123456789 |              123 |              123 | 42
 4567890123456789 |              123 |              123 | 42
 4567890123456789 | 4567890123456789 | 4567890123456789 | 42
 4567890123456789 | 4567890123456789 | 4567890123456789 | 42
 4567890123456789 | 4567890123456789 | 4567890123456789 | 42
(8 rows)

--
-- variant where a PlaceHolderVar is needed at a join, but not above the join
--
explain (costs off)
select * from
  int4_tbl as i41,
  lateral
    (select 1 as x from
      (select i41.f1 as lat,
              i42.f1 as loc from
         int8_tbl as i81, int4_tbl as i42) as ss1
      right join int4_tbl as i43 on (i43.f1 > 1)
      where ss1.loc = ss1.lat) as ss2
where i41.f1 > 0;
ERROR:  could not devise a query plan for the given query (pathnode.c:277)
--start_ignore
--GPDB_14_MERGE_FIXME: We need to make plan work. One idea is generate a gather
--motion for relations. Even it is not efficient, but better than error out here.
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop
   ->  Nested Loop
         ->  Seq Scan on int4_tbl i41
               Filter: (f1 > 0)
         ->  Nested Loop
               Join Filter: (i41.f1 = i42.f1)
               ->  Seq Scan on int8_tbl i81
               ->  Materialize
                     ->  Seq Scan on int4_tbl i42
   ->  Materialize
         ->  Seq Scan on int4_tbl i43
               Filter: (f1 > 1)
(12 rows)
--end_ignore
select * from
  int4_tbl as i41,
  lateral
    (select 1 as x from
      (select i41.f1 as lat,
              i42.f1 as loc from
         int8_tbl as i81, int4_tbl as i42) as ss1
      right join int4_tbl as i43 on (i43.f1 > 1)
      where ss1.loc = ss1.lat) as ss2
where i41.f1 > 0;
ERROR:  could not devise a query plan for the given query (pathnode.c:277)
--start_ignore
--GPDB_14_MERGE_FIXME: We need to make plan work. One idea is generate a gather
--motion for relations. Even it is not efficient, but better than error out here.
     f1     | x 
------------+---
     123456 | 1
     123456 | 1
     123456 | 1
     123456 | 1
     123456 | 1
     123456 | 1
     123456 | 1
     123456 | 1
     123456 | 1
     123456 | 1
 2147483647 | 1
 2147483647 | 1
 2147483647 | 1
 2147483647 | 1
 2147483647 | 1
 2147483647 | 1
 2147483647 | 1
 2147483647 | 1
 2147483647 | 1
 2147483647 | 1
(20 rows)
--end_ignore
--
-- test the corner cases FULL JOIN ON TRUE and FULL JOIN ON FALSE
--
select * from int4_tbl a full join int4_tbl b on true order by 1, 2;
     f1      |     f1      
-------------+-------------
 -2147483647 | -2147483647
 -2147483647 |     -123456
 -2147483647 |           0
 -2147483647 |      123456
 -2147483647 |  2147483647
     -123456 | -2147483647
     -123456 |     -123456
     -123456 |           0
     -123456 |      123456
     -123456 |  2147483647
           0 | -2147483647
           0 |     -123456
           0 |           0
           0 |      123456
           0 |  2147483647
      123456 | -2147483647
      123456 |     -123456
      123456 |           0
      123456 |      123456
      123456 |  2147483647
  2147483647 | -2147483647
  2147483647 |     -123456
  2147483647 |           0
  2147483647 |      123456
  2147483647 |  2147483647
(25 rows)

select * from int4_tbl a full join int4_tbl b on false; --order none
     f1      |     f1      
-------------+-------------
             |      123456
             |     -123456
             |           0
             |  2147483647
             | -2147483647
      123456 |            
     -123456 |            
           0 |            
  2147483647 |            
 -2147483647 |            
(10 rows)

--
-- test for ability to use a cartesian join when necessary
--
create temp table q1 as select 1 as q1;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause. Creating a NULL policy entry.
create temp table q2 as select 0 as q2;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause. Creating a NULL policy entry.
analyze q1;
analyze q2;
explain (costs off)
select * from
  tenk1 join int4_tbl on f1 = twothousand,
  q1, q2
where q1 = thousand or q2 = thousand;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (tenk1.twothousand = int4_tbl.f1)
         ->  Nested Loop
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on q2
               ->  Materialize
                     ->  Nested Loop
                           ->  Materialize
                                 ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                       ->  Seq Scan on q1
                           ->  Bitmap Heap Scan on tenk1
                                 Recheck Cond: ((q1.q1 = thousand) OR (q2.q2 = thousand))
                                 ->  BitmapOr
                                       ->  Bitmap Index Scan on tenk1_thous_tenthous
                                             Index Cond: (thousand = q1.q1)
                                       ->  Bitmap Index Scan on tenk1_thous_tenthous
                                             Index Cond: (thousand = q2.q2)
         ->  Hash
               ->  Broadcast Motion 3:3  (slice4; segments: 3)
                     ->  Seq Scan on int4_tbl
 Optimizer: Postgres query optimizer
(22 rows)

explain (costs off)
select * from
  tenk1 join int4_tbl on f1 = twothousand,
  q1, q2
where thousand = (q1 + q2);
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (tenk1.thousand = (q1.q1 + q2.q2))
         ->  Hash Join
               Hash Cond: (tenk1.twothousand = int4_tbl.f1)
               ->  Seq Scan on tenk1
               ->  Hash
                     ->  Broadcast Motion 3:3  (slice2; segments: 3)
                           ->  Seq Scan on int4_tbl
         ->  Hash
               ->  Broadcast Motion 3:3  (slice3; segments: 3)
                     ->  Nested Loop
                           ->  Seq Scan on q1
                           ->  Materialize
                                 ->  Broadcast Motion 3:3  (slice4; segments: 3)
                                       ->  Seq Scan on q2
 Optimizer: Postgres query optimizer
(17 rows)

--
-- test ability to generate a suitable plan for a star-schema query
--
set enable_nestloop to true;
explain (costs off)
select * from
  tenk1, int8_tbl a, int8_tbl b
where thousand = a.q1 and tenthous = b.q1 and a.q2 = 1 and b.q2 = 2;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Seq Scan on int8_tbl b
                     Filter: (q2 = 2)
         ->  Materialize
               ->  Nested Loop
                     ->  Materialize
                           ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                 ->  Seq Scan on int8_tbl a
                                       Filter: (q2 = 1)
                     ->  Index Scan using tenk1_thous_tenthous on tenk1
                           Index Cond: ((thousand = a.q1) AND (tenthous = b.q1))
 Optimizer: Postgres query optimizer
(14 rows)

reset enable_nestloop;
--
-- test a corner case in which we shouldn't apply the star-schema optimization
--
-- start_ignore
-- GPDB_94_MERGE_FIXME: PG plan & GP plan are different even we enable nestloop
-- join. Need more time to dig into the difference. Ignore at this moment.
explain (costs off)
select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from
  tenk1 t1
  inner join int4_tbl i1
    left join (select v1.x2, v2.y1, 11 AS d1
               from (select 1,0 from onerow) v1(x1,x2)
               left join (select 3,1 from onerow) v2(y1,y2)
               on v1.x1 = v2.y2) subq1
    on (i1.f1 = subq1.x2)
  on (t1.unique2 = subq1.d1)
  left join tenk1 t2
  on (subq1.y1 = t2.unique1)
where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (tenk1.unique1 = (3))
         Join Filter: (tenk1_1.stringu1 > tenk1.stringu2)
         ->  Seq Scan on tenk1
         ->  Hash
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: (3)
                     ->  Hash Join
                           Hash Cond: ((0) = int4_tbl.f1)
                           ->  Hash Join
                                 Hash Cond: (tenk1_1.unique2 = (11))
                                 ->  Index Scan using tenk1_unique2 on tenk1 tenk1_1
                                       Index Cond: ((unique2 < 42) AND (unique2 = 11))
                                 ->  Hash
                                       ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                             ->  Result
                                                   Filter: (((11) < 42) AND ((11) = 11))
                                                   ->  Hash Left Join
                                                         Hash Cond: ((1) = (1))
                                                         ->  Result
                                                               Filter: ((0) = 0)
                                                               ->  Seq Scan on onerow
                                                         ->  Hash
                                                               ->  Broadcast Motion 3:3  (slice4; segments: 3)
                                                                     ->  Result
                                                                           Filter: ((1) = 1)
                                                                           ->  Seq Scan on onerow onerow_1
                           ->  Hash
                                 ->  Broadcast Motion 3:3  (slice5; segments: 3)
                                       ->  Seq Scan on int4_tbl
                                             Filter: (f1 = 0)
 Optimizer: Pivotal Optimizer (GPORCA)
(33 rows)

--end_ignore
select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from
  tenk1 t1
  inner join int4_tbl i1
    left join (select v1.x2, v2.y1, 11 AS d1
               from (select 1,0 from onerow) v1(x1,x2)
               left join (select 3,1 from onerow) v2(y1,y2)
               on v1.x1 = v2.y2) subq1
    on (i1.f1 = subq1.x2)
  on (t1.unique2 = subq1.d1)
  left join tenk1 t2
  on (subq1.y1 = t2.unique1)
where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
 unique2 | stringu1 | unique1 | stringu2 
---------+----------+---------+----------
      11 | WFAAAA   |       3 | LKIAAA
(1 row)

-- variant that isn't quite a star-schema case
select ss1.d1 from
  tenk1 as t1
  inner join tenk1 as t2
  on t1.tenthous = t2.ten
  inner join
    int8_tbl as i8
    left join int4_tbl as i4
      inner join (select 64::information_schema.cardinal_number as d1
                  from tenk1 t3,
                       lateral (select abs(t3.unique1) + random()) ss0(x)
                  where t3.fivethous < 0) as ss1
      on i4.f1 = ss1.d1
    on i8.q1 = i4.f1
  on t1.tenthous = ss1.d1
where t1.unique1 < i4.f1;
 d1 
----
(0 rows)

-- this variant is foldable by the remove-useless-RESULT-RTEs code
explain (costs off)
select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from
  tenk1 t1
  inner join int4_tbl i1
    left join (select v1.x2, v2.y1, 11 AS d1
               from (values(1,0)) v1(x1,x2)
               left join (values(3,1)) v2(y1,y2)
               on v1.x1 = v2.y2) subq1
    on (i1.f1 = subq1.x2)
  on (t1.unique2 = subq1.d1)
  left join tenk1 t2
  on (subq1.y1 = t2.unique1)
where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.unique1 = (3))
         Join Filter: (t1.stringu1 > t2.stringu2)
         ->  Seq Scan on tenk1 t2
         ->  Hash
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: (3)
                     ->  Hash Join
                           Hash Cond: (t1.unique2 = (11))
                           ->  Index Scan using tenk1_unique2 on tenk1 t1
                                 Index Cond: (unique2 < 42)
                           ->  Hash
                                 ->  Broadcast Motion 1:3  (slice3; segments: 1)
                                       ->  Seq Scan on int4_tbl i1
                                             Filter: ((11 < 42) AND (f1 = 0))
 Optimizer: Postgres query optimizer
(17 rows)

select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from
  tenk1 t1
  inner join int4_tbl i1
    left join (select v1.x2, v2.y1, 11 AS d1
               from (values(1,0)) v1(x1,x2)
               left join (values(3,1)) v2(y1,y2)
               on v1.x1 = v2.y2) subq1
    on (i1.f1 = subq1.x2)
  on (t1.unique2 = subq1.d1)
  left join tenk1 t2
  on (subq1.y1 = t2.unique1)
where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
 unique2 | stringu1 | unique1 | stringu2 
---------+----------+---------+----------
      11 | WFAAAA   |       3 | LKIAAA
(1 row)

-- Here's a variant that we can't fold too aggressively, though,
-- or we end up with noplace to evaluate the lateral PHV
explain (verbose, costs off)
select * from
  (select 1 as x) ss1 left join (select 2 as y) ss2 on (true),
  lateral (select ss2.y as z limit 1) ss3;
             QUERY PLAN              
-------------------------------------
 Nested Loop
   Output: 1, (2), ((2))
   ->  Result
         Output: 2
   ->  Materialize
         Output: ((2))
         ->  Limit
               Output: ((2))
               ->  Result
                     Output: (2)
 Settings: optimizer = 'on'
 Optimizer: Postgres query optimizer
(12 rows)

select * from
  (select 1 as x) ss1 left join (select 2 as y) ss2 on (true),
  lateral (select ss2.y as z limit 1) ss3;
 x | y | z 
---+---+---
 1 | 2 | 2
(1 row)

-- Test proper handling of appendrel PHVs during useless-RTE removal
explain (costs off)
select * from
  (select 0 as z) as t1
  left join
  (select true as a) as t2
  on true,
  lateral (select true as b
           union all
           select a as b) as t3
where b;
              QUERY PLAN               
---------------------------------------
 Nested Loop
   ->  Result
   ->  Append
         ->  Result
         ->  Result
               One-Time Filter: (true)
(6 rows)

select * from
  (select 0 as z) as t1
  left join
  (select true as a) as t2
  on true,
  lateral (select true as b
           union all
           select a as b) as t3
where b;
 z | a | b 
---+---+---
 0 | t | t
 0 | t | t
(2 rows)

--
-- test inlining of immutable functions
--
create function f_immutable_int4(i integer) returns integer as
$$ begin return i; end; $$ language plpgsql immutable;
-- enable nestloop here
set enable_nestloop=on;
-- check optimization of function scan with join
explain (costs off)
select unique1 from tenk1, (select * from f_immutable_int4(1) x) x
where x = unique1;
                     QUERY PLAN                     
----------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Only Scan using tenk1_unique1 on tenk1
         Index Cond: (unique1 = 1)
 Optimizer: Postgres query optimizer
(4 rows)

explain (verbose, costs off)
select unique1, x.*
from tenk1, (select *, random() from f_immutable_int4(1) x) x
where x = unique1;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: tenk1.unique1, (1), (random())
   ->  Nested Loop
         Output: tenk1.unique1, (1), (random())
         ->  Redistribute Motion 1:3  (slice2; segments: 1)
               Output: (1), (random())
               Hash Key: (1)
               ->  Result
                     Output: 1, random()
         ->  Index Only Scan using tenk1_unique1 on public.tenk1
               Output: tenk1.unique1
               Index Cond: (tenk1.unique1 = (1))
 Settings: enable_nestloop = 'on'
 Optimizer: Postgres query optimizer
(14 rows)

explain (costs off)
select unique1 from tenk1, f_immutable_int4(1) x where x = unique1;
                     QUERY PLAN                     
----------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Only Scan using tenk1_unique1 on tenk1
         Index Cond: (unique1 = 1)
 Optimizer: Postgres query optimizer
(4 rows)

explain (costs off)
select unique1 from tenk1, lateral f_immutable_int4(1) x where x = unique1;
                     QUERY PLAN                     
----------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Only Scan using tenk1_unique1 on tenk1
         Index Cond: (unique1 = 1)
 Optimizer: Postgres query optimizer
(4 rows)

explain (costs off)
select unique1 from tenk1, lateral f_immutable_int4(1) x where x in (select 17);
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(3 rows)

explain (costs off)
select unique1, x from tenk1 join f_immutable_int4(1) x on unique1 = x;
                     QUERY PLAN                     
----------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Only Scan using tenk1_unique1 on tenk1
         Index Cond: (unique1 = 1)
 Optimizer: Postgres query optimizer
(4 rows)

explain (costs off)
select unique1, x from tenk1 left join f_immutable_int4(1) x on unique1 = x;
                   QUERY PLAN                   
------------------------------------------------
 Hash Left Join
   Hash Cond: (unique1 = (1))
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Seq Scan on tenk1
   ->  Hash
         ->  Result
 Optimizer: Pivotal Optimizer (GPORCA)
(7 rows)

explain (costs off)
select unique1, x from tenk1 right join f_immutable_int4(1) x on unique1 = x;
                        QUERY PLAN                        
----------------------------------------------------------
 Hash Right Join
   Hash Cond: (unique1 = (1))
   ->  Gather Motion 1:1  (slice1; segments: 1)
         ->  Index Only Scan using tenk1_unique1 on tenk1
               Index Cond: (unique1 = 1)
   ->  Hash
         ->  Result
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

explain (costs off)
select unique1, x from tenk1 full join f_immutable_int4(1) x on unique1 = x;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Full Join
         Merge Cond: (unique1 = (1))
         ->  Sort
               Sort Key: unique1
               ->  Seq Scan on tenk1
         ->  Sort
               Sort Key: (1)
               ->  Result
                     ->  Result
 Optimizer: Pivotal Optimizer (GPORCA)
(11 rows)

-- check that pullup of a const function allows further const-folding
explain (costs off)
select unique1 from tenk1, f_immutable_int4(1) x where x = 42;
              QUERY PLAN               
---------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Pivotal Optimizer (GPORCA)
(3 rows)

reset enable_nestloop;
-- test inlining of immutable functions with PlaceHolderVars
explain (costs off)
select nt3.id
from nt3 as nt3
  left join
    (select nt2.*, (nt2.b1 or i4 = 42) AS b3
     from nt2 as nt2
       left join
         f_immutable_int4(0) i4
         on i4 = nt2.nt1_id
    ) as ss2
    on ss2.id = nt3.nt2_id
where nt3.id = 1 and ss2.b3;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (nt2.id = nt3.nt2_id)
         ->  Redistribute Motion 1:3  (slice2)
               ->  Result
                     Filter: (nt2.b1 OR ((0) = 42))
                     ->  Hash Left Join
                           Hash Cond: (nt2.nt1_id = (0))
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Seq Scan on nt2
                           ->  Hash
                                 ->  Result
         ->  Hash
               ->  Broadcast Motion 3:3  (slice4; segments: 3)
                     ->  Index Scan using nt3_pkey on nt3
                           Index Cond: (id = 1)
 Optimizer: Pivotal Optimizer (GPORCA)
(17 rows)

drop function f_immutable_int4(int);
-- test inlining when function returns composite
create function mki8(bigint, bigint) returns int8_tbl as
$$select row($1,$2)::int8_tbl$$ language sql;
create function mki4(int) returns int4_tbl as
$$select row($1)::int4_tbl$$ language sql;
explain (verbose, costs off)
select * from mki8(1,2);
              QUERY PLAN               
---------------------------------------
 Function Scan on mki8
   Output: q1, q2
   Function Call: '(1,2)'::int8_tbl
 Settings: optimizer = 'on'
 Optimizer: Pivotal Optimizer (GPORCA)
(5 rows)

select * from mki8(1,2);
 q1 | q2 
----+----
  1 |  2
(1 row)

explain (verbose, costs off)
select * from mki4(42);
              QUERY PLAN               
---------------------------------------
 Function Scan on mki4
   Output: f1
   Function Call: '(42)'::int4_tbl
 Settings: optimizer = 'on'
 Optimizer: Pivotal Optimizer (GPORCA)
(5 rows)

select * from mki4(42);
 f1 
----
 42
(1 row)

drop function mki8(bigint, bigint);
drop function mki4(int);
--
-- test extraction of restriction OR clauses from join OR clause
-- (we used to only do this for indexable clauses)
--
explain (costs off)
select * from tenk1 a join tenk1 b on
  (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.hundred = 4);
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         Join Filter: (((a.unique1 = 1) AND (b.unique1 = 2)) OR ((a.unique2 = 3) AND (b.hundred = 4)))
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Bitmap Heap Scan on tenk1 a
                     Recheck Cond: ((unique1 = 1) OR (unique2 = 3))
                     ->  BitmapOr
                           ->  Bitmap Index Scan on tenk1_unique1
                                 Index Cond: (unique1 = 1)
                           ->  Bitmap Index Scan on tenk1_unique2
                                 Index Cond: (unique2 = 3)
         ->  Materialize
               ->  Bitmap Heap Scan on tenk1 b
                     Recheck Cond: ((unique1 = 2) OR (hundred = 4))
                     ->  BitmapOr
                           ->  Bitmap Index Scan on tenk1_unique1
                                 Index Cond: (unique1 = 2)
                           ->  Bitmap Index Scan on tenk1_hundred
                                 Index Cond: (hundred = 4)
 Optimizer: Postgres query optimizer
(20 rows)

explain (costs off)
select * from tenk1 a join tenk1 b on
  (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.ten = 4);
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         Join Filter: (((a.unique1 = 1) AND (b.unique1 = 2)) OR ((a.unique2 = 3) AND (b.ten = 4)))
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Bitmap Heap Scan on tenk1 a
                     Recheck Cond: ((unique1 = 1) OR (unique2 = 3))
                     ->  BitmapOr
                           ->  Bitmap Index Scan on tenk1_unique1
                                 Index Cond: (unique1 = 1)
                           ->  Bitmap Index Scan on tenk1_unique2
                                 Index Cond: (unique2 = 3)
         ->  Materialize
               ->  Seq Scan on tenk1 b
                     Filter: ((unique1 = 2) OR (ten = 4))
 Optimizer: Postgres query optimizer
(15 rows)

explain (costs off)
select * from tenk1 a join tenk1 b on
  (a.unique1 = 1 and b.unique1 = 2) or
  ((a.unique2 = 3 or a.unique2 = 7) and b.hundred = 4);
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         Join Filter: (((a.unique1 = 1) AND (b.unique1 = 2)) OR (((a.unique2 = 3) OR (a.unique2 = 7)) AND (b.hundred = 4)))
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Bitmap Heap Scan on tenk1 a
                     Recheck Cond: ((unique1 = 1) OR (unique2 = 3) OR (unique2 = 7))
                     ->  BitmapOr
                           ->  Bitmap Index Scan on tenk1_unique1
                                 Index Cond: (unique1 = 1)
                           ->  Bitmap Index Scan on tenk1_unique2
                                 Index Cond: (unique2 = 3)
                           ->  Bitmap Index Scan on tenk1_unique2
                                 Index Cond: (unique2 = 7)
         ->  Materialize
               ->  Bitmap Heap Scan on tenk1 b
                     Recheck Cond: ((unique1 = 2) OR (hundred = 4))
                     ->  BitmapOr
                           ->  Bitmap Index Scan on tenk1_unique1
                                 Index Cond: (unique1 = 2)
                           ->  Bitmap Index Scan on tenk1_hundred
                                 Index Cond: (hundred = 4)
 Optimizer: Postgres query optimizer
(22 rows)

--
-- test placement of movable quals in a parameterized join tree
--
explain (costs off)
select * from tenk1 t1 left join
  (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)
  on t1.hundred = t2.hundred and t1.ten = t3.ten
where t1.unique1 = 1;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Right Join
         Hash Cond: ((tenk1.hundred = tenk1_2.hundred) AND (tenk1_1.ten = tenk1_2.ten))
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: tenk1.hundred
               ->  Hash Join
                     Hash Cond: (tenk1.thousand = tenk1_1.unique2)
                     ->  Redistribute Motion 3:3  (slice3; segments: 3)
                           Hash Key: tenk1.thousand
                           ->  Seq Scan on tenk1
                     ->  Hash
                           ->  Redistribute Motion 3:3  (slice4; segments: 3)
                                 Hash Key: tenk1_1.unique2
                                 ->  Seq Scan on tenk1 tenk1_1
         ->  Hash
               ->  Redistribute Motion 3:3  (slice5; segments: 3)
                     Hash Key: tenk1_2.hundred
                     ->  Index Scan using tenk1_unique1 on tenk1 tenk1_2
                           Index Cond: (unique1 = 1)
 Optimizer: Pivotal Optimizer (GPORCA)
(20 rows)

explain (costs off)
select * from tenk1 t1 left join
  (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)
  on t1.hundred = t2.hundred and t1.ten + t2.ten = t3.ten
where t1.unique1 = 1;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Right Join
         Hash Cond: (tenk1.hundred = tenk1_2.hundred)
         Join Filter: ((tenk1_2.ten + tenk1.ten) = tenk1_1.ten)
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: tenk1.hundred
               ->  Hash Join
                     Hash Cond: (tenk1.thousand = tenk1_1.unique2)
                     ->  Redistribute Motion 3:3  (slice3; segments: 3)
                           Hash Key: tenk1.thousand
                           ->  Seq Scan on tenk1
                     ->  Hash
                           ->  Redistribute Motion 3:3  (slice4; segments: 3)
                                 Hash Key: tenk1_1.unique2
                                 ->  Seq Scan on tenk1 tenk1_1
         ->  Hash
               ->  Redistribute Motion 3:3  (slice5; segments: 3)
                     Hash Key: tenk1_2.hundred
                     ->  Index Scan using tenk1_unique1 on tenk1 tenk1_2
                           Index Cond: (unique1 = 1)
 Optimizer: Pivotal Optimizer (GPORCA)
(21 rows)

explain (costs off)
select count(*) from
  tenk1 a join tenk1 b on a.unique1 = b.unique2
  left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand
  join int4_tbl on b.thousand = f1;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Finalize Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Partial Aggregate
               ->  Hash Right Join
                     Hash Cond: (c.thousand = a.thousand)
                     Join Filter: (a.unique2 = b.unique1)
                     ->  Redistribute Motion 3:3  (slice2; segments: 3)
                           Hash Key: c.thousand
                           ->  Seq Scan on tenk1 c
                     ->  Hash
                           ->  Redistribute Motion 3:3  (slice3; segments: 3)
                                 Hash Key: a.thousand
                                 ->  Hash Join
                                       Hash Cond: (a.unique1 = b.unique2)
                                       ->  Seq Scan on tenk1 a
                                       ->  Hash
                                             ->  Redistribute Motion 3:3  (slice4; segments: 3)
                                                   Hash Key: b.unique2
                                                   ->  Hash Join
                                                         Hash Cond: (b.thousand = int4_tbl.f1)
                                                         ->  Seq Scan on tenk1 b
                                                         ->  Hash
                                                               ->  Broadcast Motion 3:3  (slice5; segments: 3)
                                                                     ->  Seq Scan on int4_tbl
 Optimizer: Postgres query optimizer
(25 rows)

select count(*) from
  tenk1 a join tenk1 b on a.unique1 = b.unique2
  left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand
  join int4_tbl on b.thousand = f1;
 count 
-------
    10
(1 row)

explain (costs off)
select b.unique1 from
  tenk1 a join tenk1 b on a.unique1 = b.unique2
  left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand
  join int4_tbl i1 on b.thousand = f1
  right join int4_tbl i2 on i2.f1 = b.tenthous
  order by 1;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: b.unique1
   ->  Sort
         Sort Key: b.unique1
         ->  Hash Right Join
               Hash Cond: (b.tenthous = i2.f1)
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: b.tenthous
                     ->  Hash Right Join
                           Hash Cond: (c.thousand = a.thousand)
                           Join Filter: (b.unique1 = 42)
                           ->  Redistribute Motion 3:3  (slice3; segments: 3)
                                 Hash Key: c.thousand
                                 ->  Seq Scan on tenk1 c
                           ->  Hash
                                 ->  Redistribute Motion 3:3  (slice4; segments: 3)
                                       Hash Key: a.thousand
                                       ->  Hash Join
                                             Hash Cond: (a.unique1 = b.unique2)
                                             ->  Seq Scan on tenk1 a
                                             ->  Hash
                                                   ->  Redistribute Motion 3:3  (slice5; segments: 3)
                                                         Hash Key: b.unique2
                                                         ->  Hash Join
                                                               Hash Cond: (b.thousand = i1.f1)
                                                               ->  Seq Scan on tenk1 b
                                                               ->  Hash
                                                                     ->  Broadcast Motion 3:3  (slice6; segments: 3)
                                                                           ->  Seq Scan on int4_tbl i1
               ->  Hash
                     ->  Seq Scan on int4_tbl i2
 Optimizer: Postgres query optimizer
(32 rows)

select b.unique1 from
  tenk1 a join tenk1 b on a.unique1 = b.unique2
  left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand
  join int4_tbl i1 on b.thousand = f1
  right join int4_tbl i2 on i2.f1 = b.tenthous
  order by 1;
 unique1 
---------
       0
        
        
        
        
(5 rows)

explain (costs off)
select * from
(
  select unique1, q1, coalesce(unique1, -1) + q1 as fault
  from int8_tbl left join tenk1 on (q2 = unique2)
) ss
where fault = 122
order by fault;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: ((COALESCE(tenk1.unique1, '-1'::integer) + int8_tbl.q1))
   ->  Sort
         Sort Key: ((COALESCE(tenk1.unique1, '-1'::integer) + int8_tbl.q1))
         ->  Result
               Filter: ((COALESCE(tenk1.unique1, '-1'::integer) + int8_tbl.q1) = 122)
               ->  Hash Right Join
                     Hash Cond: ((tenk1.unique2)::bigint = int8_tbl.q2)
                     ->  Redistribute Motion 3:3  (slice2; segments: 3)
                           Hash Key: (tenk1.unique2)::bigint
                           ->  Seq Scan on tenk1
                     ->  Hash
                           ->  Redistribute Motion 3:3  (slice3; segments: 3)
                                 Hash Key: int8_tbl.q2
                                 ->  Seq Scan on int8_tbl
 Optimizer: Pivotal Optimizer (GPORCA)
(16 rows)

select * from
(
  select unique1, q1, coalesce(unique1, -1) + q1 as fault
  from int8_tbl left join tenk1 on (q2 = unique2)
) ss
where fault = 122
order by fault;
 unique1 | q1  | fault 
---------+-----+-------
         | 123 |   122
(1 row)

explain (costs off)
select * from
(values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)
left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x
left join unnest(v1ys) as u1(u1y) on u1y = v2y;
                           QUERY PLAN                           
----------------------------------------------------------------
 Nested Loop Left Join
   Join Filter: (u1.u1y = "*VALUES*_1".column2)
   ->  Hash Left Join
         Hash Cond: ("*VALUES*".column1 = "*VALUES*_1".column1)
         ->  Values Scan on "*VALUES*"
         ->  Hash
               ->  Values Scan on "*VALUES*_1"
   ->  Function Scan on unnest u1
 Optimizer: Postgres query optimizer
(9 rows)

select * from
(values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)
left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x
left join unnest(v1ys) as u1(u1y) on u1y = v2y;
 v1x |  v1ys   | v2x | v2y | u1y 
-----+---------+-----+-----+-----
   1 | {10,20} |   1 |  10 |  10
   2 | {20,30} |   2 |  20 |  20
(2 rows)

--
-- test handling of potential equivalence clauses above outer joins
--
explain (costs off)
select q1, unique2, thousand, hundred
  from int8_tbl a left join tenk1 b on q1 = unique2
  where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Result
         Filter: ((COALESCE(tenk1.thousand, 123) = int8_tbl.q1) AND (int8_tbl.q1 = COALESCE(tenk1.hundred, 123)))
         ->  Hash Right Join
               Hash Cond: ((tenk1.unique2)::bigint = int8_tbl.q1)
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: (tenk1.unique2)::bigint
                     ->  Seq Scan on tenk1
               ->  Hash
                     ->  Seq Scan on int8_tbl
 Optimizer: Pivotal Optimizer (GPORCA)
(11 rows)

select q1, unique2, thousand, hundred
  from int8_tbl a left join tenk1 b on q1 = unique2
  where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);
 q1 | unique2 | thousand | hundred 
----+---------+----------+---------
(0 rows)

explain (costs off)
select f1, unique2, case when unique2 is null then f1 else 0 end
  from int4_tbl a left join tenk1 b on f1 = unique2
  where (case when unique2 is null then f1 else 0 end) = 0;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Result
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Result
               Filter: (CASE WHEN (tenk1.unique2 IS NULL) THEN int4_tbl.f1 ELSE 0 END = 0)
               ->  Hash Right Join
                     Hash Cond: (tenk1.unique2 = int4_tbl.f1)
                     ->  Redistribute Motion 3:3  (slice2; segments: 3)
                           Hash Key: tenk1.unique2
                           ->  Seq Scan on tenk1
                     ->  Hash
                           ->  Seq Scan on int4_tbl
 Optimizer: Pivotal Optimizer (GPORCA)
(12 rows)

select f1, unique2, case when unique2 is null then f1 else 0 end
  from int4_tbl a left join tenk1 b on f1 = unique2
  where (case when unique2 is null then f1 else 0 end) = 0;
 f1 | unique2 | case 
----+---------+------
  0 |       0 |    0
(1 row)

--
-- another case with equivalence clauses above outer joins (bug #8591)
--
explain (costs off)
select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)
  from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)
  where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Right Join
         Hash Cond: (tenk1.unique2 = COALESCE(tenk1_1.twothousand, tenk1_2.twothousand))
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: tenk1.unique2
               ->  Seq Scan on tenk1
         ->  Hash
               ->  Redistribute Motion 3:3  (slice3; segments: 3)
                     Hash Key: COALESCE(tenk1_1.twothousand, tenk1_2.twothousand)
                     ->  Result
                           Filter: (COALESCE(tenk1_1.twothousand, tenk1_2.twothousand) = 44)
                           ->  Hash Right Join
                                 Hash Cond: (tenk1_1.thousand = tenk1_2.unique1)
                                 ->  Redistribute Motion 3:3  (slice4; segments: 3)
                                       Hash Key: tenk1_1.thousand
                                       ->  Seq Scan on tenk1 tenk1_1
                                 ->  Hash
                                       ->  Index Scan using tenk1_unique2 on tenk1 tenk1_2
                                             Index Cond: (unique2 < 10)
 Optimizer: Pivotal Optimizer (GPORCA)
(20 rows)

select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)
  from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)
  where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;
 unique1 | unique1 | unique1 | coalesce 
---------+---------+---------+----------
(0 rows)

--
-- check handling of join aliases when flattening multiple levels of subquery
--
explain (verbose, costs off)
select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from
  (values (0),(1)) foo1(join_key)
left join
  (select join_key, bug_field from
    (select ss1.join_key, ss1.bug_field from
      (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1
    ) foo2
   left join
    (select unique2 as join_key from tenk1 i2) ss2
   using (join_key)
  ) foo3
using (join_key);
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: "Values".column1, int4_tbl.f1, (666)
   ->  Hash Left Join
         Output: "Values".column1, int4_tbl.f1, (666)
         Hash Cond: ("Values".column1 = int4_tbl.f1)
         ->  Result
               Output: "Values".column1
               ->  Values Scan on "Values"
                     Output: "Values".column1
         ->  Hash
               Output: int4_tbl.f1, (666)
               ->  Hash Right Join
                     Output: int4_tbl.f1, (666)
                     Hash Cond: (tenk1.unique2 = int4_tbl.f1)
                     ->  Redistribute Motion 3:3  (slice2; segments: 3)
                           Output: tenk1.unique2
                           Hash Key: tenk1.unique2
                           ->  Seq Scan on public.tenk1
                                 Output: tenk1.unique2
                     ->  Hash
                           Output: (666), int4_tbl.f1
                           ->  Seq Scan on public.int4_tbl
                                 Output: 666, int4_tbl.f1
 Optimizer: Pivotal Optimizer (GPORCA)
(24 rows)

select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from
  (values (0),(1)) foo1(join_key)
left join
  (select join_key, bug_field from
    (select ss1.join_key, ss1.bug_field from
      (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1
    ) foo2
   left join
    (select unique2 as join_key from tenk1 i2) ss2
   using (join_key)
  ) foo3
using (join_key);
 foo1_id | foo3_id | bug_field 
---------+---------+-----------
       0 |       0 |       666
       1 |         |          
(2 rows)

--
-- test successful handling of nested outer joins with degenerate join quals
--
explain (verbose, costs off)
select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: text_tbl.f1
   ->  Hash Left Join
         Output: text_tbl.f1
         Hash Cond: (int8_tbl.q2 = (int4_tbl.f1)::bigint)
         ->  Redistribute Motion 1:3  (slice2)
               Output: text_tbl.f1, int8_tbl.q2
               Hash Key: int8_tbl.q2
               ->  Hash Right Join
                     Output: text_tbl.f1, int8_tbl.q2
                     Hash Cond: (('***'::text) = text_tbl.f1)
                     ->  Hash Right Join
                           Output: ('***'::text), int8_tbl.q2
                           Hash Cond: (((NULL::integer))::bigint = int8_tbl_2.q2)
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 Output: int8_tbl.q2, (NULL::integer)
                                 ->  Hash Left Join
                                       Output: int8_tbl.q2, (NULL::integer)
                                       Hash Cond: (int8_tbl.q1 = int8_tbl_1.q1)
                                       ->  Seq Scan on public.int8_tbl
                                             Output: int8_tbl.q1, int8_tbl.q2
                                       ->  Hash
                                             Output: (NULL::integer), int8_tbl_1.q1
                                             ->  Seq Scan on public.int8_tbl int8_tbl_1
                                                   Output: NULL::integer, int8_tbl_1.q1
                           ->  Hash
                                 Output: ('***'::text), int8_tbl_2.q2
                                 ->  Result
                                       Output: '***'::text, int8_tbl_2.q2
                                       ->  Gather Motion 3:1  (slice4; segments: 3)
                                             Output: int8_tbl_2.q2
                                             ->  Seq Scan on public.int8_tbl int8_tbl_2
                                                   Output: int8_tbl_2.q2
                     ->  Hash
                           Output: text_tbl.f1
                           ->  Gather Motion 3:1  (slice5; segments: 3)
                                 Output: text_tbl.f1
                                 ->  Seq Scan on public.text_tbl
                                       Output: text_tbl.f1
         ->  Hash
               Output: int4_tbl.f1
               ->  Redistribute Motion 3:3  (slice6; segments: 3)
                     Output: int4_tbl.f1
                     Hash Key: (int4_tbl.f1)::bigint
                     ->  Seq Scan on public.int4_tbl
                           Output: int4_tbl.f1
 Optimizer: Pivotal Optimizer (GPORCA)
(48 rows)

select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
        f1         
-------------------
 hi de ho neighbor
 doh!
(2 rows)

explain (verbose, costs off)
select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: text_tbl.f1
   ->  Hash Left Join
         Output: text_tbl.f1
         Hash Cond: (int8_tbl.q2 = (int4_tbl_1.f1)::bigint)
         ->  Redistribute Motion 1:3  (slice2)
               Output: text_tbl.f1, int8_tbl.q2
               Hash Key: int8_tbl.q2
               ->  Hash Right Join
                     Output: text_tbl.f1, int8_tbl.q2
                     Hash Cond: (('***'::text) = text_tbl.f1)
                     ->  Hash Right Join
                           Output: ('***'::text), int8_tbl.q2
                           Hash Cond: (((NULL::integer))::bigint = int8_tbl_2.q2)
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 Output: int8_tbl.q2, (NULL::integer)
                                 ->  Hash Left Join
                                       Output: int8_tbl.q2, (NULL::integer)
                                       Hash Cond: (int8_tbl.q1 = int8_tbl_1.q1)
                                       ->  Seq Scan on public.int8_tbl
                                             Output: int8_tbl.q1, int8_tbl.q2
                                       ->  Hash
                                             Output: (NULL::integer), int8_tbl_1.q1
                                             ->  Nested Loop
                                                   Output: NULL::integer, int8_tbl_1.q1
                                                   Join Filter: true
                                                   ->  Seq Scan on public.int8_tbl int8_tbl_1
                                                         Output: int8_tbl_1.q1
                                                   ->  Materialize
                                                         ->  Broadcast Motion 3:3  (slice4; segments: 3)
                                                               ->  Seq Scan on public.int4_tbl
                           ->  Hash
                                 Output: ('***'::text), int8_tbl_2.q2
                                 ->  Result
                                       Output: '***'::text, int8_tbl_2.q2
                                       ->  Gather Motion 3:1  (slice5; segments: 3)
                                             Output: int8_tbl_2.q2
                                             ->  Seq Scan on public.int8_tbl int8_tbl_2
                                                   Output: int8_tbl_2.q2
                     ->  Hash
                           Output: text_tbl.f1
                           ->  Gather Motion 3:1  (slice6; segments: 3)
                                 Output: text_tbl.f1
                                 ->  Seq Scan on public.text_tbl
                                       Output: text_tbl.f1
         ->  Hash
               Output: int4_tbl_1.f1
               ->  Redistribute Motion 3:3  (slice7; segments: 3)
                     Output: int4_tbl_1.f1
                     Hash Key: (int4_tbl_1.f1)::bigint
                     ->  Seq Scan on public.int4_tbl int4_tbl_1
                           Output: int4_tbl_1.f1
 Optimizer: Pivotal Optimizer (GPORCA)
(54 rows)

select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
        f1         
-------------------
 doh!
 hi de ho neighbor
(2 rows)

explain (verbose, costs off)
select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2
                 where q1 = f1) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: text_tbl.f1
   ->  Hash Left Join
         Output: text_tbl.f1
         Hash Cond: (int8_tbl.q2 = (int4_tbl_1.f1)::bigint)
         ->  Redistribute Motion 1:3  (slice2)
               Output: text_tbl.f1, int8_tbl.q2
               Hash Key: int8_tbl.q2
               ->  Hash Right Join
                     Output: text_tbl.f1, int8_tbl.q2
                     Hash Cond: (('***'::text) = text_tbl.f1)
                     ->  Hash Right Join
                           Output: ('***'::text), int8_tbl.q2
                           Hash Cond: (((NULL::integer))::bigint = int8_tbl_2.q2)
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 Output: int8_tbl.q2, (NULL::integer)
                                 ->  Hash Left Join
                                       Output: int8_tbl.q2, (NULL::integer)
                                       Hash Cond: (int8_tbl.q1 = int8_tbl_1.q1)
                                       ->  Seq Scan on public.int8_tbl
                                             Output: int8_tbl.q1, int8_tbl.q2
                                       ->  Hash
                                             Output: (NULL::integer), int8_tbl_1.q1
                                             ->  Hash Join
                                                   Output: NULL::integer, int8_tbl_1.q1
                                                   Hash Cond: (int8_tbl_1.q1 = (int4_tbl.f1)::bigint)
                                                   ->  Seq Scan on public.int8_tbl int8_tbl_1
                                                         Output: int8_tbl_1.q1
                                                   ->  Hash
                                                         Output: int4_tbl.f1
                                                         ->  Redistribute Motion 3:3  (slice4; segments: 3)
                                                               Output: int4_tbl.f1
                                                               Hash Key: (int4_tbl.f1)::bigint
                                                               ->  Seq Scan on public.int4_tbl
                                                                     Output: int4_tbl.f1
                           ->  Hash
                                 Output: ('***'::text), int8_tbl_2.q2
                                 ->  Result
                                       Output: '***'::text, int8_tbl_2.q2
                                       ->  Gather Motion 3:1  (slice5; segments: 3)
                                             Output: int8_tbl_2.q2
                                             ->  Seq Scan on public.int8_tbl int8_tbl_2
                                                   Output: int8_tbl_2.q2
                     ->  Hash
                           Output: text_tbl.f1
                           ->  Gather Motion 3:1  (slice6; segments: 3)
                                 Output: text_tbl.f1
                                 ->  Seq Scan on public.text_tbl
                                       Output: text_tbl.f1
         ->  Hash
               Output: int4_tbl_1.f1
               ->  Redistribute Motion 3:3  (slice7; segments: 3)
                     Output: int4_tbl_1.f1
                     Hash Key: (int4_tbl_1.f1)::bigint
                     ->  Seq Scan on public.int4_tbl int4_tbl_1
                           Output: int4_tbl_1.f1
 Optimizer: Pivotal Optimizer (GPORCA)
(58 rows)

select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2
                 where q1 = f1) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
        f1         
-------------------
 hi de ho neighbor
 doh!
(2 rows)

explain (verbose, costs off)
select * from
  text_tbl t1
  inner join int8_tbl i8
  on i8.q2 = 456
  right join text_tbl t2
  on t1.f1 = 'doh!'
  left join int4_tbl i4
  on i8.q1 = i4.f1;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: text_tbl.f1, int8_tbl.q1, int8_tbl.q2, text_tbl_1.f1, int4_tbl.f1
   ->  Hash Left Join
         Output: text_tbl.f1, int8_tbl.q1, int8_tbl.q2, text_tbl_1.f1, int4_tbl.f1
         Hash Cond: (int8_tbl.q1 = (int4_tbl.f1)::bigint)
         ->  Nested Loop Left Join
               Output: text_tbl_1.f1, text_tbl.f1, int8_tbl.q1, int8_tbl.q2
               Join Filter: true
               ->  Seq Scan on public.text_tbl text_tbl_1
                     Output: text_tbl_1.f1
               ->  Materialize
                     Output: text_tbl.f1, int8_tbl.q1, int8_tbl.q2
                     ->  Broadcast Motion 3:3  (slice2; segments: 3)
                           Output: text_tbl.f1, int8_tbl.q1, int8_tbl.q2
                           ->  Nested Loop
                                 Output: text_tbl.f1, int8_tbl.q1, int8_tbl.q2
                                 Join Filter: true
                                 ->  Seq Scan on public.int8_tbl
                                       Output: int8_tbl.q1, int8_tbl.q2
                                       Filter: (int8_tbl.q2 = 456)
                                 ->  Materialize
                                       Output: text_tbl.f1
                                       ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                             Output: text_tbl.f1
                                             ->  Seq Scan on public.text_tbl
                                                   Output: text_tbl.f1
                                                   Filter: (text_tbl.f1 = 'doh!'::text)
         ->  Hash
               Output: int4_tbl.f1
               ->  Broadcast Motion 3:3  (slice4; segments: 3)
                     Output: int4_tbl.f1
                     ->  Seq Scan on public.int4_tbl
                           Output: int4_tbl.f1
 Settings: optimizer = 'on'
 Optimizer: Pivotal Optimizer (GPORCA)
(35 rows)

select * from
  text_tbl t1
  inner join int8_tbl i8
  on i8.q2 = 456
  right join text_tbl t2
  on t1.f1 = 'doh!'
  left join int4_tbl i4
  on i8.q1 = i4.f1;
  f1  | q1  | q2  |        f1         | f1 
------+-----+-----+-------------------+----
 doh! | 123 | 456 | doh!              |   
 doh! | 123 | 456 | hi de ho neighbor |   
(2 rows)

--
-- test for appropriate join order in the presence of lateral references
--
-- start_ignore
-- GPDB_94_STABLE_MERGE_FIXME: Currently LATERAL is not fully supported in GPDB
-- and the queries below are failing at the moment (The first one fails with
-- error and the other two fail with panic). Comment them off temporarily.
/*
explain (verbose, costs off)
select * from
  text_tbl t1
  left join int8_tbl i8
  on i8.q2 = 123,
  lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss
where t1.f1 = ss.f1;

select * from
  text_tbl t1
  left join int8_tbl i8
  on i8.q2 = 123,
  lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss
where t1.f1 = ss.f1;

explain (verbose, costs off)
select * from
  text_tbl t1
  left join int8_tbl i8
  on i8.q2 = 123,
  lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,
  lateral (select ss1.* from text_tbl t3 limit 1) as ss2
where t1.f1 = ss2.f1;

select * from
  text_tbl t1
  left join int8_tbl i8
  on i8.q2 = 123,
  lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,
  lateral (select ss1.* from text_tbl t3 limit 1) as ss2
where t1.f1 = ss2.f1;

explain (verbose, costs off)
select 1 from
  text_tbl as tt1
  inner join text_tbl as tt2 on (tt1.f1 = 'foo')
  left join text_tbl as tt3 on (tt3.f1 = 'foo')
  left join text_tbl as tt4 on (tt3.f1 = tt4.f1),
  lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1
where tt1.f1 = ss1.c0;

select 1 from
  text_tbl as tt1
  inner join text_tbl as tt2 on (tt1.f1 = 'foo')
  left join text_tbl as tt3 on (tt3.f1 = 'foo')
  left join text_tbl as tt4 on (tt3.f1 = tt4.f1),
  lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1
where tt1.f1 = ss1.c0;
*/
--end_ignore
--
-- check a case in which a PlaceHolderVar forces join order
--
--start_ignore
--GPDB_94_STABLE_MERGE_FIXME: This query is lateral related and its plan is
--different from PostgreSQL's.  Do not know why yet. Ignore its plan
--temporarily.
explain (verbose, costs off)
select ss2.* from
  int4_tbl i41
  left join int8_tbl i8
    join (select i42.f1 as c1, i43.f1 as c2, 42 as c3
          from int4_tbl i42, int4_tbl i43) ss1
    on i8.q1 = ss1.c2
  on i41.f1 = ss1.c1,
  lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2
where ss1.c2 = 0;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Nested Loop
   Output: (i41.f1), (i8.q1), (i8.q2), (i42.f1), (i43.f1), ((42))
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: i41.f1, i42.f1, i8.q1, i8.q2, i43.f1, (42)
         ->  Nested Loop
               Output: i41.f1, i42.f1, i8.q1, i8.q2, i43.f1, 42
               ->  Nested Loop
                     Output: i41.f1, i42.f1, i8.q1, i8.q2
                     ->  Redistribute Motion 3:3  (slice2; segments: 3)
                           Output: i41.f1, i42.f1
                           Hash Key: 0
                           ->  Hash Join
                                 Output: i41.f1, i42.f1
                                 Hash Cond: (i41.f1 = i42.f1)
                                 ->  Seq Scan on public.int4_tbl i41
                                       Output: i41.f1
                                 ->  Hash
                                       Output: i42.f1
                                       ->  Seq Scan on public.int4_tbl i42
                                             Output: i42.f1
                     ->  Seq Scan on public.int8_tbl i8
                           Output: i8.q1, i8.q2
                           Filter: (i8.q1 = 0)
               ->  Seq Scan on public.int4_tbl i43
                     Output: i43.f1
                     Filter: (i43.f1 = 0)
   ->  Materialize
         Output: (i41.f1), (i8.q1), (i8.q2), (i42.f1), (i43.f1), ((42))
         ->  Limit
               Output: (i41.f1), (i8.q1), (i8.q2), (i42.f1), (i43.f1), ((42))
               ->  Result
                     Output: i41.f1, i8.q1, i8.q2, i42.f1, i43.f1, (42)
                     ->  Materialize
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Seq Scan on public.text_tbl
 Settings: optimizer = 'on'
 Optimizer: Postgres query optimizer
(37 rows)

--end_ignore
select ss2.* from
  int4_tbl i41
  left join int8_tbl i8
    join (select i42.f1 as c1, i43.f1 as c2, 42 as c3
          from int4_tbl i42, int4_tbl i43) ss1
    on i8.q1 = ss1.c2
  on i41.f1 = ss1.c1,
  lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2
where ss1.c2 = 0;
 f1 | q1 | q2 | c1 | c2 | c3 
----+----+----+----+----+----
(0 rows)

--
-- test successful handling of full join underneath left join (bug #14105)
--
explain (costs off)
select * from
  (select 1 as id) as xx
  left join
    (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))
  on (xx.id = coalesce(yy.id));
                   QUERY PLAN                   
------------------------------------------------
 Hash Right Join
   Hash Cond: (COALESCE((1)) = (1))
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Merge Full Join
               Merge Cond: (unique1 = (1))
               ->  Sort
                     Sort Key: unique1
                     ->  Seq Scan on tenk1
               ->  Sort
                     Sort Key: (1)
                     ->  Result
                           ->  Result
   ->  Hash
         ->  Result
 Optimizer: Pivotal Optimizer (GPORCA)
(15 rows)

select * from
  (select 1 as id) as xx
  left join
    (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))
  on (xx.id = coalesce(yy.id));
 id | unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 | id 
----+---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+----
  1 |       1 |    2838 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | EFEAAA   | OOOOxx  |  1
(1 row)

--
-- test ability to push constants through outer join clauses
--
explain (costs off)
  select * from int4_tbl a left join tenk1 b on f1 = unique2 where f1 = 0;
                      QUERY PLAN                      
------------------------------------------------------
 Hash Right Join
   Hash Cond: (tenk1.unique2 = int4_tbl.f1)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Index Scan using tenk1_unique2 on tenk1
               Index Cond: (unique2 = 0)
   ->  Hash
         ->  Gather Motion 3:1  (slice2; segments: 3)
               ->  Seq Scan on int4_tbl
                     Filter: (f1 = 0)
 Optimizer: Pivotal Optimizer (GPORCA)
(10 rows)

explain (costs off)
  select * from tenk1 a full join tenk1 b using(unique2) where unique2 = 42;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Result
         Filter: ((COALESCE(tenk1.unique2, tenk1_1.unique2)) = 42)
         ->  Merge Full Join
               Merge Cond: (tenk1.unique2 = tenk1_1.unique2)
               ->  Sort
                     Sort Key: tenk1.unique2
                     ->  Redistribute Motion 3:3  (slice2; segments: 3)
                           Hash Key: tenk1.unique2
                           ->  Seq Scan on tenk1
               ->  Sort
                     Sort Key: tenk1_1.unique2
                     ->  Redistribute Motion 3:3  (slice3; segments: 3)
                           Hash Key: tenk1_1.unique2
                           ->  Seq Scan on tenk1 tenk1_1
 Optimizer: Pivotal Optimizer (GPORCA)
(16 rows)

--
-- test that quals attached to an outer join have correct semantics,
-- specifically that they don't re-use expressions computed below the join;
-- we force a mergejoin so that coalesce(b.q1, 1) appears as a join input
--
set enable_hashjoin to off;
set enable_nestloop to off;
set enable_mergejoin to on;
explain (verbose, costs off)
  select a.q2, b.q1
    from int8_tbl a left join int8_tbl b on a.q2 = coalesce(b.q1, 1)
    where coalesce(b.q1, 1) > 0;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: int8_tbl.q2, int8_tbl_1.q1
   ->  Result
         Output: int8_tbl.q2, int8_tbl_1.q1
         Filter: (COALESCE(int8_tbl_1.q1, '1'::bigint) > 0)
         ->  Hash Left Join
               Output: int8_tbl.q2, int8_tbl_1.q1
               Hash Cond: (int8_tbl.q2 = COALESCE(int8_tbl_1.q1, '1'::bigint))
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Output: int8_tbl.q2
                     Hash Key: int8_tbl.q2
                     ->  Seq Scan on public.int8_tbl
                           Output: int8_tbl.q2
               ->  Hash
                     Output: int8_tbl_1.q1
                     ->  Redistribute Motion 3:3  (slice3; segments: 3)
                           Output: int8_tbl_1.q1
                           Hash Key: COALESCE(int8_tbl_1.q1, '1'::bigint)
                           ->  Seq Scan on public.int8_tbl int8_tbl_1
                                 Output: int8_tbl_1.q1
 Settings: enable_hashjoin = 'off', enable_mergejoin = 'on', enable_nestloop = 'off', optimizer = 'on'
 Optimizer: Pivotal Optimizer (GPORCA)
(22 rows)

select a.q2, b.q1
  from int8_tbl a left join int8_tbl b on a.q2 = coalesce(b.q1, 1)
  where coalesce(b.q1, 1) > 0;
        q2         |        q1        
-------------------+------------------
               123 |              123
               123 |              123
               456 |                 
  4567890123456789 | 4567890123456789
  4567890123456789 | 4567890123456789
  4567890123456789 | 4567890123456789
  4567890123456789 | 4567890123456789
  4567890123456789 | 4567890123456789
  4567890123456789 | 4567890123456789
 -4567890123456789 |                 
(10 rows)

reset enable_hashjoin;
reset enable_nestloop;
reset enable_mergejoin;
--
-- test join removal
--
begin;
CREATE TEMP TABLE a (id int PRIMARY KEY, b_id int);
CREATE TEMP TABLE b (id int PRIMARY KEY, c_id int);
CREATE TEMP TABLE c (id int PRIMARY KEY);
CREATE TEMP TABLE d (a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO a VALUES (0, 0), (1, NULL);
INSERT INTO b VALUES (0, 0), (1, NULL);
INSERT INTO c VALUES (0), (1);
INSERT INTO d VALUES (1,3), (2,2), (3,1);
ANALYZE a;
ANALYZE b;
ANALYZE c;
ANALYZE d;
-- all three cases should be optimizable into a simple seqscan
explain (costs off) SELECT a.* FROM a LEFT JOIN b ON a.b_id = b.id;
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: a.b_id
               ->  Seq Scan on a
         ->  Index Scan using b_pkey on b
               Index Cond: (id = a.b_id)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

explain (costs off) SELECT b.* FROM b LEFT JOIN c ON b.c_id = c.id;
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: b.c_id
               ->  Seq Scan on b
         ->  Index Scan using c_pkey on c
               Index Cond: (id = b.c_id)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

explain (costs off)
  SELECT a.* FROM a LEFT JOIN (b left join c on b.c_id = c.id)
  ON (a.b_id = b.id);
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Left Join
         Hash Cond: (a.b_id = b.id)
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: a.b_id
               ->  Seq Scan on a
         ->  Hash
               ->  Redistribute Motion 3:3  (slice3; segments: 3)
                     Hash Key: b.id
                     ->  Nested Loop Left Join
                           Join Filter: true
                           ->  Redistribute Motion 3:3  (slice4; segments: 3)
                                 Hash Key: b.c_id
                                 ->  Seq Scan on b
                           ->  Index Scan using c_pkey on c
                                 Index Cond: (id = b.c_id)
 Optimizer: Pivotal Optimizer (GPORCA)
(17 rows)

-- check optimization of outer join within another special join
explain (costs off)
select id from a where id in (
	select b.id from b left join c on b.id = c.id
);
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: (a.id = b.id)
         ->  Seq Scan on a
         ->  Hash
               ->  Nested Loop Left Join
                     Join Filter: true
                     ->  Seq Scan on b
                     ->  Index Scan using c_pkey on c
                           Index Cond: (id = b.id)
 Optimizer: Pivotal Optimizer (GPORCA)
(11 rows)

-- check that join removal works for a left join when joining a subquery
-- that is guaranteed to be unique by its GROUP BY clause
explain (costs off)
select d.* from d left join (select * from b group by b.id, b.c_id) s
  on d.a = s.id and d.b = s.c_id;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Seq Scan on d
         ->  Index Scan using b_pkey on b
               Index Cond: (id = d.a)
               Filter: (d.b = c_id)
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

-- similarly, but keying off a DISTINCT clause
explain (costs off)
select d.* from d left join (select distinct * from b) s
  on d.a = s.id and d.b = s.c_id;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Seq Scan on d
         ->  Index Scan using b_pkey on b
               Index Cond: (id = d.a)
               Filter: (d.b = c_id)
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

-- join removal is not possible when the GROUP BY contains a column that is
-- not in the join condition.  (Note: as of 9.6, we notice that b.id is a
-- primary key and so drop b.c_id from the GROUP BY of the resulting plan;
-- but this happens too late for join removal in the outer plan level.)
explain (costs off)
select d.* from d left join (select * from b group by b.id, b.c_id) s
  on d.a = s.id;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Seq Scan on d
         ->  Index Scan using b_pkey on b
               Index Cond: (id = d.a)
 Optimizer: Pivotal Optimizer (GPORCA)
(7 rows)

-- similarly, but keying off a DISTINCT clause
explain (costs off)
select d.* from d left join (select distinct * from b) s
  on d.a = s.id;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Seq Scan on d
         ->  Index Scan using b_pkey on b
               Index Cond: (id = d.a)
 Optimizer: Pivotal Optimizer (GPORCA)
(7 rows)

-- check join removal works when uniqueness of the join condition is enforced
-- by a UNION
explain (costs off)
select d.* from d left join (select id from a union select id from b) s
  on d.a = s.id;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Left Join
         Hash Cond: (d.a = a.id)
         ->  Seq Scan on d
         ->  Hash
               ->  GroupAggregate
                     Group Key: a.id
                     ->  Sort
                           Sort Key: a.id
                           ->  Redistribute Motion 3:3  (slice2; segments: 3)
                                 Hash Key: a.id
                                 ->  GroupAggregate
                                       Group Key: a.id
                                       ->  Sort
                                             Sort Key: a.id
                                             ->  Redistribute Motion 3:3  (slice3; segments: 3)
                                                   ->  Append
                                                         ->  Seq Scan on a
                                                         ->  Seq Scan on b
 Optimizer: Pivotal Optimizer (GPORCA)
(20 rows)

-- check join removal with a cross-type comparison operator
explain (costs off)
select i8.* from int8_tbl i8 left join (select f1 from int4_tbl group by f1) i4
  on i8.q1 = i4.f1;
                            QUERY PLAN                            
------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Left Join
         Hash Cond: (int8_tbl.q1 = (int4_tbl.f1)::bigint)
         ->  Seq Scan on int8_tbl
         ->  Hash
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: (int4_tbl.f1)::bigint
                     ->  GroupAggregate
                           Group Key: int4_tbl.f1
                           ->  Sort
                                 Sort Key: int4_tbl.f1
                                 ->  Seq Scan on int4_tbl
 Optimizer: Pivotal Optimizer (GPORCA)
(13 rows)

-- check join removal with lateral references
explain (costs off)
select 1 from (select a.id FROM a left join b on a.b_id = b.id) q,
			  lateral generate_series(1, q.id) gs(i) where q.id = gs.i;
                   QUERY PLAN                    
-------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Seq Scan on a
         ->  Function Scan on generate_series gs
               Filter: (a.id = i)
 Optimizer: Postgres query optimizer
(6 rows)

rollback;
create temp table parent (k int primary key, pd int);
create temp table child (k int unique, cd int);
insert into parent values (1, 10), (2, 20), (3, 30);
insert into child values (1, 100), (4, 400);
-- this case is optimizable
select p.* from parent p left join child c on (p.k = c.k);
 k | pd 
---+----
 2 | 20
 3 | 30
 1 | 10
(3 rows)

explain (costs off)
  select p.* from parent p left join child c on (p.k = c.k);
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Seq Scan on parent
         ->  Index Scan using child_k_key on child
               Index Cond: (k = parent.k)
 Optimizer: Pivotal Optimizer (GPORCA)
(7 rows)

-- this case is not
select p.*, linked from parent p
  left join (select c.*, true as linked from child c) as ss
  on (p.k = ss.k);
 k | pd | linked 
---+----+--------
 1 | 10 | t
 2 | 20 | 
 3 | 30 | 
(3 rows)

explain (costs off)
  select p.*, linked from parent p
    left join (select c.*, true as linked from child c) as ss
    on (p.k = ss.k);
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Seq Scan on parent
         ->  Index Scan using child_k_key on child
               Index Cond: (k = parent.k)
 Optimizer: Pivotal Optimizer (GPORCA)
(7 rows)

-- check for a 9.0rc1 bug: join removal breaks pseudoconstant qual handling
select p.* from
  parent p left join child c on (p.k = c.k)
  where p.k = 1 and p.k = 2;
 k | pd 
---+----
(0 rows)

explain (costs off)
select p.* from
  parent p left join child c on (p.k = c.k)
  where p.k = 1 and p.k = 2;
              QUERY PLAN               
---------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Pivotal Optimizer (GPORCA)
(3 rows)

select p.* from
  (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k
  where p.k = 1 and p.k = 2;
 k | pd 
---+----
(0 rows)

explain (costs off)
select p.* from
  (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k
  where p.k = 1 and p.k = 2;
              QUERY PLAN               
---------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Pivotal Optimizer (GPORCA)
(3 rows)

-- bug 5255: this is not optimizable by join removal
begin;
CREATE TEMP TABLE a (id int PRIMARY KEY);
CREATE TEMP TABLE b (id int PRIMARY KEY, a_id int);
INSERT INTO a VALUES (0), (1);
INSERT INTO b VALUES (0, 0), (1, NULL);
SELECT * FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);
 id | a_id | id 
----+------+----
  1 |      |   
(1 row)

SELECT b.* FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);
 id | a_id 
----+------
  1 |     
(1 row)

rollback;
-- another join removal bug: this is not optimizable, either
begin;
create temp table innertab (id int8 primary key, dat1 int8);
insert into innertab values(123, 42);
SELECT * FROM
    (SELECT 1 AS x) ss1
  LEFT JOIN
    (SELECT q1, q2, COALESCE(dat1, q1) AS y
     FROM int8_tbl LEFT JOIN innertab ON q2 = id) ss2
  ON true;
 x |        q1        |        q2         |        y         
---+------------------+-------------------+------------------
 1 | 4567890123456789 |               123 |               42
 1 |              123 |               456 |              123
 1 |              123 |  4567890123456789 |              123
 1 | 4567890123456789 |  4567890123456789 | 4567890123456789
 1 | 4567890123456789 | -4567890123456789 | 4567890123456789
(5 rows)

rollback;
-- another join removal bug: we must clean up correctly when removing a PHV
begin;
create temp table uniquetbl (f1 text unique);
explain (costs off)
select t1.* from
  uniquetbl as t1
  left join (select *, '***'::text as d1 from uniquetbl) t2
  on t1.f1 = t2.f1
  left join uniquetbl t3
  on t2.d1 = t3.f1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: ('***'::text)
               ->  Nested Loop Left Join
                     Join Filter: true
                     ->  Seq Scan on uniquetbl
                     ->  Index Scan using uniquetbl_f1_key on uniquetbl uniquetbl_1
                           Index Cond: (f1 = uniquetbl.f1)
         ->  Index Scan using uniquetbl_f1_key on uniquetbl uniquetbl_2
               Index Cond: (f1 = ('***'::text))
 Optimizer: Pivotal Optimizer (GPORCA)
(13 rows)

explain (costs off)
select t0.*
from
 text_tbl t0
 left join
   (select case t1.ten when 0 then 'doh!'::text else null::text end as case1,
           t1.stringu2
     from tenk1 t1
     join int4_tbl i4 ON i4.f1 = t1.unique2
     left join uniquetbl u1 ON u1.f1 = t1.string4) ss
  on t0.f1 = ss.case1
where ss.stringu2 !~* ss.case1;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (CASE t1.ten WHEN 0 THEN 'doh!'::text ELSE NULL::text END = t0.f1)
         ->  Hash Join
               Hash Cond: (t1.unique2 = i4.f1)
               ->  Seq Scan on tenk1 t1
                     Filter: (stringu2 !~* CASE ten WHEN 0 THEN 'doh!'::text ELSE NULL::text END)
               ->  Hash
                     ->  Broadcast Motion 3:3  (slice2; segments: 3)
                           ->  Seq Scan on int4_tbl i4
         ->  Hash
               ->  Broadcast Motion 3:3  (slice3; segments: 3)
                     ->  Seq Scan on text_tbl t0
 Optimizer: Postgres query optimizer
(14 rows)

select t0.*
from
 text_tbl t0
 left join
   (select case t1.ten when 0 then 'doh!'::text else null::text end as case1,
           t1.stringu2
     from tenk1 t1
     join int4_tbl i4 ON i4.f1 = t1.unique2
     left join uniquetbl u1 ON u1.f1 = t1.string4) ss
  on t0.f1 = ss.case1
where ss.stringu2 !~* ss.case1;
  f1  
------
 doh!
(1 row)

rollback;
-- test case to expose miscomputation of required relid set for a PHV
explain (verbose, costs off)
select i8.*, ss.v, t.unique2
  from int8_tbl i8
    left join int4_tbl i4 on i4.f1 = 1
    left join lateral (select i4.f1 + 1 as v) as ss on true
    left join tenk1 t on t.unique2 = ss.v
where q2 = 456;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: i8.q1, i8.q2, ((i4.f1 + 1)), t.unique2
   ->  Hash Right Join
         Output: i8.q1, i8.q2, ((i4.f1 + 1)), t.unique2
         Hash Cond: (t.unique2 = ((i4.f1 + 1)))
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Output: t.unique2
               Hash Key: t.unique2
               ->  Seq Scan on public.tenk1 t
                     Output: t.unique2
         ->  Hash
               Output: i8.q1, i8.q2, ((i4.f1 + 1))
               ->  Redistribute Motion 3:3  (slice3; segments: 3)
                     Output: i8.q1, i8.q2, ((i4.f1 + 1))
                     Hash Key: ((i4.f1 + 1))
                     ->  Nested Loop Left Join
                           Output: i8.q1, i8.q2, (i4.f1 + 1)
                           ->  Seq Scan on public.int8_tbl i8
                                 Output: i8.q1, i8.q2
                                 Filter: (i8.q2 = 456)
                           ->  Materialize
                                 Output: i4.f1
                                 ->  Broadcast Motion 1:3  (slice4; segments: 1)
                                       Output: i4.f1
                                       ->  Seq Scan on public.int4_tbl i4
                                             Output: i4.f1
                                             Filter: (i4.f1 = 1)
 Optimizer: Postgres query optimizer
(28 rows)

select i8.*, ss.v, t.unique2
  from int8_tbl i8
    left join int4_tbl i4 on i4.f1 = 1
    left join lateral (select i4.f1 + 1 as v) as ss on true
    left join tenk1 t on t.unique2 = ss.v
where q2 = 456;
 q1  | q2  | v | unique2 
-----+-----+---+---------
 123 | 456 |   |        
(1 row)

-- and check a related issue where we miscompute required relids for
-- a PHV that's been translated to a child rel
create temp table parttbl (a integer primary key) partition by range (a);
create temp table parttbl1 partition of parttbl for values from (1) to (100);
insert into parttbl values (11), (12);
explain (costs off)
select * from
  (select *, 12 as phv from parttbl) as ss
  right join int4_tbl on true
where ss.a = ss.phv and f1 = 0;
             QUERY PLAN             
------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         Join Filter: true
         ->  Result
               Filter: (((12) = 12) AND (parttbl1.a = (12)))
               ->  Result
                     ->  Append
                           ->  Index Scan using parttbl1_pkey on parttbl1
                                 Index Cond: (a = 12)
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on int4_tbl
                           Filter: (f1 = 0)
 Optimizer: Pivotal Optimizer (GPORCA)
(14 rows)

select * from
  (select *, 12 as phv from parttbl) as ss
  right join int4_tbl on true
where ss.a = ss.phv and f1 = 0;
 a  | phv | f1 
----+-----+----
 12 |  12 |  0
(1 row)

-- bug #8444: we've historically allowed duplicate aliases within aliased JOINs
select * from
  int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = f1; -- error
ERROR:  column reference "f1" is ambiguous
LINE 2: ..._tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = f1;
                                                                    ^
select * from
  int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = y.f1; -- error
ERROR:  invalid reference to FROM-clause entry for table "y"
LINE 2: ...bl x join (int4_tbl x cross join int4_tbl y) j on q1 = y.f1;
                                                                  ^
HINT:  There is an entry for table "y", but it cannot be referenced from this part of the query.
select * from
  int8_tbl x join (int4_tbl x cross join int4_tbl y(ff)) j on q1 = f1; -- ok
 q1 | q2 | f1 | ff 
----+----+----+----
(0 rows)

--
-- Test hints given on incorrect column references are useful
--
select t1.uunique1 from
  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, prefer "t1" suggestion
ERROR:  column t1.uunique1 does not exist
LINE 1: select t1.uunique1 from
               ^
HINT:  Perhaps you meant to reference the column "t1.unique1".
select t2.uunique1 from
  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, prefer "t2" suggestion
ERROR:  column t2.uunique1 does not exist
LINE 1: select t2.uunique1 from
               ^
HINT:  Perhaps you meant to reference the column "t2.unique1".
select uunique1 from
  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, suggest both at once
ERROR:  column "uunique1" does not exist
LINE 1: select uunique1 from
               ^
HINT:  Perhaps you meant to reference the column "t1.unique1" or the column "t2.unique1".
--
-- Take care to reference the correct RTE
--
select atts.relid::regclass, s.* from pg_stats s join
    pg_attribute a on s.attname = a.attname and s.tablename =
    a.attrelid::regclass::text join (select unnest(indkey) attnum,
    indexrelid from pg_index i) atts on atts.attnum = a.attnum where
    schemaname != 'pg_catalog';
ERROR:  column atts.relid does not exist
LINE 1: select atts.relid::regclass, s.* from pg_stats s join
               ^
--
-- Test LATERAL
--
select unique2, x.*
from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;
 unique2 | f1 
---------+----
    9998 |  0
(1 row)

explain (costs off)
  select unique2, x.*
  from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (a.unique1 = b.f1)
         ->  Seq Scan on tenk1 a
         ->  Hash
               ->  Seq Scan on int4_tbl b
 Optimizer: Postgres query optimizer
(7 rows)

select unique2, x.*
from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;
 unique2 | f1 
---------+----
    9998 |  0
(1 row)

explain (costs off)
  select unique2, x.*
  from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;
                QUERY PLAN                 
-------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (tenk1.unique1 = x.f1)
         ->  Seq Scan on tenk1
         ->  Hash
               ->  Seq Scan on int4_tbl x
 Optimizer: Postgres query optimizer
(7 rows)

explain (costs off)
  select unique2, x.*
  from int4_tbl x cross join lateral (select unique2 from tenk1 where f1 = unique1) ss;
                QUERY PLAN                 
-------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (tenk1.unique1 = x.f1)
         ->  Seq Scan on tenk1
         ->  Hash
               ->  Seq Scan on int4_tbl x
 Optimizer: Postgres query optimizer
(7 rows)

select unique2, x.*
from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;
 unique2 |     f1      
---------+-------------
         |      123456
         |     -123456
    9998 |           0
         | -2147483647
         |  2147483647
(5 rows)

explain (costs off)
  select unique2, x.*
  from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;
                QUERY PLAN                 
-------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Right Join
         Hash Cond: (tenk1.unique1 = x.f1)
         ->  Seq Scan on tenk1
         ->  Hash
               ->  Seq Scan on int4_tbl x
 Optimizer: Postgres query optimizer
(7 rows)

-- check scoping of lateral versus parent references
-- the first of these should return int8_tbl.q2, the second int8_tbl.q1
select *, (select r from (select q1 as q2) x, (select q2 as r) y) from int8_tbl;
        q1        |        q2         |         r         
------------------+-------------------+-------------------
 4567890123456789 |               123 |               123
 4567890123456789 |  4567890123456789 |  4567890123456789
 4567890123456789 | -4567890123456789 | -4567890123456789
              123 |               456 |               456
              123 |  4567890123456789 |  4567890123456789
(5 rows)

select *, (select r from (select q1 as q2) x, lateral (select q2 as r) y) from int8_tbl;
        q1        |        q2         |        r         
------------------+-------------------+------------------
 4567890123456789 |               123 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 | 4567890123456789
              123 |               456 |              123
              123 |  4567890123456789 |              123
(5 rows)

-- lateral with function in FROM
select count(*) from tenk1 a, lateral generate_series(1,two) g;
 count 
-------
  5000
(1 row)

explain (costs off)
  select count(*) from tenk1 a, lateral generate_series(1,two) g;
                         QUERY PLAN                         
------------------------------------------------------------
 Finalize Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Partial Aggregate
               ->  Nested Loop
                     ->  Seq Scan on tenk1 a
                     ->  Memoize
                           Cache Key: a.two
                           Cache Mode: binary
                           ->  Function Scan on generate_series g
 Optimizer: Postgres query optimizer
(10 rows)

explain (costs off)
  select count(*) from tenk1 a cross join lateral generate_series(1,two) g;
                         QUERY PLAN                         
------------------------------------------------------------
 Finalize Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Partial Aggregate
               ->  Nested Loop
                     ->  Seq Scan on tenk1 a
                     ->  Memoize
                           Cache Key: a.two
                           Cache Mode: binary
                           ->  Function Scan on generate_series g
(10 rows)

-- don't need the explicit LATERAL keyword for functions
explain (costs off)
  select count(*) from tenk1 a, generate_series(1,two) g;
                         QUERY PLAN                         
------------------------------------------------------------
 Finalize Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Partial Aggregate
               ->  Nested Loop
                     ->  Seq Scan on tenk1 a
                     ->  Memoize
                           Cache Key: a.two
                           Cache Mode: binary
                           ->  Function Scan on generate_series g
 Optimizer: Postgres query optimizer
(10 rows)

-- lateral with UNION ALL subselect
explain (costs off)
  select * from generate_series(100,200) g,
    lateral (select * from int8_tbl a where g = q1 union all
             select * from int8_tbl b where g = q2) ss;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Nested Loop
   ->  Function Scan on generate_series g
   ->  Materialize
         ->  Append
               ->  Result
                     Filter: (g.g = a.q1)
                     ->  Materialize
                           ->  Gather Motion 3:1  (slice1; segments: 3)
                                 ->  Seq Scan on int8_tbl a
               ->  Result
                     Filter: (g.g = b.q2)
                     ->  Materialize
                           ->  Gather Motion 3:1  (slice2; segments: 3)
                                 ->  Seq Scan on int8_tbl b
 Optimizer: Postgres query optimizer
(15 rows)

select * from generate_series(100,200) g,
  lateral (select * from int8_tbl a where g = q1 union all
           select * from int8_tbl b where g = q2) ss;
  g  |        q1        |        q2        
-----+------------------+------------------
 123 |              123 |              456
 123 |              123 | 4567890123456789
 123 | 4567890123456789 |              123
(3 rows)

-- lateral with VALUES
explain (costs off)
  select count(*) from tenk1 a,
    tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Finalize Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Partial Aggregate
               ->  Hash Join
                     Hash Cond: (b.unique2 = a.unique1)
                     ->  Redistribute Motion 3:3  (slice2; segments: 3)
                           Hash Key: b.unique2
                           ->  Seq Scan on tenk1 b
                     ->  Hash
                           ->  Seq Scan on tenk1 a
 Optimizer: Postgres query optimizer
(11 rows)

select count(*) from tenk1 a,
  tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;
 count 
-------
 10000
(1 row)

-- lateral with VALUES, no flattening possible
explain (costs off)
  select count(*) from tenk1 a,
    tenk1 b join lateral (values(a.unique1),(-1)) ss(x) on b.unique2 = ss.x;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Finalize Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Partial Aggregate
               ->  Hash Join
                     Hash Cond: ("*VALUES*".column1 = b.unique2)
                     ->  Redistribute Motion 3:3  (slice2; segments: 3)
                           Hash Key: "*VALUES*".column1
                           ->  Nested Loop
                                 ->  Seq Scan on tenk1 a
                                 ->  Values Scan on "*VALUES*"
                     ->  Hash
                           ->  Redistribute Motion 3:3  (slice3; segments: 3)
                                 Hash Key: b.unique2
                                 ->  Seq Scan on tenk1 b
 Optimizer: Postgres query optimizer
(15 rows)

select count(*) from tenk1 a,
  tenk1 b join lateral (values(a.unique1),(-1)) ss(x) on b.unique2 = ss.x;
 count 
-------
 10000
(1 row)

-- lateral injecting a strange outer join condition
-- start_ignore
-- GPDB_93_MERGE_FIXME: These queries are failing at the moment. Need to investigate.
-- There were a lot of LATERAL fixes in upstream minor versions, so I'm hoping that
-- these will get fixed once we catch up to those. Or if not, at least it will be
-- nicer to work on the code, knowing that there aren't going to be a dozen commits
-- coming up, touching the same area.
-- FAIL with ERROR:  could not devise a query plan for the given query (pathnode.c:416)
explain (costs off)
  select * from int8_tbl a,
    int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)
      on x.q2 = ss.z
  order by a.q1, a.q2, x.q1, x.q2, ss.z;
ERROR:  could not devise a query plan for the given query (pathnode.c:277)
select * from int8_tbl a,
  int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)
    on x.q2 = ss.z
  order by a.q1, a.q2, x.q1, x.q2, ss.z;
ERROR:  could not devise a query plan for the given query (pathnode.c:277)
--end_ignore
-- lateral reference to a join alias variable
select * from (select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,
  lateral (select x) ss2(y);
 x | f1 | y 
---+----+---
 0 |  0 | 0
(1 row)

select * from (select f1 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,
  lateral (values(x)) ss2(y);
      x      |     f1      |      y      
-------------+-------------+-------------
      123456 |      123456 |      123456
     -123456 |     -123456 |     -123456
           0 |           0 |           0
  2147483647 |  2147483647 |  2147483647
 -2147483647 | -2147483647 | -2147483647
(5 rows)

select * from ((select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1) j,
  lateral (select x) ss2(y);
 x | f1 | y 
---+----+---
 0 |  0 | 0
(1 row)

-- lateral references requiring pullup
select * from (values(1)) x(lb),
  lateral generate_series(lb,4) x4;
 lb | x4 
----+----
  1 |  1
  1 |  2
  1 |  3
  1 |  4
(4 rows)

select * from (select f1/1000000000 from int4_tbl) x(lb),
  lateral generate_series(lb,4) x4;
 lb | x4 
----+----
  0 |  0
  0 |  1
  0 |  2
  0 |  3
  0 |  4
  0 |  0
  0 |  1
  0 |  2
  0 |  3
  0 |  4
  0 |  0
  0 |  1
  0 |  2
  0 |  3
  0 |  4
  2 |  2
  2 |  3
  2 |  4
 -2 | -2
 -2 | -1
 -2 |  0
 -2 |  1
 -2 |  2
 -2 |  3
 -2 |  4
(25 rows)

select * from (values(1)) x(lb),
  lateral (values(lb)) y(lbcopy);
 lb | lbcopy 
----+--------
  1 |      1
(1 row)

select * from (values(1)) x(lb),
  lateral (select lb from int4_tbl) y(lbcopy);
 lb | lbcopy 
----+--------
  1 |      1
  1 |      1
  1 |      1
  1 |      1
  1 |      1
(5 rows)

select * from
  int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
  lateral (values(x.q1,y.q1,y.q2)) v(xq1,yq1,yq2);
        q1        |        q2         |        q1        |        q2         |       xq1        |       yq1        |        yq2        
------------------+-------------------+------------------+-------------------+------------------+------------------+-------------------
 4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789 | 4567890123456789 | -4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 |  4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789 | 4567890123456789 |               123
 4567890123456789 | -4567890123456789 |                  |                   | 4567890123456789 |                  |                  
              123 |               456 |                  |                   |              123 |                  |                  
              123 |  4567890123456789 | 4567890123456789 | -4567890123456789 |              123 | 4567890123456789 | -4567890123456789
              123 |  4567890123456789 | 4567890123456789 |  4567890123456789 |              123 | 4567890123456789 |  4567890123456789
              123 |  4567890123456789 | 4567890123456789 |               123 |              123 | 4567890123456789 |               123
 4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789 |              123 |  4567890123456789
 4567890123456789 |               123 |              123 |               456 | 4567890123456789 |              123 |               456
(10 rows)

select * from
  int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
  lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);
        q1        |        q2         |        q1        |        q2         |       xq1        |       yq1        |        yq2        
------------------+-------------------+------------------+-------------------+------------------+------------------+-------------------
 4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789 |              123 |  4567890123456789
 4567890123456789 |               123 |              123 |               456 | 4567890123456789 |              123 |               456
 4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789 | 4567890123456789 | -4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 |  4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789 | 4567890123456789 |               123
 4567890123456789 | -4567890123456789 |                  |                   | 4567890123456789 |                  |                  
              123 |               456 |                  |                   |              123 |                  |                  
              123 |  4567890123456789 | 4567890123456789 | -4567890123456789 |              123 | 4567890123456789 | -4567890123456789
              123 |  4567890123456789 | 4567890123456789 |  4567890123456789 |              123 | 4567890123456789 |  4567890123456789
              123 |  4567890123456789 | 4567890123456789 |               123 |              123 | 4567890123456789 |               123
(10 rows)

select x.* from
  int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
  lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);
        q1        |        q2         
------------------+-------------------
 4567890123456789 |               123
 4567890123456789 |               123
 4567890123456789 |  4567890123456789
 4567890123456789 |  4567890123456789
 4567890123456789 |  4567890123456789
 4567890123456789 | -4567890123456789
              123 |               456
              123 |  4567890123456789
              123 |  4567890123456789
              123 |  4567890123456789
(10 rows)

select v.* from
  (int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1)
  left join int4_tbl z on z.f1 = x.q2,
  lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);
        vx         |        vy         
-------------------+-------------------
  4567890123456789 |               123
               123 |  4567890123456789
  4567890123456789 |               123
               123 |               456
  4567890123456789 |  4567890123456789
  4567890123456789 | -4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |               123
  4567890123456789 |                  
 -4567890123456789 |                  
               123 |                  
               456 |                  
               123 |  4567890123456789
  4567890123456789 | -4567890123456789
               123 |  4567890123456789
  4567890123456789 |  4567890123456789
               123 |  4567890123456789
  4567890123456789 |               123
(20 rows)

select v.* from
  (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)
  left join int4_tbl z on z.f1 = x.q2,
  lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);
        vx         |        vy         
-------------------+-------------------
  4567890123456789 |  4567890123456789
  4567890123456789 | -4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |               123
  4567890123456789 |                  
 -4567890123456789 |                  
               123 |                  
               456 |                  
               123 |  4567890123456789
  4567890123456789 | -4567890123456789
               123 |  4567890123456789
  4567890123456789 |  4567890123456789
               123 |  4567890123456789
  4567890123456789 |               123
  4567890123456789 |               123
               123 |  4567890123456789
  4567890123456789 |               123
               123 |               456
(20 rows)

select v.* from
  (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)
  left join int4_tbl z on z.f1 = x.q2,
  lateral (select x.q1,y.q1 from onerow union all select x.q2,y.q2 from onerow) v(vx,vy);
        vx         |        vy         
-------------------+-------------------
  4567890123456789 |               123
               123 |  4567890123456789
  4567890123456789 |               123
               123 |               456
  4567890123456789 |  4567890123456789
  4567890123456789 | -4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |               123
  4567890123456789 |                  
 -4567890123456789 |                  
               123 |                  
               456 |                  
               123 |  4567890123456789
  4567890123456789 | -4567890123456789
               123 |  4567890123456789
  4567890123456789 |  4567890123456789
               123 |  4567890123456789
  4567890123456789 |               123
(20 rows)

explain (verbose, costs off)
select * from
  int8_tbl a left join
  lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: a.q1, a.q2, b.q1, b.q2, (a.q2)
   ->  Nested Loop Left Join
         Output: a.q1, a.q2, b.q1, b.q2, (a.q2)
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Output: a.q1, a.q2
               Hash Key: a.q2
               ->  Seq Scan on public.int8_tbl a
                     Output: a.q1, a.q2
         ->  Seq Scan on public.int8_tbl b
               Output: b.q1, b.q2, a.q2
               Filter: (a.q2 = b.q1)
 Settings: optimizer = 'on'
 Optimizer: Postgres query optimizer
(14 rows)

select * from
  int8_tbl a left join
  lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;
        q1        |        q2         |        q1        |        q2         |        x         
------------------+-------------------+------------------+-------------------+------------------
              123 |               456 |                  |                   |                 
              123 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
              123 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
              123 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 |                  |                   |                 
 4567890123456789 |               123 |              123 |               456 |              123
 4567890123456789 |               123 |              123 |  4567890123456789 |              123
(10 rows)

explain (verbose, costs off)
select * from
  int8_tbl a left join
  lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: a.q1, a.q2, b.q1, b.q2, (COALESCE(a.q2, '42'::bigint))
   ->  Nested Loop Left Join
         Output: a.q1, a.q2, b.q1, b.q2, (COALESCE(a.q2, '42'::bigint))
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Output: a.q1, a.q2
               Hash Key: a.q2
               ->  Seq Scan on public.int8_tbl a
                     Output: a.q1, a.q2
         ->  Seq Scan on public.int8_tbl b
               Output: b.q1, b.q2, COALESCE(a.q2, '42'::bigint)
               Filter: (a.q2 = b.q1)
 Settings: optimizer = 'on'
 Optimizer: Postgres query optimizer
(14 rows)

select * from
  int8_tbl a left join
  lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;
        q1        |        q2         |        q1        |        q2         |        x         
------------------+-------------------+------------------+-------------------+------------------
 4567890123456789 |               123 |              123 |               456 |              123
 4567890123456789 |               123 |              123 |  4567890123456789 |              123
              123 |               456 |                  |                   |                 
              123 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
              123 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
              123 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 |                  |                   |                 
(10 rows)

-- lateral can result in join conditions appearing below their
-- real semantic level
explain (verbose, costs off)
select * from int4_tbl i left join
  lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;
                   QUERY PLAN                    
-------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: i.f1, j.f1
   ->  Hash Left Join
         Output: i.f1, j.f1
         Hash Cond: (i.f1 = j.f1)
         ->  Seq Scan on public.int4_tbl i
               Output: i.f1
         ->  Hash
               Output: j.f1
               ->  Seq Scan on public.int2_tbl j
                     Output: j.f1
 Settings: optimizer = 'on'
 Optimizer: Postgres query optimizer
(13 rows)

select * from int4_tbl i left join
  lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;
     f1      | f1 
-------------+----
           0 |  0
  2147483647 |   
 -2147483647 |   
      123456 |   
     -123456 |   
(5 rows)

explain (verbose, costs off)
select * from int4_tbl i left join
  lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;
                QUERY PLAN                 
-------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: i.f1, (COALESCE(i.*))
   ->  Nested Loop Left Join
         Output: i.f1, (COALESCE(i.*))
         ->  Seq Scan on public.int4_tbl i
               Output: i.f1, i.*
         ->  Seq Scan on public.int2_tbl j
               Output: j.f1, COALESCE(i.*)
               Filter: (i.f1 = j.f1)
 Optimizer: Postgres query optimizer
(10 rows)

select * from int4_tbl i left join
  lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;
     f1      | coalesce 
-------------+----------
      123456 | 
     -123456 | 
           0 | (0)
  2147483647 | 
 -2147483647 | 
(5 rows)

explain (verbose, costs off)
select * from int4_tbl a,
  lateral (
    select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)
  ) ss;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Nested Loop
   Output: a.f1, b.f1, c.q1, c.q2
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: a.f1
         ->  Seq Scan on public.int4_tbl a
               Output: a.f1
   ->  Materialize
         Output: b.f1, c.q1, c.q2
         ->  Hash Right Join
               Output: b.f1, c.q1, c.q2
               Hash Cond: (c.q1 = b.f1)
               ->  Result
                     Output: c.q1, c.q2
                     Filter: (a.f1 = c.q2)
                     ->  Materialize
                           Output: c.q1, c.q2
                           ->  Gather Motion 3:1  (slice2; segments: 3)
                                 Output: c.q1, c.q2
                                 ->  Seq Scan on public.int8_tbl c
                                       Output: c.q1, c.q2
               ->  Hash
                     Output: b.f1
                     ->  Materialize
                           Output: b.f1
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 Output: b.f1
                                 ->  Seq Scan on public.int4_tbl b
                                       Output: b.f1
 Optimizer: Postgres query optimizer
(29 rows)

select * from int4_tbl a,
  lateral (
    select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)
  ) ss;
     f1      |     f1      | q1 | q2 
-------------+-------------+----+----
      123456 |     -123456 |    |   
      123456 |      123456 |    |   
      123456 |           0 |    |   
      123456 |  2147483647 |    |   
      123456 | -2147483647 |    |   
     -123456 |     -123456 |    |   
     -123456 |      123456 |    |   
     -123456 |           0 |    |   
     -123456 |  2147483647 |    |   
     -123456 | -2147483647 |    |   
           0 |     -123456 |    |   
           0 |      123456 |    |   
           0 |           0 |    |   
           0 |  2147483647 |    |   
           0 | -2147483647 |    |   
  2147483647 |     -123456 |    |   
  2147483647 |      123456 |    |   
  2147483647 |           0 |    |   
  2147483647 |  2147483647 |    |   
  2147483647 | -2147483647 |    |   
 -2147483647 |     -123456 |    |   
 -2147483647 |      123456 |    |   
 -2147483647 |           0 |    |   
 -2147483647 |  2147483647 |    |   
 -2147483647 | -2147483647 |    |   
(25 rows)

-- lateral reference in a PlaceHolderVar evaluated at join level
-- GPDB_94_STABLE_MERGE_FIXME: The query fails. The change is related to
-- upstream commit acfcd4. Need to come back to fix it when understanding more
-- about that commit.
explain (verbose, costs off)
select * from
  int8_tbl a left join lateral
  (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from
   int8_tbl b cross join int8_tbl c) ss
  on a.q2 = ss.bq1;
ERROR:  could not devise a query plan for the given query (pathnode.c:275)
select * from
  int8_tbl a left join lateral
  (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from
   int8_tbl b cross join int8_tbl c) ss
  on a.q2 = ss.bq1;
ERROR:  could not devise a query plan for the given query (pathnode.c:275)
-- case requiring nested PlaceHolderVars
explain (verbose, costs off)
select * from
  int8_tbl c left join (
    int8_tbl a left join (select q1, coalesce(q2,42) as x from int8_tbl b) ss1
      on a.q2 = ss1.q1
    cross join
    lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2
  ) on c.q2 = ss2.q1,
  lateral (select ss2.y offset 0) ss3;
                                                                                        QUERY PLAN                                                                                        
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: c.q1, c.q2, a.q1, a.q2, b.q1, (COALESCE(b.q2, '42'::bigint)), d.q1, (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2)), ((COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2)))
   ->  Nested Loop
         Output: c.q1, c.q2, a.q1, a.q2, b.q1, (COALESCE(b.q2, '42'::bigint)), d.q1, (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2)), ((COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2)))
         ->  Hash Right Join
               Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, (COALESCE(b.q2, '42'::bigint)), (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2))
               Hash Cond: (d.q1 = c.q2)
               ->  Nested Loop
                     Output: a.q1, a.q2, b.q1, d.q1, (COALESCE(b.q2, '42'::bigint)), (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2))
                     ->  Broadcast Motion 3:3  (slice2; segments: 3)
                           Output: a.q1, a.q2, b.q1, (COALESCE(b.q2, '42'::bigint))
                           ->  Hash Left Join
                                 Output: a.q1, a.q2, b.q1, (COALESCE(b.q2, '42'::bigint))
                                 Hash Cond: (a.q2 = b.q1)
                                 ->  Redistribute Motion 3:3  (slice3; segments: 3)
                                       Output: a.q1, a.q2
                                       Hash Key: a.q2
                                       ->  Seq Scan on public.int8_tbl a
                                             Output: a.q1, a.q2
                                 ->  Hash
                                       Output: b.q1, (COALESCE(b.q2, '42'::bigint))
                                       ->  Seq Scan on public.int8_tbl b
                                             Output: b.q1, COALESCE(b.q2, '42'::bigint)
                     ->  Seq Scan on public.int8_tbl d
                           Output: d.q1, COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2)
               ->  Hash
                     Output: c.q1, c.q2
                     ->  Redistribute Motion 3:3  (slice4; segments: 3)
                           Output: c.q1, c.q2
                           Hash Key: c.q2
                           ->  Seq Scan on public.int8_tbl c
                                 Output: c.q1, c.q2
         ->  Materialize
               Output: ((COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2)))
               ->  Result
                     Output: (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2))
 Optimizer: Postgres query optimizer
(37 rows)

-- case that breaks the old ph_may_need optimization
explain (verbose, costs off)
select c.*,a.*,ss1.q1,ss2.q1,ss3.* from
  int8_tbl c left join (
    int8_tbl a left join
      (select q1, coalesce(q2,f1) as x from int8_tbl b, int4_tbl b2
       where q1 < f1) ss1
      on a.q2 = ss1.q1
    cross join
    lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2
  ) on c.q2 = ss2.q1,
  lateral (select * from int4_tbl i where ss2.y > f1) ss3;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, i.f1
   ->  Nested Loop
         Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, i.f1
         Join Filter: ((COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2)) > i.f1)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               Output: i.f1
               ->  Seq Scan on public.int4_tbl i
                     Output: i.f1
         ->  Materialize
               Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, (COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2))
               ->  Hash Right Join
                     Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, (COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2))
                     Hash Cond: (d.q1 = c.q2)
                     ->  Nested Loop
                           Output: a.q1, a.q2, b.q1, d.q1, (COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2))
                           ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                 Output: a.q1, a.q2, b.q1, (COALESCE(b.q2, (b2.f1)::bigint))
                                 ->  Hash Right Join
                                       Output: a.q1, a.q2, b.q1, (COALESCE(b.q2, (b2.f1)::bigint))
                                       Hash Cond: (b.q1 = a.q2)
                                       ->  Nested Loop
                                             Output: b.q1, COALESCE(b.q2, (b2.f1)::bigint)
                                             Join Filter: (b.q1 < b2.f1)
                                             ->  Seq Scan on public.int8_tbl b
                                                   Output: b.q1, b.q2
                                             ->  Materialize
                                                   Output: b2.f1
                                                   ->  Broadcast Motion 3:3  (slice4; segments: 3)
                                                         Output: b2.f1
                                                         ->  Seq Scan on public.int4_tbl b2
                                                               Output: b2.f1
                                       ->  Hash
                                             Output: a.q1, a.q2
                                             ->  Redistribute Motion 3:3  (slice5; segments: 3)
                                                   Output: a.q1, a.q2
                                                   Hash Key: a.q2
                                                   ->  Seq Scan on public.int8_tbl a
                                                         Output: a.q1, a.q2
                           ->  Seq Scan on public.int8_tbl d
                                 Output: d.q1, COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2)
                     ->  Hash
                           Output: c.q1, c.q2
                           ->  Redistribute Motion 3:3  (slice6; segments: 3)
                                 Output: c.q1, c.q2
                                 Hash Key: c.q2
                                 ->  Seq Scan on public.int8_tbl c
                                       Output: c.q1, c.q2
 Optimizer: Postgres query optimizer
(49 rows)

-- check processing of postponed quals (bug #9041)
explain (verbose, costs off)
select * from
  (select 1 as x offset 0) x cross join (select 2 as y offset 0) y
  left join lateral (
    select * from (select 3 as z offset 0) z where z.z = x.x
  ) zz on zz.z = y.y;
                 QUERY PLAN                 
--------------------------------------------
 Hash Left Join
   Output: (1), (2), (3)
   Hash Cond: (((1) = (3)) AND ((2) = (3)))
   ->  Nested Loop
         Output: (1), (2)
         ->  Result
               Output: 1
         ->  Materialize
               Output: (2)
               ->  Result
                     Output: 2
   ->  Hash
         Output: (3)
         ->  Result
               Output: 3
 Optimizer: Postgres query optimizer
(16 rows)

-- check dummy rels with lateral references (bug #15694)
explain (verbose, costs off)
select * from int8_tbl i8 left join lateral
  (select *, i8.q2 from int4_tbl where false) ss on true;
                 QUERY PLAN                 
--------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: i8.q1, i8.q2, f1, (i8.q2)
   ->  Nested Loop Left Join
         Output: i8.q1, i8.q2, f1, (i8.q2)
         ->  Seq Scan on public.int8_tbl i8
               Output: i8.q1, i8.q2
         ->  Result
               Output: f1, i8.q2
               One-Time Filter: false
 Optimizer: Postgres query optimizer
(10 rows)

explain (verbose, costs off)
select * from int8_tbl i8 left join lateral
  (select *, i8.q2 from int4_tbl i1, int4_tbl i2 where false) ss on true;
                  QUERY PLAN                   
-----------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: i8.q1, i8.q2, f1, f1, (i8.q2)
   ->  Nested Loop Left Join
         Output: i8.q1, i8.q2, f1, f1, (i8.q2)
         ->  Seq Scan on public.int8_tbl i8
               Output: i8.q1, i8.q2
         ->  Result
               Output: f1, f1, i8.q2
               One-Time Filter: false
 Optimizer: Postgres query optimizer
(10 rows)

-- check handling of nested appendrels inside LATERAL
select * from
  ((select 2 as v) union all (select 3 as v)) as q1
  cross join lateral
  ((select * from
      ((select 4 as v) union all (select 5 as v)) as q3)
   union all
   (select q1.v)
  ) as q2;
 v | v 
---+---
 2 | 4
 2 | 5
 2 | 2
 3 | 4
 3 | 5
 3 | 3
(6 rows)

-- check the number of columns specified
SELECT * FROM (int8_tbl i cross join int4_tbl j) ss(a,b,c,d);
ERROR:  join expression "ss" has 3 columns available but 4 columns specified
-- check we don't try to do a unique-ified semijoin with LATERAL
explain (verbose, costs off)
select * from
  (values (0,9998), (1,1000)) v(id,x),
  lateral (select f1 from int4_tbl
           where f1 = any (select unique1 from tenk1
                           where unique2 = v.x offset 0)) ss;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: "*VALUES*".column1, "*VALUES*".column2, int4_tbl.f1
   ->  Nested Loop
         Output: "*VALUES*".column1, "*VALUES*".column2, int4_tbl.f1
         ->  Values Scan on "*VALUES*"
               Output: "*VALUES*".column1, "*VALUES*".column2
         ->  Seq Scan on public.int4_tbl
               Output: int4_tbl.f1
               Filter: (SubPlan 1)
               SubPlan 1
                 ->  Result
                       Output: tenk1.unique1
                       Filter: (tenk1.unique2 = "*VALUES*".column2)
                       ->  Materialize
                             Output: tenk1.unique1, tenk1.unique2
                             ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                   Output: tenk1.unique1, tenk1.unique2
                                   ->  Seq Scan on public.tenk1
                                         Output: tenk1.unique1, tenk1.unique2
 Optimizer: Postgres query optimizer
(20 rows)

select * from
  (values (0,9998), (1,1000)) v(id,x),
  lateral (select f1 from int4_tbl
           where f1 = any (select unique1 from tenk1
                           where unique2 = v.x offset 0)) ss;
 id |  x   | f1 
----+------+----
  0 | 9998 |  0
(1 row)

-- check proper extParam/allParam handling (this isn't exactly a LATERAL issue,
-- but we can make the test case much more compact with LATERAL)
explain (verbose, costs off)
select * from (values (0), (1)) v(id),
lateral (select * from int8_tbl t1,
         lateral (select * from
                    (select * from int8_tbl t2
                     where q1 = any (select q2 from int8_tbl t3
                                     where q2 = (select greatest(t1.q1,t2.q2))
                                       and (select v.id=0)) offset 0) ss2) ss
         where t1.q1 = ss.q2) ss0;
ERROR:  correlated subquery with skip-level correlations is not supported
select * from (values (0), (1)) v(id),
lateral (select * from int8_tbl t1,
         lateral (select * from
                    (select * from int8_tbl t2
                     where q1 = any (select q2 from int8_tbl t3
                                     where q2 = (select greatest(t1.q1,t2.q2))
                                       and (select v.id=0)) offset 0) ss2) ss
         where t1.q1 = ss.q2) ss0;
ERROR:  correlated subquery with skip-level correlations is not supported
-- test some error cases where LATERAL should have been used but wasn't
select f1,g from int4_tbl a, (select f1 as g) ss;
ERROR:  column "f1" does not exist
LINE 1: select f1,g from int4_tbl a, (select f1 as g) ss;
                                             ^
HINT:  There is a column named "f1" in table "a", but it cannot be referenced from this part of the query.
select f1,g from int4_tbl a, (select a.f1 as g) ss;
ERROR:  invalid reference to FROM-clause entry for table "a"
LINE 1: select f1,g from int4_tbl a, (select a.f1 as g) ss;
                                             ^
HINT:  There is an entry for table "a", but it cannot be referenced from this part of the query.
select f1,g from int4_tbl a cross join (select f1 as g) ss;
ERROR:  column "f1" does not exist
LINE 1: select f1,g from int4_tbl a cross join (select f1 as g) ss;
                                                       ^
HINT:  There is a column named "f1" in table "a", but it cannot be referenced from this part of the query.
select f1,g from int4_tbl a cross join (select a.f1 as g) ss;
ERROR:  invalid reference to FROM-clause entry for table "a"
LINE 1: select f1,g from int4_tbl a cross join (select a.f1 as g) ss...
                                                       ^
HINT:  There is an entry for table "a", but it cannot be referenced from this part of the query.
-- SQL:2008 says the left table is in scope but illegal to access here
select f1,g from int4_tbl a right join lateral generate_series(0, a.f1) g on true;
ERROR:  invalid reference to FROM-clause entry for table "a"
LINE 1: ... int4_tbl a right join lateral generate_series(0, a.f1) g on...
                                                             ^
DETAIL:  The combining JOIN type must be INNER or LEFT for a LATERAL reference.
select f1,g from int4_tbl a full join lateral generate_series(0, a.f1) g on true;
ERROR:  invalid reference to FROM-clause entry for table "a"
LINE 1: ...m int4_tbl a full join lateral generate_series(0, a.f1) g on...
                                                             ^
DETAIL:  The combining JOIN type must be INNER or LEFT for a LATERAL reference.
-- check we complain about ambiguous table references
select * from
  int8_tbl x cross join (int4_tbl x cross join lateral (select x.f1) ss);
ERROR:  table reference "x" is ambiguous
LINE 2: ...cross join (int4_tbl x cross join lateral (select x.f1) ss);
                                                             ^
-- LATERAL can be used to put an aggregate into the FROM clause of its query
select 1 from tenk1 a, lateral (select max(a.unique1) from int4_tbl b) ss;
ERROR:  aggregate functions are not allowed in FROM clause of their own query level
LINE 1: select 1 from tenk1 a, lateral (select max(a.unique1) from i...
                                               ^
-- check behavior of LATERAL in UPDATE/DELETE
create temp table xx1 as select f1 as x1, -f1 as x2 from int4_tbl;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause. Creating a NULL policy entry.
-- error, can't do this:
update xx1 set x2 = f1 from (select * from int4_tbl where f1 = x1) ss;
ERROR:  column "x1" does not exist
LINE 1: ... set x2 = f1 from (select * from int4_tbl where f1 = x1) ss;
                                                                ^
HINT:  There is a column named "x1" in table "xx1", but it cannot be referenced from this part of the query.
update xx1 set x2 = f1 from (select * from int4_tbl where f1 = xx1.x1) ss;
ERROR:  invalid reference to FROM-clause entry for table "xx1"
LINE 1: ...t x2 = f1 from (select * from int4_tbl where f1 = xx1.x1) ss...
                                                             ^
HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
-- can't do it even with LATERAL:
update xx1 set x2 = f1 from lateral (select * from int4_tbl where f1 = x1) ss;
ERROR:  invalid reference to FROM-clause entry for table "xx1"
LINE 1: ...= f1 from lateral (select * from int4_tbl where f1 = x1) ss;
                                                                ^
HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
-- we might in future allow something like this, but for now it's an error:
update xx1 set x2 = f1 from xx1, lateral (select * from int4_tbl where f1 = x1) ss;
ERROR:  table name "xx1" specified more than once
-- also errors:
delete from xx1 using (select * from int4_tbl where f1 = x1) ss;
ERROR:  column "x1" does not exist
LINE 1: ...te from xx1 using (select * from int4_tbl where f1 = x1) ss;
                                                                ^
HINT:  There is a column named "x1" in table "xx1", but it cannot be referenced from this part of the query.
delete from xx1 using (select * from int4_tbl where f1 = xx1.x1) ss;
ERROR:  invalid reference to FROM-clause entry for table "xx1"
LINE 1: ...from xx1 using (select * from int4_tbl where f1 = xx1.x1) ss...
                                                             ^
HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
delete from xx1 using lateral (select * from int4_tbl where f1 = x1) ss;
ERROR:  invalid reference to FROM-clause entry for table "xx1"
LINE 1: ...xx1 using lateral (select * from int4_tbl where f1 = x1) ss;
                                                                ^
HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
--
-- test LATERAL reference propagation down a multi-level inheritance hierarchy
-- produced for a multi-level partitioned table hierarchy.
--
create table join_pt1 (a int, b int, c varchar) partition by range(a);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
create table join_pt1p1 partition of join_pt1 for values from (0) to (100) partition by range(b);
NOTICE:  table has parent, setting distribution columns to match parent table
create table join_pt1p2 partition of join_pt1 for values from (100) to (200);
NOTICE:  table has parent, setting distribution columns to match parent table
create table join_pt1p1p1 partition of join_pt1p1 for values from (0) to (100);
NOTICE:  table has parent, setting distribution columns to match parent table
insert into join_pt1 values (1, 1, 'x'), (101, 101, 'y');
create table join_ut1 (a int, b int, c varchar);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into join_ut1 values (101, 101, 'y'), (2, 2, 'z');
-- GPDB_12_MERGE_FIXME: The query fails. This test query is new with v12,
-- but a corresponding query fails on GPDB master, too. I think this is
-- similar to the case marked with GPDB_94_STABLE_MERGE_FIXME above.
-- upstream commit acfcd4. Need to come back to fix it when understanding more
-- about that commit.
-- start_ignore
explain (verbose, costs off)
select t1.b, ss.phv from join_ut1 t1 left join lateral
              (select t2.a as t2a, t3.a t3a, least(t1.a, t2.a, t3.a) phv
					  from join_pt1 t2 join join_ut1 t3 on t2.a = t3.b) ss
              on t1.a = ss.t2a order by t1.a;
ERROR:  could not devise a query plan for the given query (pathnode.c:275)
select t1.b, ss.phv from join_ut1 t1 left join lateral
              (select t2.a as t2a, t3.a t3a, least(t1.a, t2.a, t3.a) phv
					  from join_pt1 t2 join join_ut1 t3 on t2.a = t3.b) ss
              on t1.a = ss.t2a order by t1.a;
ERROR:  could not devise a query plan for the given query (pathnode.c:275)
-- end_ignore
drop table join_pt1;
drop table join_ut1;
--
-- test estimation behavior with multi-column foreign key and constant qual
--
begin;
create table fkest (x integer, x10 integer, x10b integer, x100 integer);
insert into fkest select x, x/10, x/10, x/100 from generate_series(1,1000) x;
create unique index on fkest(x, x10, x100);
analyze fkest;
explain (costs off)
select * from fkest f1
  join fkest f2 on (f1.x = f2.x and f1.x10 = f2.x10b and f1.x100 = f2.x100)
  join fkest f3 on f1.x = f3.x
  where f1.x100 = 2;
                        QUERY PLAN                         
-----------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: ((fkest_1.x = fkest_2.x) AND (fkest_1.x10b = fkest_2.x10) AND (fkest_1.x100 = fkest_2.x100))
         ->  Hash Join
               Hash Cond: (fkest.x = fkest_1.x)
               ->  Seq Scan on fkest
               ->  Hash
                     ->  Index Scan using fkest_x_x10_x100_idx on fkest fkest_1
                           Index Cond: (x100 = 2)
         ->  Hash
               ->  Index Scan using fkest_x_x10_x100_idx on fkest fkest_2
                     Index Cond: (x100 = 2)
 Optimizer: Postgres query optimizer
(13 rows)

alter table fkest add constraint fk
  foreign key (x, x10b, x100) references fkest (x, x10, x100);
explain (costs off)
select * from fkest f1
  join fkest f2 on (f1.x = f2.x and f1.x10 = f2.x10b and f1.x100 = f2.x100)
  join fkest f3 on f1.x = f3.x
  where f1.x100 = 2;
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: ((fkest_1.x = fkest_2.x) AND (fkest_1.x10b = fkest_2.x10) AND (fkest_1.x100 = fkest_2.x100))
         ->  Hash Join
               Hash Cond: (fkest.x = fkest_1.x)
               ->  Seq Scan on fkest
               ->  Hash
                     ->  Index Scan using fkest_x_x10_x100_idx on fkest fkest_1
                           Index Cond: (x100 = 2)
         ->  Hash
               ->  Index Scan using fkest_x_x10_x100_idx on fkest fkest_2
                     Index Cond: (x100 = 2)
 Optimizer: Postgres query optimizer
(13 rows)

rollback;
--
-- test that foreign key join estimation performs sanely for outer joins
--
begin;
-- GPDB: persuade the planner to choose same plan as in upstream.
set local enable_nestloop=on;
-- GPDB: in upstream, there's a unique index on 'c', but in GPDB you can't
-- have two unique indexes with no columns in common. Create it as normal
-- index instead, it doesn't affect the test.
create table fkest (a int, b int, c int, primary key(a,b));
create index fkest_c_key on fkest (c);
create table fkest1 (a int, b int, primary key(a,b));
-- GPDB: insert 10x as much data as in upstream, to further persuade
-- index scans. In GPDB, 1000 rows, as used in upstream test, fits in on
-- just one page on each segment, because of the larger block size.
insert into fkest select x/10, x%10, x from generate_series(1,1000*10) x;
insert into fkest1 select x/10, x%10 from generate_series(1,1000*10) x;
alter table fkest1
  add constraint fkest1_a_b_fkey foreign key (a,b) references fkest;
WARNING:  referential integrity (FOREIGN KEY) constraints are not supported in Cloudberry Database, will not be enforced
analyze fkest;
analyze fkest1;
explain (costs off)
select *
from fkest f
  left join fkest1 f1 on f.a = f1.a and f.b = f1.b
  left join fkest1 f2 on f.a = f2.a and f.b = f2.b
  left join fkest1 f3 on f.a = f3.a and f.b = f3.b
where f.c = 1;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Nested Loop Left Join
               Join Filter: true
               ->  Nested Loop Left Join
                     Join Filter: true
                     ->  Index Scan using fkest_c_key on fkest
                           Index Cond: (c = 1)
                     ->  Index Scan using fkest1_pkey on fkest1
                           Index Cond: ((a = fkest.a) AND (b = fkest.b))
               ->  Index Scan using fkest1_pkey on fkest1 fkest1_1
                     Index Cond: ((a = fkest.a) AND (b = fkest.b))
         ->  Index Scan using fkest1_pkey on fkest1 fkest1_2
               Index Cond: ((a = fkest.a) AND (b = fkest.b))
 Optimizer: Pivotal Optimizer (GPORCA)
(16 rows)

rollback;
--
-- test planner's ability to mark joins as unique
--
create table j1 (id int primary key);
create table j2 (id int primary key);
create table j3 (id int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into j1 values(1),(2),(3);
insert into j2 values(1),(2),(3);
insert into j3 values(1),(1);
-- In GPDB, we need more data to make the plans match the upstream.
--
-- In particular, with just a handful of rows, a Seq Scan on j1 or j3 appear to
-- be 2x or 3x as expensive as a scan on j3, because on j3, all the rows reside
-- on the same segment, and hence the total size of the table is just one page,
-- whereas on j1 and j2 the rows are spread on different segments, and the
-- total table size is therefore 2 or 3 pages.
insert into j1 select g from generate_series(1000,1100) g;
insert into j2 select g from generate_series(1000,1100) g;
insert into j3 select 1000 from generate_series(1000,1100) g;
analyze j1;
analyze j2;
analyze j3;
-- ensure join is properly marked as unique
explain (verbose, costs off)
select * from j1 inner join j2 on j1.id = j2.id;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: j1.id, j2.id
   ->  Hash Join
         Output: j1.id, j2.id
         Hash Cond: (j1.id = j2.id)
         ->  Seq Scan on public.j1
               Output: j1.id
         ->  Hash
               Output: j2.id
               ->  Seq Scan on public.j2
                     Output: j2.id
 Optimizer: Pivotal Optimizer (GPORCA)
(12 rows)

-- ensure join is not unique when not an equi-join
explain (verbose, costs off)
select * from j1 inner join j2 on j1.id > j2.id;
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: j1.id, j2.id
   ->  Nested Loop
         Output: j1.id, j2.id
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               Output: j1.id
               ->  Seq Scan on public.j1
                     Output: j1.id
         ->  Index Only Scan using j2_pkey on public.j2
               Output: j2.id
               Index Cond: (j2.id < j1.id)
 Optimizer: Postgres query optimizer
(12 rows)

-- ensure non-unique rel is not chosen as inner
explain (verbose, costs off)
select * from j1 inner join j3 on j1.id = j3.id;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: j1.id, j3.id
   ->  Hash Join
         Output: j1.id, j3.id
         Hash Cond: (j3.id = j1.id)
         ->  Seq Scan on public.j3
               Output: j3.id
         ->  Hash
               Output: j1.id
               ->  Seq Scan on public.j1
                     Output: j1.id
 Optimizer: Pivotal Optimizer (GPORCA)
(12 rows)

-- ensure left join is marked as unique
explain (verbose, costs off)
select * from j1 left join j2 on j1.id = j2.id;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: j1.id, j2.id
   ->  Hash Left Join
         Output: j1.id, j2.id
         Hash Cond: (j1.id = j2.id)
         ->  Seq Scan on public.j1
               Output: j1.id
         ->  Hash
               Output: j2.id
               ->  Seq Scan on public.j2
                     Output: j2.id
 Optimizer: Pivotal Optimizer (GPORCA)
(12 rows)

-- ensure right join is marked as unique
explain (verbose, costs off)
select * from j1 right join j2 on j1.id = j2.id;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: j1.id, j2.id
   ->  Hash Left Join
         Output: j1.id, j2.id
         Hash Cond: (j2.id = j1.id)
         ->  Seq Scan on public.j2
               Output: j2.id
         ->  Hash
               Output: j1.id
               ->  Seq Scan on public.j1
                     Output: j1.id
 Optimizer: Pivotal Optimizer (GPORCA)
(12 rows)

-- ensure full join is marked as unique
explain (verbose, costs off)
select * from j1 full join j2 on j1.id = j2.id;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: j1.id, j2.id
   ->  Merge Full Join
         Output: j1.id, j2.id
         Merge Cond: (j1.id = j2.id)
         ->  Sort
               Output: j1.id
               Sort Key: j1.id
               ->  Seq Scan on public.j1
                     Output: j1.id
         ->  Sort
               Output: j2.id
               Sort Key: j2.id
               ->  Seq Scan on public.j2
                     Output: j2.id
 Optimizer: Pivotal Optimizer (GPORCA)
(16 rows)

-- a clauseless (cross) join can't be unique
explain (verbose, costs off)
select * from j1 cross join j2;
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: j1.id, j2.id
   ->  Nested Loop
         Output: j1.id, j2.id
         Join Filter: true
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               Output: j1.id
               ->  Seq Scan on public.j1
                     Output: j1.id
         ->  Seq Scan on public.j2
               Output: j2.id
 Optimizer: Pivotal Optimizer (GPORCA)
(12 rows)

-- ensure a natural join is marked as unique
explain (verbose, costs off)
select * from j1 natural join j2;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: j1.id
   ->  Hash Join
         Output: j1.id
         Hash Cond: (j1.id = j2.id)
         ->  Seq Scan on public.j1
               Output: j1.id
         ->  Hash
               Output: j2.id
               ->  Seq Scan on public.j2
                     Output: j2.id
 Optimizer: Pivotal Optimizer (GPORCA)
(12 rows)

-- ensure a distinct clause allows the inner to become unique
explain (verbose, costs off)
select * from j1
inner join (select distinct id from j3) j3 on j1.id = j3.id;
                  QUERY PLAN                   
-----------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: j1.id, j3.id
   ->  Hash Join
         Output: j1.id, j3.id
         Inner Unique: true
         Hash Cond: (j1.id = j3.id)
         ->  Seq Scan on public.j1
               Output: j1.id
         ->  Hash
               Output: j3.id
               ->  HashAggregate
                     Output: j3.id
                     Group Key: j3.id
                     ->  Seq Scan on public.j3
                           Output: j3.id
 Optimizer: Postgres query optimizer
(16 rows)

-- ensure group by clause allows the inner to become unique
explain (verbose, costs off)
select * from j1
inner join (select id from j3 group by id) j3 on j1.id = j3.id;
                  QUERY PLAN                   
-----------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: j1.id, j3.id
   ->  Hash Join
         Output: j1.id, j3.id
         Inner Unique: true
         Hash Cond: (j1.id = j3.id)
         ->  Seq Scan on public.j1
               Output: j1.id
         ->  Hash
               Output: j3.id
               ->  HashAggregate
                     Output: j3.id
                     Group Key: j3.id
                     ->  Seq Scan on public.j3
                           Output: j3.id
 Optimizer: Postgres query optimizer
(16 rows)

drop table j1;
drop table j2;
drop table j3;
-- test more complex permutations of unique joins
create table j1 (id1 int, id2 int, primary key(id1,id2));
create table j2 (id1 int, id2 int, primary key(id1,id2));
create table j3 (id1 int, id2 int, primary key(id1,id2));
insert into j1 values(1,1),(1,2);
insert into j2 values(1,1);
insert into j3 values(1,1);
analyze j1;
analyze j2;
analyze j3;
-- ensure there's no unique join when not all columns which are part of the
-- unique index are seen in the join clause
explain (verbose, costs off)
select * from j1
inner join j2 on j1.id1 = j2.id1;
                            QUERY PLAN                            
------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: j1.id1, j1.id2, j2.id1, j2.id2
   ->  Hash Join
         Output: j1.id1, j1.id2, j2.id1, j2.id2
         Hash Cond: (j1.id1 = j2.id1)
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Output: j1.id1, j1.id2
               Hash Key: j1.id1
               ->  Seq Scan on public.j1
                     Output: j1.id1, j1.id2
         ->  Hash
               Output: j2.id1, j2.id2
               ->  Redistribute Motion 3:3  (slice3; segments: 3)
                     Output: j2.id1, j2.id2
                     Hash Key: j2.id1
                     ->  Seq Scan on public.j2
                           Output: j2.id1, j2.id2
 Optimizer: Postgres query optimizer
(18 rows)

-- ensure proper unique detection with multiple join quals
explain (verbose, costs off)
select * from j1
inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2;
                          QUERY PLAN                          
--------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: j1.id1, j1.id2, j2.id1, j2.id2
   ->  Hash Join
         Output: j1.id1, j1.id2, j2.id1, j2.id2
         Inner Unique: true
         Hash Cond: ((j1.id1 = j2.id1) AND (j1.id2 = j2.id2))
         ->  Seq Scan on public.j1
               Output: j1.id1, j1.id2
         ->  Hash
               Output: j2.id1, j2.id2
               ->  Seq Scan on public.j2
                     Output: j2.id1, j2.id2
 Optimizer: Postgres query optimizer
(13 rows)

-- ensure we don't detect the join to be unique when quals are not part of the
-- join condition
set enable_nestloop=on;
explain (verbose, costs off)
select * from j1
inner join j2 on j1.id1 = j2.id1 where j1.id2 = 1;
                            QUERY PLAN                            
------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: j1.id1, j1.id2, j2.id1, j2.id2
   ->  Nested Loop
         Output: j1.id1, j1.id2, j2.id1, j2.id2
         Join Filter: (j1.id1 = j2.id1)
         ->  Seq Scan on public.j1
               Output: j1.id1, j1.id2
               Filter: (j1.id2 = 1)
         ->  Materialize
               Output: j2.id1, j2.id2
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Output: j2.id1, j2.id2
                     Hash Key: j2.id1, 1
                     ->  Seq Scan on public.j2
                           Output: j2.id1, j2.id2
 Settings: enable_nestloop = 'on'
 Optimizer: Postgres query optimizer
(17 rows)

-- as above, but for left joins.
explain (verbose, costs off)
select * from j1
left join j2 on j1.id1 = j2.id1 where j1.id2 = 1;
                      QUERY PLAN                      
------------------------------------------------------
 Hash Left Join
   Output: j1.id1, j1.id2, j2.id1, j2.id2
   Hash Cond: (j1.id1 = j2.id1)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: j1.id1, j1.id2
         ->  Index Scan using j1_pkey on public.j1
               Output: j1.id1, j1.id2
               Index Cond: (j1.id2 = 1)
   ->  Hash
         Output: j2.id1, j2.id2
         ->  Gather Motion 3:1  (slice2; segments: 3)
               Output: j2.id1, j2.id2
               ->  Seq Scan on public.j2
                     Output: j2.id1, j2.id2
 Optimizer: Pivotal Optimizer (GPORCA)
 Settings: enable_nestloop=on
(16 rows)

-- validate logic in merge joins which skips mark and restore.
-- it should only do this if all quals which were used to detect the unique
-- are present as join quals, and not plain quals.
set enable_nestloop to 0;
set enable_hashjoin to 0;
set enable_mergejoin to 1;
set enable_sort to 0;
-- create indexes that will be preferred over the PKs to perform the join
create index j1_id1_idx on j1 (id1) where id1 % 1000 = 1;
create index j2_id1_idx on j2 (id1) where id1 % 1000 = 1;
-- need an additional row in j2, if we want j2_id1_idx to be preferred
insert into j2 values(1,2);
analyze j2;
analyze j1; -- GPDB also needs this to get the same plan as in upstream
explain (costs off) select * from j1
inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1;
                  QUERY PLAN                   
-----------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (j1.id1 = j2.id1)
         Join Filter: (j1.id2 = j2.id2)
         ->  Index Scan using j1_id1_idx on j1
         ->  Index Scan using j2_id1_idx on j2
 Optimizer: Postgres query optimizer
(7 rows)

select * from j1
inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1;
 id1 | id2 | id1 | id2 
-----+-----+-----+-----
   1 |   1 |   1 |   1
   1 |   2 |   1 |   2
(2 rows)

-- Exercise array keys mark/restore B-Tree code
explain (costs off) select * from j1
inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1 and j2.id1 = any (array[1]);
                        QUERY PLAN                        
----------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (j1.id1 = j2.id1)
         Join Filter: (j1.id2 = j2.id2)
         ->  Index Scan using j1_id1_idx on j1
               Index Cond: (id1 = ANY ('{1}'::integer[]))
         ->  Index Scan using j2_id1_idx on j2
               Index Cond: (id1 = ANY ('{1}'::integer[]))
 Optimizer: Postgres query optimizer
(9 rows)

select * from j1
inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1 and j2.id1 = any (array[1]);
 id1 | id2 | id1 | id2 
-----+-----+-----+-----
   1 |   1 |   1 |   1
   1 |   2 |   1 |   2
(2 rows)

-- Exercise array keys "find extreme element" B-Tree code
explain (costs off) select * from j1
inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1 and j2.id1 >= any (array[1,5]);
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: ((j1.id1 = j2.id1) AND (j1.id2 = j2.id2))
         ->  Index Only Scan using j1_pkey on j1
               Index Cond: (id1 >= ANY ('{1,5}'::integer[]))
               Filter: ((id1 % 1000) = 1)
         ->  Index Only Scan using j2_pkey on j2
               Index Cond: (id1 >= ANY ('{1,5}'::integer[]))
               Filter: ((id1 % 1000) = 1)
 Optimizer: Postgres query optimizer
(10 rows)

select * from j1
inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1 and j2.id1 >= any (array[1,5]);
 id1 | id2 | id1 | id2 
-----+-----+-----+-----
   1 |   1 |   1 |   1
   1 |   2 |   1 |   2
(2 rows)

reset enable_nestloop;
reset enable_hashjoin;
reset enable_sort;
drop table j1;
drop table j2;
drop table j3;
-- check that semijoin inner is not seen as unique for a portion of the outerrel
set enable_hashjoin = off;
set enable_nestloop = on;
set enable_seqscan = off;
set enable_bitmapscan = off;
analyze onek;
explain (verbose, costs off)
select t1.unique1, t2.hundred
from onek t1, tenk1 t2
where exists (select 1 from tenk1 t3
              where t3.thousand = t1.unique1 and t3.tenthous = t2.hundred)
      and t1.unique1 < 1;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: onek.unique1, tenk1.hundred
   ->  Hash Semi Join
         Output: onek.unique1, tenk1.hundred
         Hash Cond: ((onek.unique1 = tenk1_1.thousand) AND (tenk1.hundred = tenk1_1.tenthous))
         ->  Nested Loop
               Output: onek.unique1, tenk1.hundred
               Join Filter: true
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     Output: onek.unique1
                     ->  Index Only Scan using onek_unique1 on public.onek
                           Output: onek.unique1
                           Index Cond: (onek.unique1 < 1)
               ->  Seq Scan on public.tenk1
                     Output: tenk1.hundred
         ->  Hash
               Output: tenk1_1.thousand, tenk1_1.tenthous
               ->  Broadcast Motion 3:3  (slice3; segments: 3)
                     Output: tenk1_1.thousand, tenk1_1.tenthous
                     ->  Index Only Scan using tenk1_thous_tenthous on public.tenk1 tenk1_1
                           Output: tenk1_1.thousand, tenk1_1.tenthous
                           Index Cond: (tenk1_1.thousand < 1)
 Optimizer: Pivotal Optimizer (GPORCA)
 Settings: enable_bitmapscan=off, enable_hashjoin=off, enable_mergejoin=on, enable_nestloop=on, enable_seqscan=off
(24 rows)

-- ... unless it actually is unique
create table j3 as select unique1, tenthous from onek;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause. Creating a NULL policy entry.
vacuum analyze j3;
create unique index on j3(unique1, tenthous);
ERROR:  UNIQUE and DISTRIBUTED RANDOMLY are incompatible
explain (verbose, costs off)
select t1.unique1, t2.hundred
from onek t1, tenk1 t2
where exists (select 1 from j3
              where j3.unique1 = t1.unique1 and j3.tenthous = t2.hundred)
      and t1.unique1 < 1;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: onek.unique1, tenk1.hundred
   ->  Hash Semi Join
         Output: onek.unique1, tenk1.hundred
         Hash Cond: ((onek.unique1 = j3.unique1) AND (tenk1.hundred = j3.tenthous))
         ->  Nested Loop
               Output: onek.unique1, tenk1.hundred
               Join Filter: true
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     Output: onek.unique1
                     ->  Index Only Scan using onek_unique1 on public.onek
                           Output: onek.unique1
                           Index Cond: (onek.unique1 < 1)
               ->  Seq Scan on public.tenk1
                     Output: tenk1.hundred
         ->  Hash
               Output: j3.unique1, j3.tenthous
               ->  Broadcast Motion 3:3  (slice3; segments: 3)
                     Output: j3.unique1, j3.tenthous
                     ->  Seq Scan on public.j3
                           Output: j3.unique1, j3.tenthous
                           Filter: (j3.unique1 < 1)
 Optimizer: Pivotal Optimizer (GPORCA)
 Settings: enable_bitmapscan=off, enable_hashjoin=off, enable_mergejoin=on, enable_nestloop=on, enable_seqscan=off
(24 rows)

drop table j3;
reset enable_hashjoin;
reset enable_nestloop;
reset enable_seqscan;
reset enable_bitmapscan;
