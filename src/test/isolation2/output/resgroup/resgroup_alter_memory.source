-- start_ignore
DROP ROLE IF EXISTS role1_memory_test;
DROP
DROP ROLE IF EXISTS role2_memory_test;
DROP
DROP RESOURCE GROUP rg1_memory_test;
ERROR:  resource group "rg1_memory_test" does not exist
DROP RESOURCE GROUP rg2_memory_test;
ERROR:  resource group "rg2_memory_test" does not exist
-- end_ignore

CREATE OR REPLACE FUNCTION resGroupPalloc(float) RETURNS int AS '@abs_builddir@/../regress/regress@DLSUFFIX@', 'resGroupPalloc' LANGUAGE C READS SQL DATA;
CREATE

CREATE OR REPLACE FUNCTION hold_memory_by_percent(int, float) RETURNS int AS $$ SELECT * FROM resGroupPalloc($2) $$ LANGUAGE sql;
CREATE

-- After a 'q' command the client connection is disconnected but the
-- QD may still be alive, if we then query pg_stat_activity quick enough
-- we might still see this session with current_query '<IDLE>'.
-- A filter is put to filter out this kind of quitted sessions.
CREATE OR REPLACE VIEW rg_activity_status AS SELECT rsgname, waiting_reason, current_query FROM pg_stat_activity WHERE rsgname in ('rg1_memory_test', 'rg2_memory_test') AND current_query <> '<IDLE>' ORDER BY sess_id;
CREATE

CREATE OR REPLACE VIEW rg_mem_status AS SELECT groupname, memory_limit, proposed_memory_limit, memory_shared_quota, proposed_memory_shared_quota FROM gp_toolkit.gp_resgroup_config WHERE groupname='rg1_memory_test' OR groupname='rg2_memory_test' ORDER BY groupid;
CREATE

CREATE RESOURCE GROUP rg1_memory_test WITH (concurrency=2, cpu_rate_limit=10, memory_limit=60, memory_shared_quota=0, memory_spill_ratio=5);
CREATE
CREATE ROLE role1_memory_test RESOURCE GROUP rg1_memory_test;
CREATE

--
-- 1.1) alter memory shared quota with low memory usage
--

ALTER RESOURCE GROUP rg1_memory_test SET CONCURRENCY 2;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_LIMIT 60;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_SHARED_QUOTA 50;
ALTER

SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|60          |60                   |50                 |50                          
(1 row)

1: SET ROLE TO role1_memory_test;
SET
1: BEGIN;
BEGIN
1: SELECT hold_memory_by_percent(1,0.1);
hold_memory_by_percent
----------------------
0                     
(1 row)
-- proc 1 gets a quota of 60%*50%/2=15%
-- it has consumed 60%*10%=6%
-- the group has 60%*50%-15%=15% free quota and 60%*50%=30% free shared quota

ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_SHARED_QUOTA 20;
ALTER

-- now the group has 60%*80%-15%=33% free quota and 60%*20%=12% free shared quota,
-- so memory_shared_quota shall be the new value.
SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|60          |60                   |20                 |20                          
(1 row)

ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_SHARED_QUOTA 70;
ALTER

-- now the group has 60%*30%-15%=3% free quota and 60%*70%=42% free shared quota,
-- so memory_shared_quota shall be the new value.
SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|60          |60                   |70                 |70                          
(1 row)

--
-- 1.2) alter memory shared quota with high memory usage
--

ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_SHARED_QUOTA 80;
ALTER

-- now the group has 60%*20%-15%=-3% free quota and 60%*80%=48% free shared quota,
-- so memory_shared_quota shall be the old value.
SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|60          |60                   |80                 |80                          
(1 row)

1q: ... <quitting>

--
-- 1.3) alter memory shared quota up and down
--

ALTER RESOURCE GROUP rg1_memory_test SET CONCURRENCY 2;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_LIMIT 40;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_SHARED_QUOTA 60;
ALTER

SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|40          |40                   |60                 |60                          
(1 row)

1: SET ROLE TO role1_memory_test;
SET
1: BEGIN;
BEGIN
-- proc1 has a quota of 40%*40%/2=8%
-- rg1 still have 8% free quota

ALTER RESOURCE GROUP rg1_memory_test SET CONCURRENCY 4;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_SHARED_QUOTA 70;
ALTER
-- rg1 should free some quota, 40%*40%/2*1-40%*30%/4*3=8%-9%=-1%
-- rg1 now have 40%*20%=8% free quota
-- each slot in rg1 requires 40%*30%/4=3%

2: SET ROLE TO role1_memory_test;
SET
2: BEGIN;
BEGIN
3: SET ROLE TO role1_memory_test;
SET
3: BEGIN;
BEGIN
-- proc2&proc3 each requires a quota of 40%*30%/4=3%
-- rg1 now has 8%-3%*2=2% free quota

4: SET ROLE TO role1_memory_test;
SET
4&: BEGIN;  <waiting ...>
-- proc4 shall be pending

SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|40          |40                   |70                 |70                          
(1 row)
SELECT * FROM rg_activity_status;
rsgname        |waiting_reason|current_query        
---------------+--------------+---------------------
rg1_memory_test|              |<IDLE> in transaction
rg1_memory_test|              |<IDLE> in transaction
rg1_memory_test|              |<IDLE> in transaction
rg1_memory_test|resgroup      |BEGIN;               
(4 rows)

ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_SHARED_QUOTA 40;
ALTER
-- rg1 now have 40%*60%-8%-3%*2=10% free quota again
-- and now proc4 requires a quota of 40%*60%/4=6%,
-- so it shall be waken up

4<:  <... completed>
BEGIN
SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|40          |40                   |40                 |40                          
(1 row)
SELECT * FROM rg_activity_status;
rsgname        |waiting_reason|current_query        
---------------+--------------+---------------------
rg1_memory_test|              |<IDLE> in transaction
rg1_memory_test|              |<IDLE> in transaction
rg1_memory_test|              |<IDLE> in transaction
rg1_memory_test|              |<IDLE> in transaction
(4 rows)

1q: ... <quitting>
2q: ... <quitting>
3q: ... <quitting>
4q: ... <quitting>

--
-- 2.1) alter memory limit with low memory usage (and low memory shared usage)
--

ALTER RESOURCE GROUP rg1_memory_test SET CONCURRENCY 2;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_LIMIT 50;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_SHARED_QUOTA 60;
ALTER

SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|50          |50                   |60                 |60                          
(1 row)

1: SET ROLE TO role1_memory_test;
SET
1: BEGIN;
BEGIN
1: SELECT hold_memory_by_percent(1,0.1);
hold_memory_by_percent
----------------------
0                     
(1 row)
-- proc 1 gets a quota of 50%*40%/2=10%
-- it has consumed 50%*10%=5%
-- the group has 50%*40%-10%=10% free quota and 50%*60%=30% free shared quota

ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_LIMIT 60;
ALTER

-- now the group has 60%*40%-10%=14% free quota and 60%*60%=36% free shared quota,
-- so memory_limit can be the new value, however at the moment we don't update
-- value when increasing memory_limit, so it's still the old value.
SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|60          |60                   |60                 |60                          
(1 row)

ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_LIMIT 40;
ALTER

-- now the group has 40%*40%-10%=6% free quota and 40%*60%=24% free shared quota,
-- so memory_limit shall be the new value.
SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|40          |40                   |60                 |60                          
(1 row)

--
-- 2.2) alter memory limit with high memory usage and low memory shared usage
--

ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_LIMIT 10;
ALTER

-- now the group has 10%*40%-10%=-6% free quota and 10%*60%=6% free shared quota,
-- so memory_limit shall be the old value.
SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|10          |10                   |60                 |60                          
(1 row)

--
-- 2.3) alter memory limit with high memory usage and high memory shared usage
--

ALTER RESOURCE GROUP rg1_memory_test SET CONCURRENCY 2;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_LIMIT 40;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_SHARED_QUOTA 60;
ALTER

-- now the group has 40%*40%-10%=6% free quota and 40%*60%=24% free shared quota,
SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|40          |40                   |60                 |60                          
(1 row)

1: SELECT hold_memory_by_percent(1,0.5);
hold_memory_by_percent
----------------------
0                     
(1 row)
-- proc 1 has consumed another 50%*50%=25%, in total 30%
-- now it has consumed all its 10% quota, as well as 20% shared quota
-- now the group has 40%*40%-10%=6% free quota and 40%*60%-20%=4% free shared quota,

ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_SHARED_QUOTA 20;
ALTER

-- now the group has 40%*80%-10%=22% free quota and 40%*20%-20%=-12% free shared quota,
-- so memory_shared_quota shall be the old value.
SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|40          |40                   |20                 |20                          
(1 row)

ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_LIMIT 30;
ALTER

-- now the group has 30%*80%-10%=14% free quota and 30%*20%-20%=-14% free shared quota,
-- so memory_limit shall be the old value.
SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|30          |30                   |20                 |20                          
(1 row)

1q: ... <quitting>

--
-- 3.1) decrease one group and increase another, no load
--

ALTER RESOURCE GROUP rg1_memory_test SET CONCURRENCY 3;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_LIMIT 30;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_SHARED_QUOTA 0;
ALTER

CREATE RESOURCE GROUP rg2_memory_test WITH (concurrency=3, cpu_rate_limit=10, memory_limit=30, memory_shared_quota=0, memory_spill_ratio=5);
CREATE
CREATE ROLE role2_memory_test RESOURCE GROUP rg2_memory_test;
CREATE

-- default_group and admin_group consumed 40% memory_limit,
-- so with rg1+rg2=60% all memory_limit is already allocated,
-- so increasing any of them shall fail.
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_LIMIT 31;
ERROR:  total memory_limit exceeded the limit of 100

SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|30          |30                   |0                  |0                           
rg2_memory_test|30          |30                   |0                  |0                           
(2 rows)

-- but increase could succeed if another rg is first decreased.
ALTER RESOURCE GROUP rg2_memory_test SET MEMORY_LIMIT 20;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_LIMIT 40;
ALTER

SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|40          |40                   |0                  |0                           
rg2_memory_test|20          |20                   |0                  |0                           
(2 rows)

--
-- 3.2) decrease one group and increase another, with load, no pending
--

ALTER RESOURCE GROUP rg1_memory_test SET CONCURRENCY 3;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_LIMIT 30;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_SHARED_QUOTA 0;
ALTER

ALTER RESOURCE GROUP rg2_memory_test SET CONCURRENCY 2;
ALTER
ALTER RESOURCE GROUP rg2_memory_test SET MEMORY_LIMIT 30;
ALTER
ALTER RESOURCE GROUP rg2_memory_test SET MEMORY_SHARED_QUOTA 0;
ALTER

SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|30          |30                   |0                  |0                           
rg2_memory_test|30          |30                   |0                  |0                           
(2 rows)

11: SET ROLE TO role1_memory_test;
SET
11: BEGIN;
BEGIN
-- proc11 gets a quota of 30%/3=10% from rg1

12: SET ROLE TO role1_memory_test;
SET
12: BEGIN;
BEGIN
-- proc12 gets a quota of 30%/3=10% from rg1

13: SET ROLE TO role1_memory_test;
SET
13: BEGIN;
BEGIN
-- proc13 gets a quota of 30%/3=10% from rg1

-- although all the memory quota is in use,
-- it's still allowed to decrease memory_limit,
-- in such a case rg2 won't get the new quota until any query in rg1 ends.
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_LIMIT 15;
ALTER
ALTER RESOURCE GROUP rg2_memory_test SET MEMORY_LIMIT 40;
ALTER
-- now both rg1 and rg2 still have 30% quota

21: SET ROLE TO role2_memory_test;
SET
21: BEGIN;
BEGIN
-- proc21 gets a quota of 40%/2=20% from rg2

SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|15          |15                   |0                  |0                           
rg2_memory_test|40          |40                   |0                  |0                           
(2 rows)
SELECT * FROM rg_activity_status;
rsgname        |waiting_reason|current_query        
---------------+--------------+---------------------
rg1_memory_test|              |<IDLE> in transaction
rg1_memory_test|              |<IDLE> in transaction
rg1_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
(4 rows)

11q: ... <quitting>
-- proc11 ends, 10%-5%=5% quota is returned to sys

12q: ... <quitting>
-- proc12 ends, 10%-5%=5% quota is returned to sys

SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|15          |15                   |0                  |0                           
rg2_memory_test|40          |40                   |0                  |0                           
(2 rows)
SELECT * FROM rg_activity_status;
rsgname        |waiting_reason|current_query        
---------------+--------------+---------------------
rg1_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
(2 rows)

-- now rg2 shall be able to get 10% free quota from sys
22: SET ROLE TO role2_memory_test;
SET
22: BEGIN;
BEGIN
-- proc22 gets a quota of 40%/2=20% from rg2

SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|15          |15                   |0                  |0                           
rg2_memory_test|40          |40                   |0                  |0                           
(2 rows)
SELECT * FROM rg_activity_status;
rsgname        |waiting_reason|current_query        
---------------+--------------+---------------------
rg1_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
(3 rows)

13q: ... <quitting>
21q: ... <quitting>
22q: ... <quitting>

--
-- 3.3) decrease one group and increase another, with load, with pending,
--      memory_shared_quota is 0,
--      waken up by released quota memory from other group
--

ALTER RESOURCE GROUP rg2_memory_test SET CONCURRENCY 2;
ALTER
ALTER RESOURCE GROUP rg2_memory_test SET MEMORY_LIMIT 30;
ALTER
ALTER RESOURCE GROUP rg2_memory_test SET MEMORY_SHARED_QUOTA 0;
ALTER

ALTER RESOURCE GROUP rg1_memory_test SET CONCURRENCY 3;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_LIMIT 30;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_SHARED_QUOTA 0;
ALTER

SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|30          |30                   |0                  |0                           
rg2_memory_test|30          |30                   |0                  |0                           
(2 rows)

11: SET ROLE TO role1_memory_test;
SET
11: BEGIN;
BEGIN
-- proc11 gets a quota of 30%/3=10% from rg1

12: SET ROLE TO role1_memory_test;
SET
12: BEGIN;
BEGIN
-- proc12 gets a quota of 30%/3=10% from rg1

13: SET ROLE TO role1_memory_test;
SET
13: BEGIN;
BEGIN
-- proc13 gets a quota of 30%/3=10% from rg1

-- although all the memory quota is in use,
-- it's still allowed to decrease memory_limit,
-- in such a case rg2 won't get the new quota until any query in rg1 ends.
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_LIMIT 15;
ALTER
ALTER RESOURCE GROUP rg2_memory_test SET MEMORY_LIMIT 40;
ALTER
-- now both rg1 and rg2 still have 30% quota

21: SET ROLE TO role2_memory_test;
SET
21: BEGIN;
BEGIN

22: SET ROLE TO role2_memory_test;
SET
22&: BEGIN;  <waiting ...>

-- proc21 gets a quota of 40%/2=20% from rg2
-- proc22 requires a quota of 40%/2=20% from rg2,
-- but as rg2 only has 30%-20%=10% free quota now,
-- it shall be pending.
SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|15          |15                   |0                  |0                           
rg2_memory_test|40          |40                   |0                  |0                           
(2 rows)
SELECT * FROM rg_activity_status;
rsgname        |waiting_reason|current_query        
---------------+--------------+---------------------
rg1_memory_test|              |<IDLE> in transaction
rg1_memory_test|              |<IDLE> in transaction
rg1_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
rg2_memory_test|resgroup      |BEGIN;               
(5 rows)

11: END;
END
11q: ... <quitting>
-- proc11 ends, 10%-5%=5% quota is returned to sys

SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|15          |15                   |0                  |0                           
rg2_memory_test|40          |40                   |0                  |0                           
(2 rows)
SELECT * FROM rg_activity_status;
rsgname        |waiting_reason|current_query        
---------------+--------------+---------------------
rg1_memory_test|              |<IDLE> in transaction
rg1_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
rg2_memory_test|resgroup      |BEGIN;               
(4 rows)

12: END;
END
12q: ... <quitting>
-- proc12 ends, 10%-5%=5% quota is returned to sys

-- now rg2 can get 10% free quota from sys
-- so proc22 can get enough quota and get executed
22<:  <... completed>
BEGIN
SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|15          |15                   |0                  |0                           
rg2_memory_test|40          |40                   |0                  |0                           
(2 rows)
SELECT * FROM rg_activity_status;
rsgname        |waiting_reason|current_query        
---------------+--------------+---------------------
rg1_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
(3 rows)

13q: ... <quitting>
21q: ... <quitting>
22q: ... <quitting>

--
-- 3.4) decrease one group and increase another, with load, with pending,
--      memory_shared_quota > 0 and can be freed,
--      waken up by released shared quota memory from other group
--

ALTER RESOURCE GROUP rg2_memory_test SET CONCURRENCY 2;
ALTER
ALTER RESOURCE GROUP rg2_memory_test SET MEMORY_LIMIT 30;
ALTER
ALTER RESOURCE GROUP rg2_memory_test SET MEMORY_SHARED_QUOTA 0;
ALTER

ALTER RESOURCE GROUP rg1_memory_test SET CONCURRENCY 1;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_LIMIT 30;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_SHARED_QUOTA 60;
ALTER

SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|30          |30                   |60                 |60                          
rg2_memory_test|30          |30                   |0                  |0                           
(2 rows)

11: SET ROLE TO role1_memory_test;
SET
11: BEGIN;
BEGIN
-- proc11 gets a quota of 30%*40%=12% from rg1
-- rg1 also has a shared quota of 30%*60%=18%

ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_LIMIT 20;
ALTER
-- now each slot in rg1 requires a quota of 20%*40%=8%
-- rg1 has 0% free quota and 20%*60%=12% free shared quota
-- rg1 should release some shared quota, 30%*60%-20%*60%=6%

ALTER RESOURCE GROUP rg2_memory_test SET CONCURRENCY 4;
ALTER
ALTER RESOURCE GROUP rg2_memory_test SET MEMORY_LIMIT 40;
ALTER
-- now rg2 has a quota of 30%+6%=36%
-- now each slot in rg2 requires a quota of 40%/4=10%

21: SET ROLE TO role2_memory_test;
SET
21: BEGIN;
BEGIN
22: SET ROLE TO role2_memory_test;
SET
22: BEGIN;
BEGIN
23: SET ROLE TO role2_memory_test;
SET
23: BEGIN;
BEGIN
-- proc21~proc23 each gets a quota of 40%/4=10%
-- rg2 still has 36%-10%*3=6% free quota

24: SET ROLE TO role2_memory_test;
SET
24&: BEGIN;  <waiting ...>
-- proc24 shall be pending.

SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|20          |20                   |60                 |60                          
rg2_memory_test|40          |40                   |0                  |0                           
(2 rows)
SELECT * FROM rg_activity_status;
rsgname        |waiting_reason|current_query        
---------------+--------------+---------------------
rg1_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
rg2_memory_test|resgroup      |BEGIN;               
(5 rows)

ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_SHARED_QUOTA 30;
ALTER
-- now rg1 should release some shared quota, 20%*60%-20%*30%=6%
-- now rg2 can get at most 6% new quota, but as it already has 36%,
-- so rg2 actually gets 4% new quota.
-- now rg2 has 40% quota, the free quota is 40%-30%=10%,
-- just enough for proc24 to wake up.

24<:  <... completed>
BEGIN
SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|20          |20                   |30                 |30                          
rg2_memory_test|40          |40                   |0                  |0                           
(2 rows)
SELECT * FROM rg_activity_status;
rsgname        |waiting_reason|current_query        
---------------+--------------+---------------------
rg1_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
(5 rows)

11q: ... <quitting>
21q: ... <quitting>
22q: ... <quitting>
23q: ... <quitting>
24q: ... <quitting>

--
-- 3.5) decrease one group and increase another, with load, with pending
--      memory_shared_quota > 0 and can not be freed,
--      waken up by released quota memory from other group
--

ALTER RESOURCE GROUP rg2_memory_test SET CONCURRENCY 2;
ALTER
ALTER RESOURCE GROUP rg2_memory_test SET MEMORY_LIMIT 30;
ALTER
ALTER RESOURCE GROUP rg2_memory_test SET MEMORY_SHARED_QUOTA 0;
ALTER

ALTER RESOURCE GROUP rg1_memory_test SET CONCURRENCY 10;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_LIMIT 30;
ALTER
ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_SHARED_QUOTA 90;
ALTER

SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|30          |30                   |90                 |90                          
rg2_memory_test|30          |30                   |0                  |0                           
(2 rows)

11: SET ROLE TO role1_memory_test;
SET
11: BEGIN;
BEGIN
11: SELECT hold_memory_by_percent(1,0.90);
hold_memory_by_percent
----------------------
0                     
(1 row)
-- proc11 gets a quota of 30%*10%/10=0.3% from rg1
-- rg1 has a free quota of 30%*10%-0.3%=2.7%
-- rg1 has a shared quota of 30%*90%=27%,
--     free shared quota is 27%-(30%*90%-0.3%)=0.3%

ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_LIMIT 20;
ALTER
-- now each slot in rg1 requires a quota of 20%*10%/10=0.2%
-- rg1 releases some quota, 0.1%*9=0.9%,
--     so new quota is 2.1%, new free quota is 2.1%-0.3%=1.8%
-- rg1 releases some shared quota, 27%-max(20%*90%,26.7%)=0.3%,
--     so new shared quota is 26.7%, new free shared quota is 0%

ALTER RESOURCE GROUP rg2_memory_test SET CONCURRENCY 4;
ALTER
ALTER RESOURCE GROUP rg2_memory_test SET MEMORY_LIMIT 40;
ALTER
-- now rg2 has a quota of 30%+1.2%=31.2%
-- now each slot in rg2 requires a quota of 40%/4=10%

21: SET ROLE TO role2_memory_test;
SET
21: BEGIN;
BEGIN
22: SET ROLE TO role2_memory_test;
SET
22: BEGIN;
BEGIN
23: SET ROLE TO role2_memory_test;
SET
23: BEGIN;
BEGIN
-- proc21~proc23 each gets a quota of 40%/4=10%
-- rg2 still has 31.2%-10%*3=1.2% free quota

24: SET ROLE TO role2_memory_test;
SET
24&: BEGIN;  <waiting ...>
-- proc24 shall be pending.

SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|20          |20                   |90                 |90                          
rg2_memory_test|40          |40                   |0                  |0                           
(2 rows)
SELECT * FROM rg_activity_status;
rsgname        |waiting_reason|current_query        
---------------+--------------+---------------------
rg1_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
rg2_memory_test|resgroup      |BEGIN;               
(5 rows)

ALTER RESOURCE GROUP rg1_memory_test SET MEMORY_SHARED_QUOTA 30;
ALTER
-- rg1 can't free any shared quota as all of them are in use by proc11

SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|20          |20                   |30                 |30                          
rg2_memory_test|40          |40                   |0                  |0                           
(2 rows)
SELECT * FROM rg_activity_status;
rsgname        |waiting_reason|current_query        
---------------+--------------+---------------------
rg1_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
rg2_memory_test|resgroup      |BEGIN;               
(5 rows)

11q: ... <quitting>
-- rg1 releases 0.3%-0.2%=0.1% quota and 26.7%-18%=8.7%
-- so rg2 gets 8.8% new quota
-- now rg2 has 40% quota, free quota is 10%
-- so proc24 shall be waken up

24<:  <... completed>
BEGIN
SELECT * FROM rg_mem_status;
groupname      |memory_limit|proposed_memory_limit|memory_shared_quota|proposed_memory_shared_quota
---------------+------------+---------------------+-------------------+----------------------------
rg1_memory_test|20          |20                   |30                 |30                          
rg2_memory_test|40          |40                   |0                  |0                           
(2 rows)
SELECT * FROM rg_activity_status;
rsgname        |waiting_reason|current_query        
---------------+--------------+---------------------
rg2_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
rg2_memory_test|              |<IDLE> in transaction
(4 rows)

21q: ... <quitting>
22q: ... <quitting>
23q: ... <quitting>
24q: ... <quitting>

-- cleanup
DROP VIEW rg_mem_status;
DROP
DROP ROLE role1_memory_test;
DROP
DROP ROLE role2_memory_test;
DROP
DROP RESOURCE GROUP rg1_memory_test;
DROP
DROP RESOURCE GROUP rg2_memory_test;
DROP

--
-- Test PrepareTransaction report an error
--
CREATE OR REPLACE FUNCTION getSelfRGCapability(cstring) RETURNS int AS '@abs_builddir@/../regress/regress@DLSUFFIX@', 'getSelfRGCapability' LANGUAGE C READS SQL DATA;
CREATE
CREATE RESOURCE GROUP rg_test_group WITH (cpu_rate_limit=5, memory_limit=5);
CREATE
CREATE ROLE rg_test_role RESOURCE GROUP rg_test_group;
CREATE

SET debug_dtm_action = "fail_begin_command";
SET
SET debug_dtm_action_target = "protocol";
SET
SET debug_dtm_action_protocol = "prepare";
SET
SET debug_dtm_action_segment = 0;
SET

-- ALTER should fail and the memory_limit in both catalog and share memory are
-- still 5%
ALTER RESOURCE GROUP rg_test_group set memory_limit 1;
ERROR:  The distributed transaction 'Prepare' broadcast failed to one or more segments for gid = 1509599543-0000000983. (cdbtm.c:698)

RESET debug_dtm_action;
RESET
RESET debug_dtm_action_target;
RESET
RESET debug_dtm_action_protocol;
RESET
RESET debug_dtm_action_segment;
RESET

-- should still be 5% on both QD and QE
select memory_limit from gp_toolkit.gp_resgroup_config where groupname = 'rg_test_group';
memory_limit
------------
5           
(1 row)
SET ROLE rg_test_role;
SET
select getSelfRGCapability('memory_limit');
getselfrgcapability
-------------------
5                 
(1 row)
select getSelfRGCapability('memory_limit') from gp_dist_random('gp_id');
getselfrgcapability
-------------------
5                 
5                 
5                 
(3 rows)

SET ROLE none;
SET

--
-- Test error happen on commit_prepare, DDL success after retry
--
SET debug_dtm_action = "fail_begin_command";
SET
SET debug_dtm_action_target = "protocol";
SET
SET debug_dtm_action_protocol = "commit_prepared";
SET
SET debug_dtm_action_segment = 0;
SET

-- ALTER should success
ALTER RESOURCE GROUP rg_test_group set memory_limit 4;
ALTER

RESET debug_dtm_action;
RESET
RESET debug_dtm_action_target;
RESET
RESET debug_dtm_action_protocol;
RESET
RESET debug_dtm_action_segment;
RESET

-- should still be 4% on both QD and QE
select memory_limit from gp_toolkit.gp_resgroup_config where groupname = 'rg_test_group';
memory_limit
------------
4           
(1 row)
SET ROLE rg_test_role;
SET
select getSelfRGCapability('memory_limit');
getselfrgcapability
-------------------
4                 
(1 row)
select getSelfRGCapability('memory_limit') from gp_dist_random('gp_id');
getselfrgcapability
-------------------
4                 
4                 
4                 
(3 rows)

SET ROLE none;
SET
DROP ROLE rg_test_role;
DROP
DROP RESOURCE GROUP rg_test_group;
DROP
