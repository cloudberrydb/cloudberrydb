-- If we enable the GDD, then the lock maybe downgrade to
-- RowExclusiveLock, so UPDATE/Delete can be executed
-- concurrently, it may trigger the EvalPlanQual function
-- to recheck the qualifications.
-- If the subPlan have Motion node, then we can not execute
-- EvalPlanQual correctly, so we raise an error when
-- GDD is enabled and EvalPlanQual is tiggered.

-- create heap table
0: show gp_enable_global_deadlock_detector;
 gp_enable_global_deadlock_detector 
------------------------------------
 off                                
(1 row)
0: create table tab_update_epq1 (c1 int, c2 int) distributed randomly;
CREATE
0: create table tab_update_epq2 (c1 int, c2 int) distributed randomly;
CREATE
0: insert into tab_update_epq1 values(1,1);
INSERT 1
0: insert into tab_update_epq2 values(1,1);
INSERT 1
0: select * from tab_update_epq1;
 c1 | c2 
----+----
 1  | 1  
(1 row)
0: select * from tab_update_epq2;
 c1 | c2 
----+----
 1  | 1  
(1 row)

1: set optimizer = off;
SET
2: set optimizer = off;
SET

-- test for heap table
1: begin;
BEGIN
2: begin;
BEGIN
1: update tab_update_epq1 set c1 = c1 + 1 where c2 = 1;
UPDATE 1
2&: update tab_update_epq1 set c1 = tab_update_epq1.c1 + 1 from tab_update_epq2 where tab_update_epq1.c2 = tab_update_epq2.c2;  <waiting ...>
1: end;
END
2<:  <... completed>
UPDATE 1
2: end;
END

0: select * from tab_update_epq1;
 c1 | c2 
----+----
 3  | 1  
(1 row)
0: drop table tab_update_epq1;
DROP
0: drop table tab_update_epq2;
DROP

-- create AO table
0: create table tab_update_epq1 (c1 int, c2 int) with(appendonly=true) distributed randomly;
CREATE
0: create table tab_update_epq2 (c1 int, c2 int) with(appendonly=true) distributed randomly;
CREATE
0: insert into tab_update_epq1 values(1,1);
INSERT 1
0: insert into tab_update_epq2 values(1,1);
INSERT 1
0: select * from tab_update_epq1;
 c1 | c2 
----+----
 1  | 1  
(1 row)
0: select * from tab_update_epq2;
 c1 | c2 
----+----
 1  | 1  
(1 row)

-- test for AO table
1: begin;
BEGIN
2: begin;
BEGIN
1: update tab_update_epq1 set c1 = c1 + 1 where c2 = 1;
UPDATE 1
2&: update tab_update_epq1 set c1 = tab_update_epq1.c1 + 1 from tab_update_epq2 where tab_update_epq1.c2 = tab_update_epq2.c2;  <waiting ...>
1: end;
END
2<:  <... completed>
UPDATE 1
2: end;
END

0: select * from tab_update_epq1;
 c1 | c2 
----+----
 3  | 1  
(1 row)
0: drop table tab_update_epq1;
DROP
0: drop table tab_update_epq2;
DROP
1q: ... <quitting>
2q: ... <quitting>
0q: ... <quitting>

-- enable gdd
-- start_ignore
! gpconfig -c gp_enable_global_deadlock_detector -v on;

! gpstop -rai;
-- end_ignore

-- create heap table
0: show gp_enable_global_deadlock_detector;
 gp_enable_global_deadlock_detector 
------------------------------------
 on                                 
(1 row)
0: create table tab_update_epq1 (c1 int, c2 int) distributed randomly;
CREATE
0: create table tab_update_epq2 (c1 int, c2 int) distributed randomly;
CREATE
0: insert into tab_update_epq1 values(1,1);
INSERT 1
0: insert into tab_update_epq2 values(1,1);
INSERT 1
0: select * from tab_update_epq1;
 c1 | c2 
----+----
 1  | 1  
(1 row)
0: select * from tab_update_epq2;
 c1 | c2 
----+----
 1  | 1  
(1 row)

1: set optimizer = off;
SET
2: set optimizer = off;
SET

-- test for heap table
1: begin;
BEGIN
2: begin;
BEGIN
1: update tab_update_epq1 set c1 = c1 + 1 where c2 = 1;
UPDATE 1
2&: update tab_update_epq1 set c1 = tab_update_epq1.c1 + 1 from tab_update_epq2 where tab_update_epq1.c2 = tab_update_epq2.c2;  <waiting ...>
1: end;
END
2<:  <... completed>
ERROR:  EvalPlanQual can not handle subPlan with Motion node  (seg1 127.0.0.1:25433 pid=34552)
2: end;
END

0: select * from tab_update_epq1;
 c1 | c2 
----+----
 2  | 1  
(1 row)
0: drop table tab_update_epq1;
DROP
0: drop table tab_update_epq2;
DROP

-- create AO table
0: create table tab_update_epq1 (c1 int, c2 int) with(appendonly=true) distributed randomly;
CREATE
0: create table tab_update_epq2 (c1 int, c2 int) with(appendonly=true) distributed randomly;
CREATE
0: insert into tab_update_epq1 values(1,1);
INSERT 1
0: insert into tab_update_epq2 values(1,1);
INSERT 1
0: select * from tab_update_epq1;
 c1 | c2 
----+----
 1  | 1  
(1 row)
0: select * from tab_update_epq2;
 c1 | c2 
----+----
 1  | 1  
(1 row)

-- test for AO table
1: begin;
BEGIN
2: begin;
BEGIN
1: update tab_update_epq1 set c1 = c1 + 1 where c2 = 1;
UPDATE 1
2&: update tab_update_epq1 set c1 = tab_update_epq1.c1 + 1 from tab_update_epq2 where tab_update_epq1.c2 = tab_update_epq2.c2;  <waiting ...>
1: end;
END
2<:  <... completed>
UPDATE 1
2: end;
END

0: select * from tab_update_epq1;
 c1 | c2 
----+----
 3  | 1  
(1 row)
0: drop table tab_update_epq1;
DROP
0: drop table tab_update_epq2;
DROP
1q: ... <quitting>
2q: ... <quitting>
0q: ... <quitting>

-- disable gdd
-- start_ignore
! gpconfig -c gp_enable_global_deadlock_detector -v off;

! gpstop -rai;
-- end_ignore
