-- start_ignore
DROP VIEW IF EXISTS cancel_all;
DROP ROLE IF EXISTS role1_cpu_test;
DROP ROLE IF EXISTS role2_cpu_test;
DROP RESOURCE GROUP rg1_cpu_test;
DROP RESOURCE GROUP rg2_cpu_test;

CREATE LANGUAGE plpython3u;
-- end_ignore

--
-- helper functions, tables and views
--

DROP TABLE IF EXISTS cpu_usage_samples;
CREATE TABLE cpu_usage_samples (sample text);

-- fetch_sample: select cpu_usage from gp_toolkit.gp_resgroup_status
-- and dump them into text in json format then save them in db for
-- further analysis.
CREATE OR REPLACE FUNCTION fetch_sample() RETURNS text AS $$
    import json

    group_cpus = plpy.execute('''
        SELECT rsgname, cpu_usage FROM gp_toolkit.gp_resgroup_status
    ''')
    json_text = json.dumps(dict([(row['rsgname'], json.loads(row['cpu_usage']))
                                 for row in group_cpus]))
    plpy.execute('''
        INSERT INTO cpu_usage_samples VALUES ('{value}')
    '''.format(value=json_text))
    return json_text
$$ LANGUAGE plpython3u;

-- verify_cpu_usage: calculate each QE's average cpu usage using all the data in
-- the table cpu_usage_sample. And compare the average value to the expected value.
-- return true if the practical value is close to the expected value.
CREATE OR REPLACE FUNCTION verify_cpu_usage(groupname TEXT, expect_cpu_usage INT, err_rate INT)
RETURNS BOOL AS $$
    import json
    import functools

    def add_vector(vec1, vec2):
        r = dict()
        for seg_id1, value1 in vec1.items():
            r[seg_id1] = value1 + vec2[seg_id1]
        return r

    def verify_cpu_usage():
        all_info = plpy.execute('''
            SELECT sample::json->'{name}' AS cpu FROM cpu_usage_samples
        '''.format(name=groupname))
        usage_sum = functools.reduce(add_vector,
                           [json.loads(row['cpu']) for row in all_info])
        usage = [(float(v) / all_info.nrows())
                 for k, v in usage_sum.items() if k != "-1"]
        avg = sum(usage) / len(usage)
        return abs(avg - expect_cpu_usage) <= err_rate

    return verify_cpu_usage()
$$ LANGUAGE plpython3u;

CREATE OR REPLACE FUNCTION busy() RETURNS void AS $$
    import os
    import signal

    n = 15
    for i in range(n):
        if os.fork() == 0:
			# children must quit without invoking the atexit hooks
            signal.signal(signal.SIGINT,  lambda a, b: os._exit(0))
            signal.signal(signal.SIGQUIT, lambda a, b: os._exit(0))
            signal.signal(signal.SIGTERM, lambda a, b: os._exit(0))

            # generate pure cpu load
            while True:
                pass

    os.wait()
$$ LANGUAGE plpython3u;

CREATE VIEW cancel_all AS
    SELECT pg_cancel_backend(pid)
    FROM pg_stat_activity
    WHERE query LIKE 'SELECT * FROM % WHERE busy%';

-- create two resource groups
CREATE RESOURCE GROUP rg1_cpu_test WITH (concurrency=5, cpu_rate_limit=10, memory_limit=20);
CREATE RESOURCE GROUP rg2_cpu_test WITH (concurrency=5, cpu_rate_limit=20, memory_limit=20);

--
-- check gpdb cgroup configuration
--
DO LANGUAGE PLPYTHON3U $$
    import subprocess

    cgroot = '@cgroup_mnt_point@'

    def get_cgroup_prop(prop):
        fullpath = cgroot + '/' + prop
        return int(open(fullpath).readline())

    def run_command(cmd):
        return subprocess.check_output(cmd.split()).decode()

    def show_guc(guc):
        return plpy.execute('SHOW {}'.format(guc))[0][guc]

    #
    # check gpdb top-level cgroup configuration
    #

    # get top-level cgroup props
    cfs_quota_us = get_cgroup_prop('/cpu/gpdb/cpu.cfs_quota_us')
    cfs_period_us = get_cgroup_prop('/cpu/gpdb/cpu.cfs_period_us')
    shares = get_cgroup_prop('/cpu/gpdb/cpu.shares')

    # get system props
    ncores = int(run_command('nproc'))

    # get global gucs
    gp_resource_group_cpu_limit = float(show_guc('gp_resource_group_cpu_limit'))
    gp_resource_group_cpu_priority = int(show_guc('gp_resource_group_cpu_priority'))

    # cfs_quota_us := cfs_period_us * ncores * gp_resource_group_cpu_limit
    assert cfs_quota_us == cfs_period_us * ncores * gp_resource_group_cpu_limit

    # shares := 1024 * gp_resource_group_cpu_priority
    assert shares == 1024 * gp_resource_group_cpu_priority

    # SUB/shares := TOP/shares * cpu_rate_limit
    def check_group_shares(name):
        cpu_rate_limit = int(plpy.execute('''
            SELECT value
              FROM pg_resgroupcapability c, pg_resgroup g
             WHERE c.resgroupid=g.oid
               AND reslimittype=2
               AND g.rsgname='{}'
        '''.format(name))[0]['value'])
        oid = int(plpy.execute('''
            SELECT oid FROM pg_resgroup WHERE rsgname='{}'
        '''.format(name))[0]['oid'])
        sub_shares = get_cgroup_prop('/cpu/gpdb/{}/cpu.shares'.format(oid))
        assert sub_shares == shares * cpu_rate_limit / 100

    # check default groups
    check_group_shares('default_group')
    check_group_shares('admin_group')

    # check user groups
    check_group_shares('rg1_cpu_test')
    check_group_shares('rg2_cpu_test')
$$;

-- lower admin_group's cpu_rate_limit to minimize its side effect
ALTER RESOURCE GROUP admin_group SET cpu_rate_limit 1;

-- create two roles and assign them to above groups
CREATE ROLE role1_cpu_test RESOURCE GROUP rg1_cpu_test;
CREATE ROLE role2_cpu_test RESOURCE GROUP rg2_cpu_test;
GRANT ALL ON FUNCTION busy() TO role1_cpu_test;
GRANT ALL ON FUNCTION busy() TO role2_cpu_test;

-- prepare parallel queries in the two groups
10: SET ROLE TO role1_cpu_test;
11: SET ROLE TO role1_cpu_test;
12: SET ROLE TO role1_cpu_test;
13: SET ROLE TO role1_cpu_test;
14: SET ROLE TO role1_cpu_test;

20: SET ROLE TO role2_cpu_test;
21: SET ROLE TO role2_cpu_test;
22: SET ROLE TO role2_cpu_test;
23: SET ROLE TO role2_cpu_test;
24: SET ROLE TO role2_cpu_test;

--
-- now we get prepared.
--
-- on empty load the cpu usage shall be 0%
--

--
-- a group should burst to use all the cpu usage
-- when it's the only one with running queries.
--
-- however the overall cpu usage is controlled by a GUC
-- gp_resource_group_cpu_limit which is 90% by default.
--
-- so the cpu usage shall be 90%
--

10&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
11&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
12&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
13&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
14&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;

-- start_ignore
TRUNCATE TABLE cpu_usage_samples;
SELECT fetch_sample();
SELECT pg_sleep(1.7);
SELECT fetch_sample();
SELECT pg_sleep(1.7);
SELECT fetch_sample();
SELECT pg_sleep(1.7);
SELECT fetch_sample();
SELECT pg_sleep(1.7);
SELECT fetch_sample();
SELECT pg_sleep(1.7);
TRUNCATE TABLE cpu_usage_samples;
SELECT fetch_sample();
SELECT pg_sleep(1.7);
SELECT fetch_sample();
SELECT pg_sleep(1.7);
SELECT fetch_sample();
SELECT pg_sleep(1.7);
SELECT fetch_sample();
SELECT pg_sleep(1.7);
SELECT fetch_sample();
SELECT pg_sleep(1.7);
-- end_ignore

SELECT verify_cpu_usage('rg1_cpu_test', 90, 10);

-- start_ignore
SELECT * FROM cancel_all;

10<:
11<:
12<:
13<:
14<:
-- end_ignore

10q:
11q:
12q:
13q:
14q:

10: SET ROLE TO role1_cpu_test;
11: SET ROLE TO role1_cpu_test;
12: SET ROLE TO role1_cpu_test;
13: SET ROLE TO role1_cpu_test;
14: SET ROLE TO role1_cpu_test;

--
-- when there are multiple groups with parallel queries,
-- they should share the cpu usage by their cpu_usage settings,
--
-- rg1_cpu_test:rg2_cpu_test is 0.1:0.2 => 1:2, so:
--
-- - rg1_cpu_test gets 90% * 1/3 => 30%;
-- - rg2_cpu_test gets 90% * 2/3 => 60%;
--

10&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
11&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
12&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
13&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
14&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;

20&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
21&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
22&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
23&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
24&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;

-- start_ignore
TRUNCATE TABLE cpu_usage_samples;
SELECT fetch_sample();
SELECT pg_sleep(1.7);
SELECT fetch_sample();
SELECT pg_sleep(1.7);
SELECT fetch_sample();
SELECT pg_sleep(1.7);
SELECT fetch_sample();
SELECT pg_sleep(1.7);
SELECT fetch_sample();
SELECT pg_sleep(1.7);
TRUNCATE TABLE cpu_usage_samples;
SELECT fetch_sample();
SELECT pg_sleep(1.7);
SELECT fetch_sample();
SELECT pg_sleep(1.7);
SELECT fetch_sample();
SELECT pg_sleep(1.7);
SELECT fetch_sample();
SELECT pg_sleep(1.7);
SELECT fetch_sample();
SELECT pg_sleep(1.7);
-- end_ignore

SELECT verify_cpu_usage('rg1_cpu_test', 30, 10);
SELECT verify_cpu_usage('rg2_cpu_test', 60, 10);

-- start_ignore
SELECT * FROM cancel_all;

10<:
11<:
12<:
13<:
14<:

20<:
21<:
22<:
23<:
24<:

10q:
11q:
12q:
13q:
14q:


20q:
21q:
22q:
23q:
24q:
-- end_ignore

-- start_ignore
! gpconfig -c gp_resource_group_cpu_ceiling_enforcement -v on;
! gpstop -rai;
-- end_ignore

-- prepare parallel queries in the two groups
10: SET ROLE TO role1_cpu_test;
11: SET ROLE TO role1_cpu_test;
12: SET ROLE TO role1_cpu_test;
13: SET ROLE TO role1_cpu_test;
14: SET ROLE TO role1_cpu_test;

20: SET ROLE TO role2_cpu_test;
21: SET ROLE TO role2_cpu_test;
22: SET ROLE TO role2_cpu_test;
23: SET ROLE TO role2_cpu_test;
24: SET ROLE TO role2_cpu_test;

--
-- now we get prepared.
--
-- on empty load the cpu usage shall be 0%
--
--
-- a group should not burst to use all the cpu usage
-- when it's the only one with running queries.
--
-- so the cpu usage shall be 10%
--

10&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
11&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
12&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
13&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
14&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;

-- start_ignore
1:TRUNCATE TABLE cpu_usage_samples;
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
1:TRUNCATE TABLE cpu_usage_samples;
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
-- end_ignore

1:SELECT verify_cpu_usage('rg1_cpu_test', 10, 2);

-- start_ignore
1:SELECT * FROM cancel_all;

10<:
11<:
12<:
13<:
14<:
-- end_ignore

10q:
11q:
12q:
13q:
14q:

10: SET ROLE TO role1_cpu_test;
11: SET ROLE TO role1_cpu_test;
12: SET ROLE TO role1_cpu_test;
13: SET ROLE TO role1_cpu_test;
14: SET ROLE TO role1_cpu_test;

--
-- when there are multiple groups with parallel queries,
-- they should follow the ceiling enforcement of the cpu usage.
--
-- rg1_cpu_test:rg2_cpu_test is 0.1:0.2, so:
--
-- - rg1_cpu_test gets 10%;
-- - rg2_cpu_test gets 20%;
--

10&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
11&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
12&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
13&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
14&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;

20&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
21&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
22&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
23&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;
24&: SELECT * FROM gp_dist_random('gp_id') WHERE busy() IS NULL;

-- start_ignore
1:TRUNCATE TABLE cpu_usage_samples;
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
1:TRUNCATE TABLE cpu_usage_samples;
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
1:SELECT fetch_sample();
1:SELECT pg_sleep(1.7);
-- end_ignore

1:SELECT verify_cpu_usage('rg1_cpu_test', 10, 2);
1:SELECT verify_cpu_usage('rg2_cpu_test', 20, 2);

-- start_ignore
1:SELECT * FROM cancel_all;

10<:
11<:
12<:
13<:
14<:

20<:
21<:
22<:
23<:
24<:

10q:
11q:
12q:
13q:
14q:


20q:
21q:
22q:
23q:
24q:

1q:
-- end_ignore

-- start_ignore
! gpconfig -c gp_resource_group_cpu_ceiling_enforcement -v off;
! gpstop -rai;
-- end_ignore

-- restore admin_group's cpu_rate_limit
2:ALTER RESOURCE GROUP admin_group SET cpu_rate_limit 10;

-- cleanup
2:REVOKE ALL ON FUNCTION busy() FROM role1_cpu_test;
2:REVOKE ALL ON FUNCTION busy() FROM role2_cpu_test;
2:DROP ROLE role1_cpu_test;
2:DROP ROLE role2_cpu_test;
2:DROP RESOURCE GROUP rg1_cpu_test;
2:DROP RESOURCE GROUP rg2_cpu_test;
2:DROP LANGUAGE plpython3u CASCADE;
