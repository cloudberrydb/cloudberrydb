SET search_path TO 'exttableext';
SET
-- Test 3: create RET and WET using created protocol
    -- Create external RET and WET
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w;
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w(like exttabtest)
        LOCATION('demoprot://exttabtest.txt') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r;
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE exttabtest_r(like exttabtest)
        LOCATION('demoprot://exttabtest.txt') 
    FORMAT 'text';
CREATE EXTERNAL TABLE
    -- Checking pg_exttable for new created RET and WET
    select location,fmttype,fmtopts,encoding,writable from pg_exttable 
    where reloid='exttabtest_r'::regclass 
       or reloid='exttabtest_w'::regclass;
          location           | fmttype |                fmtopts                 | encoding | writable 
-----------------------------+---------+----------------------------------------+----------+----------
 {demoprot://exttabtest.txt} | t       | delimiter '     ' null '\N' escape '\' |        6 | t
 {demoprot://exttabtest.txt} | t       | delimiter '     ' null '\N' escape '\' |        6 | f
(2 rows)

    -- write to WET
    SELECT * FROM clean_exttabtest_files;
 stdout 
--------
(0 rows)

    INSERT INTO exttabtest_w (SELECT * FROM exttabtest);
INSERT 0 100
    -- read from RET
    SELECT * FROM exttabtest_r
    EXCEPT ALL
    SELECT * FROM exttabtest;
 id | name | value1 | value2 
----+------+--------+--------
(0 rows)

    -- verify data should be evenly distributed
    SELECT gp_segment_id, count(*) from exttabtest_r
    GROUP BY 1 ORDER BY 1;
 gp_segment_id | count 
---------------+-------
             0 |    50
             1 |    50
(2 rows)

-- Test 4.1: create uni-directional write protocol
-- create WET using created protocol
    DROP PROTOCOL IF EXISTS demoprot;
DROP PROTOCOL
    CREATE PROTOCOL demoprot (
        writefunc = write_to_file_stable
    );
CREATE PROTOCOL
    -- Create WET with uni-directional protocol
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_uni;
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_uni(like exttabtest)
        LOCATION('demoprot://exttabtest_uni.txt') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
CREATE EXTERNAL TABLE
    -- write to WET
    INSERT INTO exttabtest_w_uni (SELECT * FROM exttabtest);
INSERT 0 100
-- Test 4.2: create uni-directional read protocol 
-- create RET using created protocol
    DROP PROTOCOL IF EXISTS demoprot;
DROP PROTOCOL
    CREATE PROTOCOL demoprot (
        readfunc = read_from_file_stable
    );
CREATE PROTOCOL
    -- Create RET with uni-directional protocol
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_uni;
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE exttabtest_r_uni(like exttabtest)
        LOCATION('demoprot://exttabtest_uni.txt') 
    FORMAT 'text';
CREATE EXTERNAL TABLE
    -- read from RET
    SELECT * FROM exttabtest_r_uni
    EXCEPT ALL
    SELECT * FROM exttabtest;
 id | name | value1 | value2 
----+------+--------+--------
(0 rows)

-- Test 5: using bi-directional protocol, create ext table with different
-- distribution policy than the source table
-- When exporting, date file (exttabtest_dist.txt) will only be created as necessary. 
-- When data is not evenly distributed (as for this test case), 
-- some segments will not have data file created.
--
-- When importing, data file is required for each primary segment. 
-- Otherwise "ERROR:  demoprot_import: could not open file " will be thrown.
    DROP PROTOCOL IF EXISTS demoprot;
DROP PROTOCOL
    CREATE PROTOCOL demoprot (
        readfunc = read_from_file_stable,
        writefunc = write_to_file_stable
    );
CREATE PROTOCOL
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_dist;
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_dist(like exttabtest)
        LOCATION('demoprot://exttabtest_dist.txt') 
    FORMAT 'text'
    DISTRIBUTED BY (value2);
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_dist;
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE exttabtest_r_dist(like exttabtest)
        LOCATION('demoprot://exttabtest_dist.txt') 
    FORMAT 'text';
CREATE EXTERNAL TABLE
    -- write to WET
    INSERT INTO exttabtest_w_dist (SELECT * FROM exttabtest);
INSERT 0 100
    -- read from RET
    SELECT * FROM exttabtest_r_dist
    EXCEPT ALL
    SELECT * FROM exttabtest;
 id | name | value1 | value2 
----+------+--------+--------
(0 rows)

    -- verify data should be evenly distributed
    SELECT gp_segment_id, count(*) from exttabtest_r_dist
    GROUP BY 1 ORDER BY 1;
 gp_segment_id | count 
---------------+-------
             0 |    51
             1 |    49
(2 rows)

-- Test 6: using two urls and using CSV format
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_2url;
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE exttabtest_r_2url (like exttabtest)
        LOCATION('demoprot://exttabtest_2url_1.csv', 
                 'demoprot://exttabtest_2url_2.csv') 
    FORMAT 'csv';
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_2url;
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_2url (like exttabtest)
        LOCATION('demoprot://exttabtest_2url_1.csv', 
                 'demoprot://exttabtest_2url_2.csv')  
    FORMAT 'csv'
    DISTRIBUTED BY (id);
CREATE EXTERNAL TABLE
    -- write to WET
    INSERT INTO exttabtest_w_2url (SELECT * FROM exttabtest);
INSERT 0 100
    -- read from RET
    SELECT * FROM exttabtest_r_2url
    EXCEPT ALL
    SELECT * FROM exttabtest;
 id | name | value1 | value2 
----+------+--------+--------
(0 rows)

    -- verify data should be evenly distributed
    SELECT gp_segment_id, count(*) from exttabtest_r_2url
    GROUP BY 1 ORDER BY 1;
 gp_segment_id | count 
---------------+-------
             0 |    50
             1 |    50
(2 rows)

    -- Check the output file at each segments
    -- ! gpssh -f allsegs ls -l /data/hhuang/MAIN/main_debug/primary/gpseg*/exttabtest_2url*.csv
-- Test 7: using two urls and text format
    
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_2url;
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE exttabtest_r_2url (like exttabtest)
        LOCATION('demoprot://exttabtest_2url_1.txt', 
                 'demoprot://exttabtest_2url_2.txt')
    FORMAT 'text';
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_2url;
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_2url (like exttabtest)
        LOCATION('demoprot://exttabtest_2url_1.txt', 
                 'demoprot://exttabtest_2url_2.txt')
    FORMAT 'text'
    DISTRIBUTED BY (id);
CREATE EXTERNAL TABLE
    -- write to WET
    INSERT INTO exttabtest_w_2url (SELECT * FROM exttabtest);
INSERT 0 100
    -- read from RET
    SELECT * FROM exttabtest_r_2url
    EXCEPT ALL
    SELECT * FROM exttabtest;
 id | name | value1 | value2 
----+------+--------+--------
(0 rows)

    -- verify data should be evenly distributed
    SELECT gp_segment_id, count(*) from exttabtest_r_2url
    GROUP BY 1 ORDER BY 1;
 gp_segment_id | count 
---------------+-------
             0 |    50
             1 |    50
(2 rows)

    -- Checking the output files on segments
    -- ! gpssh -f allsegs ls -l /data/hhuang/MAIN/main_debug/primary/gpseg*/exttabtest_2url*.txt
-- Test 8: Negative - using 5 urls, exceeding number of primary segments (4)
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_5url;
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_5url (like exttabtest)
        LOCATION('demoprot://exttabtest_5url_1.txt', 
                 'demoprot://exttabtest_5url_2.txt',
                 'demoprot://exttabtest_5url_3.txt',
                 'demoprot://exttabtest_5url_4.txt',
                 'demoprot://exttabtest_5url_5.txt') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
CREATE EXTERNAL TABLE
    -- write to WET
    INSERT INTO exttabtest_w_5url (SELECT * FROM exttabtest);
psql:/path/sql_file:1: ERROR:  External table has more URLs then available primary segments that can write into them  (seg0 rh55-qavm55:7532 pid=1235)
-- Test 9: Negative - duplicte protocol name (check pg_extprotocol)
    SELECT count(*) FROM pg_extprotocol WHERE ptcname='demoprot';
 count 
-------
     1
(1 row)

    CREATE PROTOCOL demoprot (
        readfunc = read_from_file_stable,
        writefunc = write_to_file_stable
    );
psql:/path/sql_file:1: ERROR:  protocol "demoprot" already exists
-- Test 10: Negative: create external table using non-existing protocol
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_neg10 (like exttabtest)
        LOCATION('demoprot_nonexist://exttabtest_neg10.txt')  
    FORMAT 'text'
    DISTRIBUTED BY (id);
psql:/path/sql_file:1: ERROR:  protocol "demoprot_nonexist" does not exist
-- Test 11: Negative - Using invalid protocol attribute name
-- attribute names must be readproc, write proc, and validatorproc
    DROP PROTOCOL IF EXISTS demoprot;
DROP PROTOCOL
    CREATE PROTOCOL demoprot (
        readfunction  = read_from_file, 
        writefunction = write_to_file
    );
psql:/path/sql_file:1: ERROR:  protocol attribute "readfunction" not recognized
-- Test 12: Negatvie - using undefined function when defining protocol
    DROP PROTOCOL IF EXISTS demoprot;
psql:/path/sql_file:1: NOTICE:  protocol "demoprot" does not exist, skipping
DROP PROTOCOL
    CREATE PROTOCOL demoprot (
        readfunc  = read_from_file_badname, 
        writefunc = write_to_file_badname
    );
psql:/path/sql_file:1: ERROR:  function read_from_file_badname() does not exist
-- Test 13: Negatvie - syntax error: missing '=' when defining protocol
    DROP PROTOCOL IF EXISTS demoprot;
psql:/path/sql_file:1: NOTICE:  protocol "demoprot" does not exist, skipping
DROP PROTOCOL
    CREATE PROTOCOL demoprot (
        readfunc read_from_file, 
        writefunc write_to_file
    );
psql:/path/sql_file:1: ERROR:  syntax error at or near "read_from_file"
LINE 2:         readfunc read_from_file, 
                         ^
-- Test 14: Negative - switching read function and write function
-- This is user error. GPDB should display meaningful error message.
    DROP PROTOCOL IF EXISTS demoprot;
psql:/path/sql_file:1: NOTICE:  protocol "demoprot" does not exist, skipping
DROP PROTOCOL
    CREATE PROTOCOL demoprot (
        writefunc = read_from_file_stable, 
        readfunc = write_to_file_stable
    );
CREATE PROTOCOL
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_switched;
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_switched (like exttabtest)
        LOCATION('demoprot://exttabtest_switched.txt') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_switched;
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE exttabtest_r_switched(like exttabtest)
        LOCATION('demoprot://exttabtest_switched.txt') 
    FORMAT 'text';
CREATE EXTERNAL TABLE
    -- write to WET
    INSERT INTO exttabtest_w_switched (SELECT * FROM exttabtest);
psql:/path/sql_file:1: ERROR:  demoprot_import: could not open file "exttabtest_switched.txt" for reading: No such file or directory  (seg0 rh55-qavm55:7532 pid=32378)
    -- read from RET
    --SELECT * FROM exttabtest_r_switched
    --EXCEPT ALL
    --SELECT * FROM exttabtest;
-- Test 15: Negative - circular reference
-- write to WET while selecting from RET, and WET and RET are using the same data source files
    DROP PROTOCOL IF EXISTS demoprot;
psql:/path/sql_file:1: NOTICE:  protocol "demoprot" does not exist, skipping
DROP PROTOCOL
    CREATE PROTOCOL demoprot (
        readfunc = read_from_file_stable,
        writefunc = write_to_file_stable
    );
CREATE PROTOCOL
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_circle;
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_circle(like exttabtest)
        LOCATION('demoprot://exttabtest.txt') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_circle;
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE exttabtest_r_circle(like exttabtest)
        LOCATION('demoprot://exttabtest.txt') 
    FORMAT 'text';
CREATE EXTERNAL TABLE
    -- First to create exttabtest.txt using WET
    INSERT INTO exttabtest_w_circle (SELECT * FROM exttabtest);
INSERT 0 100
    -- write to WET while reading from RET, 
    -- using limit to avoid infinit loop 
    -- This is to test that using RET and WET inappropriately can get yourself into trouble
    INSERT INTO exttabtest_w_circle (SELECT * FROM exttabtest_r_circle order by id limit 100);
INSERT 0 100
-- Test 16: Negative - invalid URL: missing path
    drop external table if exists exttabtest_w_misspath;
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_misspath(like exttabtest)
        LOCATION('demoprot://') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
CREATE EXTERNAL TABLE
    insert into exttabtest_w_misspath (select * from exttabletest);
psql:/path/sql_file:1: ERROR:  relation "exttabletest" does not exist
-- Test 17: Negative - invalid URL: missing protocol
    CREATE READABLE EXTERNAL TABLE exttabtest_r_missprot(like exttabtest)
        LOCATION('exttabtest.txt') 
    FORMAT 'text';
psql:/path/sql_file:1: ERROR:  invalid URI 'exttabtest.txt' : undefined structure
-- Test 18: Negative - invalid URL: invalid path
    CREATE READABLE EXTERNAL TABLE exttabtest_r_invalidpath(like exttabtest)
        LOCATION('demoprot:\\exttabtest.txt') 
    FORMAT 'text';
psql:/path/sql_file:1: WARNING:  nonstandard use of \\ in a string literal
LINE 2:         LOCATION('demoprot:\\exttabtest.txt') 
                         ^
HINT:  Use the escape string syntax for backslashes, e.g., E'\\'.
psql:/path/sql_file:1: ERROR:  invalid URI 'demoprot:\exttabtest.txt' : undefined structure
-- Test 19: Negative - invalid URL: invalid protocol name
    CREATE READABLE EXTERNAL TABLE exttabtest_r_invalidprot(like exttabtest)
        LOCATION('badprotocol://exttabtest.txt') 
    FORMAT 'text';
psql:/path/sql_file:1: ERROR:  protocol "badprotocol" does not exist
-- Test 20: Small dataset - 4 records
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_4records;
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_4records (like exttabtest)
        LOCATION('demoprot://exttabtest_4records.txt') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_4records;
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE exttabtest_r_4records (like exttabtest)
        LOCATION('demoprot://exttabtest_4records.txt') 
    FORMAT 'text';
CREATE EXTERNAL TABLE
    -- write to WET
    INSERT INTO exttabtest_w_4records (SELECT * FROM exttabtest where id<=4);
INSERT 0 4
    -- read from RET
    SELECT * FROM exttabtest_r_4records order by id;
 id | name  | value1 | value2 
----+-------+--------+--------
  1 | name1 |      2 |      3
  2 | name2 |      4 |      6
  3 | name3 |      6 |      9
  4 | name4 |      8 |     12
(4 rows)

    -- verify data should be evenly distributed
    SELECT gp_segment_id, count(*) from exttabtest_r_4records
    GROUP BY 1 ORDER BY 1;
 gp_segment_id | count 
---------------+-------
             0 |     2
             1 |     2
(2 rows)

    -- Drop External Tables
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_4records;
DROP EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_4records;
DROP EXTERNAL TABLE
-- Test 21: Small dataset - 1 record
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_1record;
psql:/path/sql_file:1: NOTICE:  table "exttabtest_w_1record" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_1record (like exttabtest)
        LOCATION('demoprot://exttabtest_1record.txt') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_1record;
psql:/path/sql_file:1: NOTICE:  table "exttabtest_r_1record" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE exttabtest_r_1record (like exttabtest)
        LOCATION('demoprot://exttabtest_1record.txt') 
    FORMAT 'text';
CREATE EXTERNAL TABLE
    -- write to WET
    INSERT INTO exttabtest_w_1record (SELECT * FROM exttabtest where id = 4);
INSERT 0 1
    -- read from RET
    -- The implemented example protocol (demoprot) requires data file must be available
    -- (even it is empty) for each (primary) segment.
    -- This is the limitation of this example (MPP-13811)
    -- and will cause following SElECT query to fail
    SELECT * FROM exttabtest_r_1record order by id;
psql:/path/sql_file:1: ERROR:  demoprot_import: could not open file "exttabtest_1record.txt" for reading: No such file or directory  (seg0 slice1 rh55-qavm55:7532 pid=23845)
DETAIL:  External table exttabtest_r_1record, file demoprot://exttabtest_1record.txt
    -- Drop External Tables
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_1record;
DROP EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_1record;
DROP EXTERNAL TABLE
-- Test 22: Using /dev/null
    -- Using /dev/null for output and input
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_null;
psql:/path/sql_file:1: NOTICE:  table "exttabtest_w_null" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_null (like exttabtest)
        LOCATION('demoprot:///dev/null') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_null;
psql:/path/sql_file:1: NOTICE:  table "exttabtest_r_null" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE exttabtest_r_null (like exttabtest)
        LOCATION('demoprot:///dev/null') 
    FORMAT 'text';
CREATE EXTERNAL TABLE
    -- write to WET
    INSERT INTO exttabtest_w_null (SELECT * FROM exttabtest);
INSERT 0 100
    -- read from RET
    SELECT count(id) FROM exttabtest_r_null;
 count 
-------
     0
(1 row)

-- Test 23: Performance - 1M records
    -- Load 1M rows of data
    TRUNCATE TABLE exttabtest;
TRUNCATE TABLE
    INSERT INTO exttabtest SELECT i, 'name'||i, i*2, i*3 FROM generate_series(1,1000000) i;
INSERT 0 1000000
    -- Using demoprot, import and export 1M records        
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_1M;
psql:/path/sql_file:1: NOTICE:  table "exttabtest_w_1m" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_1M (like exttabtest)
        LOCATION('demoprot://exttabtest_1M.txt') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_1M;
psql:/path/sql_file:1: NOTICE:  table "exttabtest_r_1m" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE exttabtest_r_1M (like exttabtest)
        LOCATION('demoprot://exttabtest_1M.txt') 
    FORMAT 'text';
CREATE EXTERNAL TABLE
    -- write to WET
    INSERT INTO exttabtest_w_1M (SELECT * FROM exttabtest);
INSERT 0 1000000
    -- Time: 1369.028 ms
    -- read from RET
    SELECT count(id) FROM exttabtest_r_1M;
  count  
---------
 1000000
(1 row)

    -- Time: 869.793 ms
    -- Compare to using demoprot protocol and output to /dev/null (no disk IO, thanks to Alan)
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_1M_null;
psql:/path/sql_file:1: NOTICE:  table "exttabtest_w_1m_null" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_1M_null (like exttabtest)
        LOCATION('demoprot:///dev/null') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_1M_null;
psql:/path/sql_file:1: NOTICE:  table "exttabtest_r_1m_null" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE exttabtest_r_1M_null (like exttabtest)
        LOCATION('demoprot:///dev/null') 
    FORMAT 'text';
CREATE EXTERNAL TABLE
    -- write to WET
    INSERT INTO exttabtest_w_1M_null (SELECT * FROM exttabtest);
INSERT 0 1000000
    -- Time: 1368.173 ms (about same as writing to file - CPU intensive)
-- Test 30: UDF dependency - drop UDF when it does not have dependent protocol
    -- Create new UDF that has no dependent
    CREATE OR REPLACE FUNCTION write_udf_todrop() RETURNS integer AS
        '$libdir/gpextprotocol.so', 'demoprot_export' LANGUAGE C STABLE;
CREATE FUNCTION
    CREATE OR REPLACE FUNCTION read_udf_todrop() RETURNS integer AS 
        '$libdir/gpextprotocol.so', 'demoprot_import' LANGUAGE C STABLE;
CREATE FUNCTION
    -- Check pg_proc catalog table for new created functions
    SELECT proname, prolang,proisstrict,provolatile,pronargs,prorettype,prosrc,proacl FROM pg_proc
    WHERE proname like 'write_udf_todrop'
       or proname like 'read_udf_todrop'
    ORDER BY proname;
     proname      | prolang | proisstrict | provolatile | pronargs | prorettype |     prosrc      | proacl 
------------------+---------+-------------+-------------+----------+------------+-----------------+--------
 read_udf_todrop  |      13 | f           | s           |        0 |         23 | demoprot_import | 
 write_udf_todrop |      13 | f           | s           |        0 |         23 | demoprot_export | 
(2 rows)

    -- Drop two UDFs
    DROP FUNCTION write_udf_todrop();
DROP FUNCTION
    DROP FUNCTION read_udf_todrop();
DROP FUNCTION
    -- Check pg_proc catalog table for after drop the UDFs
    SELECT proname, prolang,proisstrict,provolatile,pronargs,prorettype,prosrc,proacl FROM pg_proc
    WHERE proname like 'write_udf_todrop'
       or proname like 'read_udf_todrop'
    ORDER BY proname;
 proname | prolang | proisstrict | provolatile | pronargs | prorettype | prosrc | proacl 
---------+---------+-------------+-------------+----------+------------+--------+--------
(0 rows)

-- Test 31: UDF dependency - drop UDF when it has dependent dependent protocol
-- Cannot drop UDF when it has protocol dependent.
    -- Check protocol demoprot is depending on UDF
    select count(*) from pg_extprotocol
    where ptcreadfn='read_from_file_stable'::regproc;
 count 
-------
     1
(1 row)

    -- Try to drop UDF read_from_file_stable() that has protocol demoprot depends on it
    drop function read_from_file_stable();
psql:/path/sql_file:1: NOTICE:  protocol demoprot depends on function read_from_file_stable()
psql:/path/sql_file:1: ERROR:  cannot drop function read_from_file_stable() because other objects depend on it
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
    -- Check pg_proc catalog table to verify UDF is NOT dropped
    SELECT proname, prolang,proisstrict,provolatile,pronargs,prorettype,prosrc,proacl FROM pg_proc
    WHERE proname like 'write_to_file%'
       or proname like 'read_from_file%'
    ORDER BY proname;
        proname        | prolang | proisstrict | provolatile | pronargs | prorettype |     prosrc      | proacl 
-----------------------+---------+-------------+-------------+----------+------------+-----------------+--------
 read_from_file_stable |      13 | f           | s           |        0 |         23 | demoprot_import | 
 write_to_file_stable  |      13 | f           | s           |        0 |         23 | demoprot_export | 
(2 rows)

-- Test 32: Protocol dependency - drop protocol when it has dependent external table
-- Protocol can be dropped when external table is still referencing it
-- Entries should be removed from pg_extprotocol and pg_depend tables.
-- External table should not be accessible after dropping the protocol.
    -- Check RET exttabtest_r is using protocol demoprot
    select location from pg_exttable where reloid='exttabtest_r'::regclass;
          location           
-----------------------------
 {demoprot://exttabtest.txt}
(1 row)

    -- showing {demoprot://exttabtest.txt}
    -- Check pg_extprotocol table
    select ptcname from pg_extprotocol where ptcname='demoprot';
 ptcname  
----------
 demoprot
(1 row)

    -- returns one record 
    -- Check pg_depend table for protocol demoprot dependency
    select count(*) from pg_depend 
    where objid in (
        select oid from pg_extprotocol where ptcname='demoprot');
 count 
-------
     2
(1 row)

    -- returns 2 records
    -- truncate table exttabtest and load 100 records
    TRUNCATE TABLE exttabtest;
TRUNCATE TABLE
    INSERT INTO exttabtest SELECT i, 'name'||i, i*2, i*3 FROM generate_series(1,100) i;
INSERT 0 100
    -- Check WET is working fine before dropping the protocol demoprot
    SELECT * FROM clean_exttabtest_files;
 stdout 
--------
(0 rows)

    INSERT INTO exttabtest_w (SELECT * FROM exttabtest);
INSERT 0 100
    -- Check RET is working fine before dropping the protocol demoprot
    select count(*) from exttabtest_r;
 count 
-------
   100
(1 row)

    -- returns count =  100
    -- DROP protocol demoprot when there is RET using it
    drop protocol demoprot;
DROP PROTOCOL
    -- DROP PROTOCOL
    -- Check RET exttabtest_r_1m is still referencing protocol demoprot
    select location from pg_exttable where reloid='exttabtest_r'::regclass;
          location           
-----------------------------
 {demoprot://exttabtest.txt}
(1 row)

    -- returns 1
    -- Check pg_extprotocol table, the entry should be dropped
    select ptcname from pg_extprotocol where ptcname='demoprot';
 ptcname 
---------
(0 rows)

    -- returns 0
    -- Check pg_depend table for protocol demoprot dependency
    -- no entry should be restured
    select count(*) from pg_depend 
    where objid in (
        select oid from pg_extprotocol where ptcname='demoprot');    
 count 
-------
     0
(1 row)

    -- returns 0
    -- RET now should not be accessible, showing protocol does not exist
    select count(*) from exttabtest_r;
psql:/path/sql_file:1: ERROR:  protocol "demoprot" does not exist  (seg0 slice1 rh55-qavm55:7532 pid=26605)
    -- shows ERROR:  protocol "demoprot" does not exist  (seg0 slice1 rh55-qavm57:5532 pid=11077)"
-- Test 33: Protocol dependency - restore protocol and check the dependent external table
-- Protocol is referenced by external table via protocol name.
-- There is no other dependency between protocol and external table.
    -- Restore (recreate) protocol with the same protocol name demoprot
    DROP PROTOCOL IF EXISTS demoprot;
psql:/path/sql_file:1: NOTICE:  protocol "demoprot" does not exist, skipping
DROP PROTOCOL
    CREATE PROTOCOL demoprot (
        readfunc = read_from_file_stable,
        writefunc = write_to_file_stable
    );
CREATE PROTOCOL
    -- CREATE PROTOCOL
    -- Check WET is working fine after restore the dropped the protocol demoprot
    SELECT * FROM clean_exttabtest_files;
 stdout 
--------
(0 rows)

    INSERT INTO exttabtest_w (SELECT * FROM exttabtest);
INSERT 0 100
    -- Chect existing RET that using protocol demoprot
    -- it should be accessible after restore the protocol
    select count(*) from exttabtest_r;
 count 
-------
   100
(1 row)

    -- returns count = 100
-- Test 34: Protocol dependency - drop protocol cascade
    -- Drop protocol cascade works fine.
    DROP PROTOCOL demoprot CASCADE;
DROP PROTOCOL
    -- DROP PROTOCOL
    -- Check RET exttabtest_r_1m is still referencing protocol demoprot
    -- not affected by drop protocol cascade
    select location from pg_exttable where reloid='exttabtest_r'::regclass;
          location           
-----------------------------
 {demoprot://exttabtest.txt}
(1 row)

    -- Verified other catalog tables: pg_extprotocol, pg_depend
    -- Check pg_extprotocol for protocol demoprot, it should be dropped
    select count(*) from pg_depend 
    where objid in (
        select oid from pg_extprotocol where ptcname='demoprot');
 count 
-------
     0
(1 row)

    -- Check dependency: pg_depend table
    select extprot.ptcname, proc1.proname readfunc, proc2.proname writefunc
    from pg_extprotocol extprot, pg_proc proc1, pg_proc proc2 
    where extprot.ptcname='demoprot' 
        and extprot.ptcreadfn=proc1.oid 
        and extprot.ptcwritefn=proc2.oid;
 ptcname | readfunc | writefunc 
---------+----------+-----------
(0 rows)

-- Test 35: UDF dependency - drop function cascade
    -- Restore (recreate) protocol with the same protocol name demoprot
    DROP PROTOCOL IF EXISTS demoprot;
psql:/path/sql_file:1: NOTICE:  protocol "demoprot" does not exist, skipping
DROP PROTOCOL
    CREATE PROTOCOL demoprot (
        readfunc = read_from_file_stable,
        writefunc = write_to_file_stable
    );
CREATE PROTOCOL
    -- CREATE PROTOCOL
    -- Drop function cascade.
    -- Showing notice message of cascade drop of dependent protocol demoprot
    drop function read_from_file_stable() cascade;
psql:/path/sql_file:1: NOTICE:  drop cascades to protocol demoprot
DROP FUNCTION
    -- NOTICE:  drop cascades to protocol demoprot
    -- DROP FUNCTION
    -- Check pg_proc for function read_from_file_stable
    SELECT oid, proname FROM pg_proc 
    WHERE proname = 'read_from_file_stable';
 oid | proname 
-----+---------
(0 rows)

    -- returns 0
    -- Check dependency: pg_depend table
    select count(*) from pg_depend 
    where objid in (
        select oid from pg_extprotocol where ptcname='demoprot');
 count 
-------
     0
(1 row)

    -- Verified other catalog tables: pg_extprotocol, pg_depend
    -- Check RET exttabtest_r is still referencing protocol demoprot
    select location from pg_exttable where reloid='exttabtest_r'::regclass;
          location           
-----------------------------
 {demoprot://exttabtest.txt}
(1 row)

    -- Still showing  {demoprot://exttabtest.txt}
    -- Check pg_extprotocol table, the entry should be dropped
    select count(*) from pg_extprotocol where ptcname='demoprot';
 count 
-------
     0
(1 row)

    -- returns 0
-- Test 36: Regression - Alter Ext Table when using custom protocol
    -- Recreate function read_from_file_stable
    CREATE OR REPLACE FUNCTION read_from_file_stable() RETURNS integer AS 
        '$libdir/gpextprotocol.so', 'demoprot_import' LANGUAGE C STABLE;
CREATE FUNCTION
    -- Restore (recreate) protocol with the same protocol name demoprot
    DROP PROTOCOL IF EXISTS demoprot;
psql:/path/sql_file:1: NOTICE:  protocol "demoprot" does not exist, skipping
DROP PROTOCOL
    CREATE PROTOCOL demoprot (
        readfunc = read_from_file_stable,
        writefunc = write_to_file_stable
    );
CREATE PROTOCOL
    -- CREATE PROTOCOL
    -- Check existing WET that using protocol demoprot
    SELECT * FROM clean_exttabtest_files;
 stdout 
--------
(0 rows)

    insert into exttabtest_w (select * from exttabtest);
INSERT 0 100
    -- Check existing RET that using protocol demoprot
    select * from exttabtest_r where id <=4 order by id;
 id | name  | value1 | value2 
----+-------+--------+--------
  1 | name1 |      2 |      3
  2 | name2 |      4 |      6
  3 | name3 |      6 |      9
  4 | name4 |      8 |     12
(4 rows)

    -- returns 4 records
    -- Change ext table name when using custom protocol
    ALTER TABLE exttabtest_r rename to exttabtest_r_newname;
ALTER TABLE
    -- Check for Add|Drop|Rename column
    ALTER EXTERNAL TABLE exttabtest_r_newname ADD COLUMN value3 int;
ALTER EXTERNAL TABLE
    ALTER TABLE exttabtest_r_newname RENAME COLUMN value3 to value3_newname;
ALTER TABLE
    ALTER EXTERNAL TABLE exttabtest_r_newname DROP COLUMN value3_newname;
ALTER EXTERNAL TABLE
    -- Check external table is still accessible after alter operation
    select * from exttabtest_r_newname where id <=4 order by id;
 id | name  | value1 | value2 
----+-------+--------+--------
  1 | name1 |      2 |      3
  2 | name2 |      4 |      6
  3 | name3 |      6 |      9
  4 | name4 |      8 |     12
(4 rows)

    -- returns 4 records
-- Test 37: Regression - Drop Ext Table when using custom protocol
    -- Check external table exttabtest_r_newname exists
    -- and is using demoprot protocol
    \d exttabtest_r_newname
External table "exttableext.exttabtest_r_newname"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 id     | integer               | 
 name   | character varying(20) | 
 value1 | integer               | 
 value2 | integer               | 
Type: readable
Encoding: UTF8
Format type: text
Format options: delimiter '	' null '\N' escape '\'
External location: demoprot://exttabtest.txt

    select count(*) from pg_class where relname = 'exttabtest_r_newname';
 count 
-------
     1
(1 row)

    -- Drop external table 'exttabtest_r_newname'
    DROP EXTERNAL TABLE exttabtest_r_newname;
DROP EXTERNAL TABLE
    -- DROP EXTERNAL TABLE
-- Test 38: Negative - handling invalid data formate when using custom protocol
    -- Recreate RET
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_invalid;
psql:/path/sql_file:1: NOTICE:  table "exttabtest_r_invalid" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE exttabtest_r_invalid(like exttabtest)
        LOCATION('demoprot://exttabtest.txt') 
    FORMAT 'text';
CREATE EXTERNAL TABLE
    -- Using WET to create data source file exttabtest.txt
    SELECT * FROM clean_exttabtest_files;
 stdout 
--------
(0 rows)

    INSERT INTO exttabtest_w (select * from exttabtest);
INSERT 0 100
    -- Check RET is accessible
    SELECT count(*) from exttabtest_r_invalid;
 count 
-------
   100
(1 row)

    -- returns count = 100
    -- Add a column (value3) to RET
    ALTER EXTERNAL TABLE exttabtest_r_invalid ADD COLUMN value3 int;
ALTER EXTERNAL TABLE
    -- Access RET again with changed structure, the data file format is invalid now
    SELECT count(*) from exttabtest_r_invalid;
psql:/path/sql_file:1: ERROR:  missing data for column "value3"  (seg0 slice1 rh55-qavm55:7532 pid=14575)
DETAIL:  External table exttabtest_r_invalid, line 1 of demoprot://exttabtest.txt: "1	name1	2	3"
    -- Drop a column (id) from RET
    ALTER EXTERNAL TABLE exttabtest_r_invalid DROP COLUMN id;
ALTER EXTERNAL TABLE
    -- Access RET again with changed structure, the data file format is also invalid
    -- Comment this out since output file is undeterministic
    -- SELECT count(*) from exttabtest_r_invalid where gp_segment_id=0;
    -- Recreate WET
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_invalid;
psql:/path/sql_file:1: NOTICE:  table "exttabtest_w_invalid" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_invalid(like exttabtest)
        LOCATION('demoprot://exttabtest_invalid.txt') 
    FORMAT 'text';
psql:/path/sql_file:1: NOTICE:  Table doesn't have 'distributed by' clause, defaulting to distribution columns from LIKE table
CREATE EXTERNAL TABLE
    -- Drop a column (id) from WET
    ALTER EXTERNAL TABLE exttabtest_w_invalid DROP COLUMN id;
psql:/path/sql_file:1: NOTICE:  Dropping a column that is part of the distribution policy forces a NULL distribution policy
ALTER EXTERNAL TABLE
    -- Write to WET 
    INSERT INTO exttabtest_w_invalid (SELECT * from exttabtest);
psql:/path/sql_file:1: ERROR:  INSERT has more expressions than target columns
-- Test 60: setup source table
-- This table is our example database table for formatter test
DROP TABLE IF EXISTS formatsource CASCADE;
psql:/path/sql_file:1: NOTICE:  table "formatsource" does not exist, skipping
DROP TABLE
CREATE TABLE formatsource(
   name       varchar(40),
   id       float8,
   value1   float8,
   value2   float8
) 
DISTRIBUTED BY (id);
CREATE TABLE
-- Loading 100 records
    \echo 'loading data...'
loading data...
    INSERT INTO formatsource SELECT 'name'||i,  i, i*2, i*3 FROM generate_series(1,100) i;
INSERT 0 100
-- Check data distribution
    SELECT gp_segment_id, count(*) FROM formatsource GROUP BY 1 ORDER BY 1;
 gp_segment_id | count 
---------------+-------
             0 |    42
             1 |    58
(2 rows)

-- Test 61: create STABLE read and write functions based on example gpformatter.so
-- Note: Only STABLE is supported for formatter.
-- When it is not STABLE (VALOTILE, or IMMUTABLE),
-- the expected output of CREATE EXTERNAL TABLE should be an error.
CREATE OR REPLACE FUNCTION formatter_export_s(record) RETURNS bytea 
    AS '$libdir/gpformatter.so', 'formatter_export'
LANGUAGE C STABLE;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION formatter_import_s() RETURNS record
    AS '$libdir/gpformatter.so', 'formatter_import'
LANGUAGE C STABLE;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION formatter_export_v(record) RETURNS bytea 
    AS '$libdir/gpformatter.so', 'formatter_export'
LANGUAGE C VOLATILE;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION formatter_import_v() RETURNS record
    AS '$libdir/gpformatter.so', 'formatter_import'
LANGUAGE C VOLATILE;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION formatter_export_i(record) RETURNS bytea 
    AS '$libdir/gpformatter.so', 'formatter_export'
LANGUAGE C IMMUTABLE;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION formatter_import_i() RETURNS record
    AS '$libdir/gpformatter.so', 'formatter_import'
LANGUAGE C IMMUTABLE;
CREATE FUNCTION
-- Check pg_proc catalog table for new created functions
    SELECT proname, prolang,proisstrict,provolatile,pronargs,prorettype,prosrc,proacl FROM pg_proc 
    WHERE proname like 'formatter%' 
    ORDER BY proname;
      proname       | prolang | proisstrict | provolatile | pronargs | prorettype |      prosrc      | proacl 
--------------------+---------+-------------+-------------+----------+------------+------------------+--------
 formatter_export_i |      13 | f           | i           |        1 |         17 | formatter_export | 
 formatter_export_s |      13 | f           | s           |        1 |         17 | formatter_export | 
 formatter_export_v |      13 | f           | v           |        1 |         17 | formatter_export | 
 formatter_import_i |      13 | f           | i           |        0 |       2249 | formatter_import | 
 formatter_import_s |      13 | f           | s           |        0 |       2249 | formatter_import | 
 formatter_import_v |      13 | f           | v           |        0 |       2249 | formatter_import | 
(6 rows)

-- Test 62: Drop function without dependent external table
CREATE OR REPLACE FUNCTION formatter_export_todrop(record) RETURNS bytea 
    AS '$libdir/gpformatter.so', 'formatter_export'
LANGUAGE C STABLE;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION formatter_import_todrop() RETURNS record
    AS '$libdir/gpformatter.so', 'formatter_import'
LANGUAGE C STABLE;
CREATE FUNCTION
DROP FUNCTION formatter_export_todrop(record);
DROP FUNCTION
DROP FUNCTION formatter_import_todrop();
DROP FUNCTION
-- Test 63: create RET and WET using demoprot protocol and STABLE formatter
-- Note: Only STABLE is supported for formatter, this is enforced
-- When it is not STABLE (VOLATILE, or IMMUTABLE),
-- the expected error like:
-- ERROR: formatter function formatter_export_i is not declared STABLE. (seg1 rh55-qavm55:7533 pid=14816)
    -- Create RET and WET using IMMUTABLE functions will succeed
    -- However query such RET or WET should fail
    DROP EXTERNAL TABLE IF EXISTS format_w;
psql:/path/sql_file:1: NOTICE:  table "format_w" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE format_w(like formatsource) 
    LOCATION ('demoprot://exttabtest_test63') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_export_i');
psql:/path/sql_file:1: NOTICE:  Table doesn't have 'distributed by' clause, defaulting to distribution columns from LIKE table
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS format_r;
psql:/path/sql_file:1: NOTICE:  table "format_r" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE format_r(like formatsource) 
    LOCATION ('demoprot://exttabtest_test63') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_import_i');
CREATE EXTERNAL TABLE
    INSERT INTO format_w (SELECT * FROM formatsource);
psql:/path/sql_file:1: ERROR:  formatter function formatter_export_i is not declared STABLE.  (seg1 rh55-qavm55:7533 pid=30568)
    -- ERROR:  formatter function formatter_export_i is not declared STABLE.  (seg1 rh55-qavm55:7533 pid=14816)
    -- Create RET and WET using STABLE functions 
    DROP EXTERNAL TABLE IF EXISTS format_w;
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE format_w(like formatsource) 
    LOCATION ('demoprot://exttabtest_test63') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_export_s');
psql:/path/sql_file:1: NOTICE:  Table doesn't have 'distributed by' clause, defaulting to distribution columns from LIKE table
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS format_r;
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE format_r(like formatsource) 
    LOCATION ('demoprot://exttabtest_test63') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_import_s');
CREATE EXTERNAL TABLE
    -- Displaying table info
    \d format_w
      External table "exttableext.format_w"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 name   | character varying(40) | 
 id     | double precision      | 
 value1 | double precision      | 
 value2 | double precision      | 
Type: writable
Encoding: UTF8
Format type: custom
Format options: formatter 'formatter_export_s' 
External location: demoprot://exttabtest_test63

    \d format_r
      External table "exttableext.format_r"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 name   | character varying(40) | 
 id     | double precision      | 
 value1 | double precision      | 
 value2 | double precision      | 
Type: readable
Encoding: UTF8
Format type: custom
Format options: formatter 'formatter_import_s' 
External location: demoprot://exttabtest_test63

    -- Checking pg_exttable 
    select pg_class.relname, fmttype,
       fmtopts, encoding, writable
    from pg_class, pg_exttable
    where pg_class.oid = pg_exttable.reloid
    and (pg_class.relname='format_w'
    or
    pg_class.relname='format_r'
    or
    pg_class.relname='format_text'
    or
    pg_class.relname='format_csv');
 relname  | fmttype |             fmtopts             | encoding | writable 
----------+---------+---------------------------------+----------+----------
 format_w | b       | formatter 'formatter_export_s'  |        6 | t
 format_r | b       | formatter 'formatter_import_s'  |        6 | f
(2 rows)

    -- Write to WET
    SELECT * FROM clean_exttabtest_files;
 stdout 
--------
(0 rows)

    INSERT INTO format_w (SELECT * FROM formatsource);
INSERT 0 100
    -- read from RET
    SELECT * FROM format_r
    EXCEPT ALL
    SELECT * FROM formatsource;
 name | id | value1 | value2 
------+----+--------+--------
(0 rows)

    -- Read from RET 
    SELECT count(*) FROM format_r;
 count 
-------
   100
(1 row)

    -- verify data should be evenly distributed
    SELECT gp_segment_id, count(*) from format_r
    GROUP BY 1 ORDER BY 1;
 gp_segment_id | count 
---------------+-------
             0 |    42
             1 |    58
(2 rows)

-- Test 64: Drop format function with external table using the function
    DROP FUNCTION formatter_export_i(record); 
DROP FUNCTION
    DROP FUNCTION formatter_import_i();
DROP FUNCTION
    DROP FUNCTION formatter_export_s(record); 
DROP FUNCTION
    DROP FUNCTION formatter_import_s();
DROP FUNCTION
    -- Check pg_proc catalog table for the format functions
    -- should return 0
    SELECT proname, prolang,proisstrict,provolatile,
           pronargs,prorettype,prosrc,proacl FROM pg_proc 
    WHERE proname='formatter_import_s' or proname='formatter_export_s' 
    ORDER BY proname;
 proname | prolang | proisstrict | provolatile | pronargs | prorettype | prosrc | proacl 
---------+---------+-------------+-------------+----------+------------+--------+--------
(0 rows)

    -- Checking pg_exttable, should return 0
    select pg_class.relname, fmttype,
       fmtopts, encoding, writable
    from pg_class, pg_exttable
    where pg_class.oid = pg_exttable.reloid
    and (pg_class.relname='format_w'
    or
    pg_class.relname='format_r');
 relname  | fmttype |             fmtopts             | encoding | writable 
----------+---------+---------------------------------+----------+----------
 format_w | b       | formatter 'formatter_export_s'  |        6 | t
 format_r | b       | formatter 'formatter_import_s'  |        6 | f
(2 rows)

    -- Write to WET, should fail
    SELECT * FROM clean_exttabtest_files;
 stdout 
--------
(0 rows)

    INSERT INTO format_w (SELECT * FROM formatsource);
psql:/path/sql_file:1: ERROR:  formatter function formatter_export_s of type writable was not found.  (seg0 rh55-qavm55:7532 pid=30616)
    -- Read from RET, should fail
    SELECT count(*) FROM format_r;
psql:/path/sql_file:1: ERROR:  formatter function formatter_import_s of type readable was not found.
HINT:  Create it with CREATE FUNCTION.
-- Test 65: Restore (recreate) functions with same name, external table should work again
    -- Recreate UDFs with same function names
    CREATE OR REPLACE FUNCTION formatter_export_s(record) RETURNS bytea 
        AS '$libdir/gpformatter.so', 'formatter_export'
    LANGUAGE C STABLE;
CREATE FUNCTION
    CREATE OR REPLACE FUNCTION formatter_import_s() RETURNS record
        AS '$libdir/gpformatter.so', 'formatter_import'
    LANGUAGE C STABLE;
CREATE FUNCTION
    -- Check pg_proc catalog table for new created functions
    SELECT proname, prolang,proisstrict,provolatile,
           pronargs,prorettype,prosrc,proacl FROM pg_proc 
    WHERE proname='formatter_import_s' or proname='formatter_export_s' 
    ORDER BY proname;
      proname       | prolang | proisstrict | provolatile | pronargs | prorettype |      prosrc      | proacl 
--------------------+---------+-------------+-------------+----------+------------+------------------+--------
 formatter_export_s |      13 | f           | s           |        1 |         17 | formatter_export | 
 formatter_import_s |      13 | f           | s           |        0 |       2249 | formatter_import | 
(2 rows)

    -- Write to WET
    SELECT * FROM clean_exttabtest_files;
 stdout 
--------
(0 rows)

    INSERT INTO format_w (SELECT * FROM formatsource);
INSERT 0 100
    -- Read from RET
    SELECT count(*) FROM format_r;
 count 
-------
   100
(1 row)

    -- returns count = 100
-- Test 67: Multiple external tables can use same UDF independently
    -- Recreate STABLE import and export UDFs
    CREATE OR REPLACE FUNCTION formatter_export_s(record) RETURNS bytea 
        AS '$libdir/gpformatter.so', 'formatter_export'
    LANGUAGE C STABLE;
CREATE FUNCTION
    CREATE OR REPLACE FUNCTION formatter_import_s() RETURNS record
        AS '$libdir/gpformatter.so', 'formatter_import'
    LANGUAGE C STABLE;
CREATE FUNCTION
    -- First pair of RET and WET that using 
    -- formatter_import_s and formatter_export_s
    DROP EXTERNAL TABLE IF EXISTS format_w_s1;
psql:/path/sql_file:1: NOTICE:  table "format_w_s1" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE format_w_s1(like formatsource) 
        LOCATION ('demoprot://exttabtest_test67_s1') 
        FORMAT 'CUSTOM' (FORMATTER='formatter_export_s');
psql:/path/sql_file:1: NOTICE:  Table doesn't have 'distributed by' clause, defaulting to distribution columns from LIKE table
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS format_r_s1;
psql:/path/sql_file:1: NOTICE:  table "format_r_s1" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE format_r_s1(like formatsource) 
    LOCATION ('demoprot://exttabtest_test67_s1') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_import_s');
CREATE EXTERNAL TABLE
    -- Second pair of RET and WET that using 
    -- same formatter_import_s and formatter_export_s
    DROP EXTERNAL TABLE IF EXISTS format_w_s2;
psql:/path/sql_file:1: NOTICE:  table "format_w_s2" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE format_w_s2(like formatsource) 
        LOCATION ('demoprot://exttabtest_test67_s2') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_export_s');
psql:/path/sql_file:1: NOTICE:  Table doesn't have 'distributed by' clause, defaulting to distribution columns from LIKE table
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS format_r_s2;
psql:/path/sql_file:1: NOTICE:  table "format_r_s2" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE format_r_s2(like formatsource) 
    LOCATION ('demoprot://exttabtest_test67_s2') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_import_s');
CREATE EXTERNAL TABLE
    -- Checking pg_exttable
    select pg_class.relname, fmttype,
       fmtopts, encoding, writable
    from pg_class, pg_exttable
    where pg_class.oid = pg_exttable.reloid
    and (pg_class.relname like 'format_w_s%'
        or
        pg_class.relname like 'format_r_s%');
   relname   | fmttype |             fmtopts             | encoding | writable 
-------------+---------+---------------------------------+----------+----------
 format_w_s1 | b       | formatter 'formatter_export_s'  |        6 | t
 format_r_s1 | b       | formatter 'formatter_import_s'  |        6 | f
 format_w_s2 | b       | formatter 'formatter_export_s'  |        6 | t
 format_r_s2 | b       | formatter 'formatter_import_s'  |        6 | f
(4 rows)

    -- Write to WET    
    INSERT INTO format_w_s1 (SELECT * FROM formatsource);
INSERT 0 100
    INSERT INTO format_w_s2 (SELECT * FROM formatsource);
INSERT 0 100
    -- read from RET
    SELECT * FROM format_r_s1
    EXCEPT ALL
    SELECT * FROM formatsource;
 name | id | value1 | value2 
------+----+--------+--------
(0 rows)

    SELECT * FROM format_r_s2
    EXCEPT ALL
    SELECT * FROM formatsource;
 name | id | value1 | value2 
------+----+--------+--------
(0 rows)

    -- Read from RET
    SELECT count(*) FROM format_r_s1;
 count 
-------
   100
(1 row)

    SELECT count(*) FROM format_r_s2;
 count 
-------
   100
(1 row)

-- Test 71: Check limit of MAX_FORMAT_STRING 4096 bytes for variable length strings - text type
    --  Create format_long table for formatter long record test
    DROP TABLE IF EXISTS format_long CASCADE;
psql:/path/sql_file:1: NOTICE:  table "format_long" does not exist, skipping
DROP TABLE
    CREATE TABLE format_long (
       id       float8,
       name     text
    ) DISTRIBUTED by (id);
CREATE TABLE
    -- Check the atttypmod of column name is -1
    SELECT atttypmod FROM pg_attribute
    WHERE attrelid = 'format_long'::regclass
    AND attname = 'name';
 atttypmod 
-----------
        -1
(1 row)

    -- returns atttypmod = -1
    -- Create RET and WET using demoprot and custom format UDFs
    DROP EXTERNAL TABLE IF EXISTS format_long_w;
psql:/path/sql_file:1: NOTICE:  table "format_long_w" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE format_long_w(like format_long) 
    LOCATION ('demoprot://exttabtest_test71.txt') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_export_s');
psql:/path/sql_file:1: NOTICE:  Table doesn't have 'distributed by' clause, defaulting to distribution columns from LIKE table
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS format_long_r;
psql:/path/sql_file:1: NOTICE:  table "format_long_r" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE format_long_r(like format_long) 
    LOCATION ('demoprot://exttabtest_test71.txt') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_import_s');
CREATE EXTERNAL TABLE
    -- Loading each record with 4000 characters, less than 4096 bytes
    truncate table format_long;
TRUNCATE TABLE
    insert into format_long select 1.0,i from repeat('oxo1', 1000) i;
INSERT 0 1
    insert into format_long select 2.0,i from repeat('oxo2', 1000) i;
INSERT 0 1
    insert into format_long select 3.0,i from repeat('oxo3', 1000) i;
INSERT 0 1
    insert into format_long select 4.0,i from repeat('oxo4', 1000) i;
INSERT 0 1
    -- Check distribution is even
    select gp_segment_id,count(*) from format_long 
    group by gp_segment_id 
    order by gp_segment_id;
 gp_segment_id | count 
---------------+-------
             0 |     1
             1 |     3
(2 rows)

    -- Write to WET
    -- insert should be successful
    INSERT INTO format_long_w (SELECT * FROM format_long);
INSERT 0 4
    -- INSERT 0 4
    -- Read from RET
    select count(*) from format_long_r;
 count 
-------
     4
(1 row)

    -- returns count = 4
    -- Now loading each record with 5000 characters, more than 4096 bytes for each record
    truncate table format_long;
TRUNCATE TABLE
    insert into format_long select 1.0,i from repeat('oxox1', 1000) i;
INSERT 0 1
    insert into format_long select 2.0,i from repeat('oxox2', 1000) i;
INSERT 0 1
    insert into format_long select 3.0,i from repeat('oxox3', 1000) i;
INSERT 0 1
    insert into format_long select 4.0,i from repeat('oxox4', 1000) i;
INSERT 0 1
    -- Write to WET
    -- insert should fail since MAX_FORMAT_STRING (4096) is exceeded
    INSERT INTO format_long_w (SELECT * FROM format_long);
psql:/path/sql_file:1: ERROR:  formatter_export: buffer too small (gpformatter.c:182)  (seg0 rh55-qavm55:7532 pid=22752) (cdbdisp.c:1453)
    -- ERROR:  formatter_export: buffer too small (gpformatter.c:182)  (seg2 rh55-qavm58:5532 pid=20093) 
-- Test 72: Verify limit of MAX_FORMAT_STRING 4096 bytes does not apply to fixed length strings - varchar()
-- MAX_FORMAT_STRING limit should not apply to fixed length strings (char or varchar)
    --  Create format_long table for formatter long record test
    DROP TABLE IF EXISTS format_long CASCADE;
DROP TABLE
    CREATE TABLE format_long (
       id       float8,
       name     varchar(6000)
    ) DISTRIBUTED by (id);
CREATE TABLE
    -- Check the atttypmod of name > 0
    SELECT atttypmod FROM pg_attribute
    WHERE attrelid = 'format_long'::regclass
    AND attname = 'name';
 atttypmod 
-----------
      6004
(1 row)

    -- returns atttypmod = 6004
    -- Create RET and WET using demoprot and custom format UDFs
    DROP EXTERNAL TABLE IF EXISTS format_long_w;
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE format_long_w(like format_long) 
    LOCATION ('demoprot://exttabtest_test72.txt') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_export_s');
psql:/path/sql_file:1: NOTICE:  Table doesn't have 'distributed by' clause, defaulting to distribution columns from LIKE table
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS format_long_r;
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE format_long_r(like format_long) 
    LOCATION ('demoprot://exttabtest_test72.txt') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_import_s');
CREATE EXTERNAL TABLE
    -- Now loading each record with 5000 characters, more than 4096 bytes for each record
    truncate table format_long;
TRUNCATE TABLE
    insert into format_long select 1.0,i from repeat('oxox1', 1000) i;
INSERT 0 1
    insert into format_long select 2.0,i from repeat('oxox2', 1000) i;
INSERT 0 1
    insert into format_long select 3.0,i from repeat('oxox3', 1000) i;
INSERT 0 1
    insert into format_long select 4.0,i from repeat('oxox4', 1000) i;
INSERT 0 1
    -- Write to WET
    -- insert should be successful
    INSERT INTO format_long_w (SELECT * FROM format_long);
INSERT 0 4
    -- INSERT 0 4
    -- Read from RET
    select count(*) from format_long_r;
 count 
-------
     4
(1 row)

    -- returns count = 4
-- Test 73: Interlacing short and long record, testing FMT_NEED_MORE_DATA
-- When loading data from RET, long record may trigger FORMATTER_RETURN_NOTIFICATION(fcinfo, FMT_NEED_MORE_DATA).
-- Verify the data can be loaded successfully and should exactly match the source records.
    --  Create format_long table for formatter long record test
    DROP TABLE IF EXISTS format_long CASCADE;
DROP TABLE
    CREATE TABLE format_long (
       id       float8,
       name     varchar(5000)
    ) DISTRIBUTED by (id);
CREATE TABLE
    -- Check the atttypmod of name > 0
    SELECT atttypmod FROM pg_attribute
    WHERE attrelid = 'format_long'::regclass
    AND attname = 'name';
 atttypmod 
-----------
      5004
(1 row)

    -- returns atttypmod = 5004
    -- Create RET and WET using demoprot and custom format UDFs
    DROP EXTERNAL TABLE IF EXISTS format_long_w;
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE format_long_w(like format_long) 
    LOCATION ('demoprot://exttabtest_test73.txt') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_export_s');
psql:/path/sql_file:1: NOTICE:  Table doesn't have 'distributed by' clause, defaulting to distribution columns from LIKE table
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS format_long_r;
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE format_long_r(like format_long) 
    LOCATION ('demoprot://exttabtest_test73.txt') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_import_s');
CREATE EXTERNAL TABLE
    -- Loading short and long records alternatively.
    -- This should trigger FORMATTER_RETURN_NOTIFICATION(fcinfo, FMT_NEED_MORE_DATA)
    -- However not really sure about this.
    truncate table format_long;
TRUNCATE TABLE
    insert into format_long select 1.0,'oxo1';
INSERT 0 1
    insert into format_long select 2.0,i from repeat('oxo2', 1000) i;
INSERT 0 1
    insert into format_long select 3.0,'oxo3';
INSERT 0 1
    insert into format_long select 4.0,i from repeat('oxo4', 1000) i;
INSERT 0 1
    -- Write to WET
    -- insert should be successful
    INSERT INTO format_long_w (SELECT * FROM format_long);
INSERT 0 4
    -- INSERT 0 4
    -- Read from RET
    select count(*) from format_long_r;
 count 
-------
     4
(1 row)

    -- returns count = 4
    -- read from RET, both should return 0
    SELECT * FROM format_long_r
    EXCEPT ALL
    SELECT * FROM format_long;
 id | name 
----+------
(0 rows)

-- Test 74: Unsupported data format, using INT
-- SAS example formatter only support String and Float types. For other types of data (like INT), it throws error "unsupported data type"
    --  Create format_long table for formatter long record test
    DROP TABLE IF EXISTS format_long CASCADE;
DROP TABLE
    CREATE TABLE format_long (
       id       int,
       name     text
    ) DISTRIBUTED by (id);
CREATE TABLE
    -- Create RET and WET using demoprot and custom format UDFs
    DROP EXTERNAL TABLE IF EXISTS format_long_w;
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE format_long_w(like format_long) 
    LOCATION ('demoprot://format_long_test14') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_export_s');
psql:/path/sql_file:1: NOTICE:  Table doesn't have 'distributed by' clause, defaulting to distribution columns from LIKE table
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS format_long_r;
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE format_long_r(like format_long) 
        -- using source data file format_long_test13 created by previous test
    LOCATION ('demoprot://format_long_test13')
    FORMAT 'CUSTOM' (FORMATTER='formatter_import_s');
CREATE EXTERNAL TABLE
    -- Now loading each record with 4000 characters, less than 4096 bytes for each record
    truncate table format_long;
TRUNCATE TABLE
    insert into format_long select 1,'oxo1';
INSERT 0 1
    insert into format_long select 2,'oxo2';
INSERT 0 1
    insert into format_long select 3,'oxo3';
INSERT 0 1
    insert into format_long select 4,'oxo4';
INSERT 0 1
    -- Write to WET
    -- insert should fail since INT type is not supported
    INSERT INTO format_long_w (SELECT * FROM format_long);
psql:/path/sql_file:1: ERROR:  formatter_export error: unsupported data type (gpformatter.c:100)  (seg1 rh55-qavm55:7533 pid=27134) (cdbdisp.c:1453)
    -- ERROR:  formatter_export error: unsupported data type (gpformatter.c:100)  (seg2 rh55-qavm58:5532 pid=20668) (cdbdisp.c:1458)
    -- Read from RET using data file format_long_test13 create by previous test
    -- select should fail since INT type is not supported
    select count(*) from format_long_r;
psql:/path/sql_file:1: ERROR:  demoprot_import: could not open file "format_long_test13" for reading: No such file or directory  (seg1 slice1 rh55-qavm55:7533 pid=27134)
DETAIL:  External table format_long_r
    -- ERROR:  formatter_import error: unsupported data type (gpformatter.c:256)  (seg1 slice1 rh55-qavm57:5533 pid=20204) (cdbdisp.c:1458)
-- Test 75: External table contains dropped columns
-- SAS example formatter does NOT support dropping column from external table (both RET and WET).
-- Both import and export operations will fail. This is expected.
    --  Create example source table formatsource
    DROP TABLE IF EXISTS formatsource CASCADE;
DROP TABLE
    CREATE TABLE formatsource (
       id       float8,
       name     text, 
       value1   float8
    ) DISTRIBUTED by (id);
CREATE TABLE
    -- Create RET and WET using demoprot and custom format UDFs
    DROP EXTERNAL TABLE IF EXISTS format_w;
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE format_w(like formatsource) 
    LOCATION ('demoprot://format_test15') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_export_s');
psql:/path/sql_file:1: NOTICE:  Table doesn't have 'distributed by' clause, defaulting to distribution columns from LIKE table
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS format_r;
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE format_r(like formatsource) 
        -- using source data file format_long_test13 created by previous test
    LOCATION ('demoprot://format_long_test13') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_import_s');
CREATE EXTERNAL TABLE
    -- Drop colum value1 from source table formatsource
    ALTER TABLE formatsource DROP COLUMN value1;
ALTER TABLE
    -- Drop colum value1 from RET and WET
    ALTER EXTERNAL TABLE format_r DROP COLUMN value1;
ALTER EXTERNAL TABLE
    ALTER EXTERNAL TABLE format_w DROP COLUMN value1;
ALTER EXTERNAL TABLE
    -- Loading records 
    truncate table formatsource;
TRUNCATE TABLE
    insert into formatsource select 1,'oxo1';
INSERT 0 1
    insert into formatsource select 2,'oxo2';
INSERT 0 1
    insert into formatsource select 3,'oxo3';
INSERT 0 1
    insert into formatsource select 4,'oxo4';
INSERT 0 1
    -- Write to WET
    -- insert should failed because of dropped column value1
    INSERT INTO format_w (SELECT * FROM formatsource);
psql:/path/sql_file:1: ERROR:  formatter_export: dropped columns (gpformatter.c:80)  (seg0 rh55-qavm55:7532 pid=27212) (cdbdisp.c:1453)
    -- ERROR:  formatter_export: dropped columns (gpformatter.c:80)  (seg1 rh55-qavm57:5533 pid=20454) (cdbdisp.c:1458)
    -- Read from RET using data file format_long_test13 create by previous test
    select count(*) from format_r;
psql:/path/sql_file:1: ERROR:  demoprot_import: could not open file "format_long_test13" for reading: No such file or directory  (seg0 slice1 rh55-qavm55:7532 pid=27212)
DETAIL:  External table format_r
    -- ERROR:  formatter_import: dropped columns (gpformatter.c:244)  (seg2 slice1 rh55-qavm58:5532 pid=20911) (cdbdisp.c:1458)
-- Test 76: External table contains added column
-- Add column to external table is fine.
-- The value of the added column would be either null or NaN, depends on the data type.
    --  Create example source table formatsource
    DROP TABLE IF EXISTS formatsource CASCADE;
DROP TABLE
    CREATE TABLE formatsource (
       id       float8,
       name     char(10)
    ) DISTRIBUTED by (id);
CREATE TABLE
    -- Create RET and WET using demoprot and custom format UDFs
    DROP EXTERNAL TABLE IF EXISTS format_w;
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE format_w(like formatsource) 
    LOCATION ('demoprot://exttabtest_test76.txt') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_export_s');
psql:/path/sql_file:1: NOTICE:  Table doesn't have 'distributed by' clause, defaulting to distribution columns from LIKE table
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS format_r;
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE format_r(like formatsource) 
    LOCATION ('demoprot://exttabtest_test76.txt') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_import_s');
CREATE EXTERNAL TABLE
    -- Add column value1 to RET and WET
    ALTER EXTERNAL TABLE format_r ADD COLUMN value1 float8;
ALTER EXTERNAL TABLE
    ALTER EXTERNAL TABLE format_w ADD COLUMN value1 float8;
ALTER EXTERNAL TABLE
    -- Loading records 
    truncate table formatsource;
TRUNCATE TABLE
    insert into formatsource select 1,'oxo1';
INSERT 0 1
    insert into formatsource select 2,'oxo2';
INSERT 0 1
    insert into formatsource select 3,'oxo3';
INSERT 0 1
    insert into formatsource select 4,'oxo4';
INSERT 0 1
    -- Write to WET
    -- insert should be successful
    INSERT INTO format_w (SELECT * FROM formatsource);
INSERT 0 4
    -- INSERT 0 4
    -- Read from RET 
    select id, value1 from format_r order by id;
 id | value1 
----+--------
  1 |    NaN
  2 |    NaN
  3 |    NaN
  4 |    NaN
(4 rows)

-- Test 77: data with null values
-- SAS example formatter casts null value to:
-- * null for String
-- * NaN for Float8 
    --  Create example source table formatsource
    DROP TABLE IF EXISTS formatsource CASCADE;
DROP TABLE
    CREATE TABLE formatsource (
       id       float8,
       name     text, 
       value1   float8
    ) DISTRIBUTED by (id);
CREATE TABLE
    -- Create RET and WET using demoprot and custom format UDFs
    DROP EXTERNAL TABLE IF EXISTS format_w;
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE format_w(like formatsource) 
    LOCATION ('demoprot://exttabtest_test77.txt') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_export_s');
psql:/path/sql_file:1: NOTICE:  Table doesn't have 'distributed by' clause, defaulting to distribution columns from LIKE table
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS format_r;
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE format_r(like formatsource) 
    LOCATION ('demoprot://exttabtest_test77.txt') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_import_s');
CREATE EXTERNAL TABLE
    -- Loading records 
    truncate table formatsource;
TRUNCATE TABLE
    insert into formatsource values (1,null,null);
INSERT 0 1
    insert into formatsource values (2,null,null);
INSERT 0 1
    insert into formatsource values (3,null,null);
INSERT 0 1
    insert into formatsource values (4,null,null);
INSERT 0 1
    -- Write to WET
    -- insert should be successful
    INSERT INTO format_w (SELECT * FROM formatsource);
INSERT 0 4
    -- INSERT 0 4
    -- Read from RET 
    select * from format_r where name is null order by id;
 id | name | value1 
----+------+--------
  1 |      |    NaN
  2 |      |    NaN
  3 |      |    NaN
  4 |      |    NaN
(4 rows)

-- Test 78: Read from empty data file
-- SAS example formatter can correctly handle empty input, either from /dev/null or from empty input data files.
    --  Create example source table formatsource
    DROP TABLE IF EXISTS formatsource CASCADE;
DROP TABLE
    CREATE TABLE formatsource (
       id       float8,
       name     text, 
       value1   float8
    ) DISTRIBUTED by (id);
CREATE TABLE
    -- Create RET with custom format using /dev/null as source file
    DROP EXTERNAL TABLE IF EXISTS format_r;
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE format_r(like formatsource) 
    LOCATION ('demoprot:///dev/null') 
    FORMAT 'CUSTOM' (FORMATTER='formatter_import_s');
CREATE EXTERNAL TABLE
    -- Read from RET using /dev/null
    select * from format_r;
 id | name | value1 
----+------+--------
(0 rows)

-- Test 81: Protocol validator - create protocol with validator
-- create the protocol read and write STABLE functions
CREATE OR REPLACE FUNCTION write_to_file() RETURNS integer AS
'$libdir/gpextprotocol.so', 'demoprot_export' LANGUAGE C STABLE;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION read_from_file() RETURNS integer AS
'$libdir/gpextprotocol.so', 'demoprot_import' LANGUAGE C STABLE;
CREATE FUNCTION
-- create validation STABLE function
CREATE OR REPLACE FUNCTION url_validator() RETURNS void AS
   '$libdir/gpextprotocol.so', 'demoprot_validate_urls' LANGUAGE C STABLE;
CREATE FUNCTION
-- declare the protocol name along with in/out funcs and validator func
DROP PROTOCOL IF EXISTS demoprot;
DROP PROTOCOL
CREATE PROTOCOL demoprot (
    readfunc  = read_from_file, 
    writefunc = write_to_file,
    validatorfunc = url_validator
);
CREATE PROTOCOL
    -- Test 82: At ext table create time, validate number of URLs cannot exceed number of primary segments
    CREATE READABLE EXTERNAL TABLE exttabtest_5url_r(like exttabtest)
        LOCATION('demoprot://test1.txt', 
                 'demoprot://test2.txt',
                 'demoprot://test3.txt',
                 'demoprot://test4.txt',
                 'demoprot://test5.txt') 
    FORMAT 'text';
psql:/path/sql_file:1: ERROR:  more than 2 urls aren't allowed in this protocol
    -- ERROR:  more than 2 urls aren't allowed in this protocol
    -- Test 83: At ext table create time, url string cannot contain "secured_directory"
    CREATE READABLE EXTERNAL TABLE exttabtest_3url_r(like exttabtest)
        LOCATION('demoprot://test1.txt', 
                 'demoprot://secured_directory/test2.txt') 
    FORMAT 'text';
psql:/path/sql_file:1: ERROR:  using 'secured_directory' in a url isn't allowed
    -- ERROR:  using 'secured_directory' in a url isn't allowed
-- Test 4: Negative - validator protocol function must return void
-- create the validator function and returns integer, which is invalid
DROP FUNCTION IF EXISTS url_validator();
DROP FUNCTION
CREATE OR REPLACE FUNCTION url_validator() RETURNS integer AS
   '$libdir/gpextprotocol.so', 'demoprot_validate_urls' LANGUAGE C STABLE;
CREATE FUNCTION
-- declare the protocol name along with in/out funcs and validator func
DROP PROTOCOL IF EXISTS demoprot;
DROP PROTOCOL
CREATE PROTOCOL demoprot (
readfunc = read_from_file,
writefunc = write_to_file,
validatorfunc = url_validator
);
psql:/path/sql_file:1: ERROR:  validator protocol function url_validator() must return void
-- Test 5: Negative - invalid protocol attribute name for validator function: must be "validatorfunc"
-- declare the protocol using invalid attribute name "validatorproc"
    DROP PROTOCOL IF EXISTS demoprot;
psql:/path/sql_file:1: NOTICE:  protocol "demoprot" does not exist, skipping
DROP PROTOCOL
    CREATE PROTOCOL demoprot (
        readfunc  = read_from_file, 
        writefunc = write_to_file,
        validatorproc = url_validator
    );
psql:/path/sql_file:1: ERROR:  protocol attribute "validatorproc" not recognized
-- ERROR: protocol attribute "validatorproc" not recognized
-- Test 86: validation only happens at ext table create time, not execution time
    -- create an external table using demoprot protocol that does NOT have validator defined
    -- The external table can be created with potential offending issues,
    -- e.g., using "secured_directory" in the url
    -- declare the protocol name along with in/out funcs and WITHOUT validator
    DROP PROTOCOL IF EXISTS demoprot;
psql:/path/sql_file:1: NOTICE:  protocol "demoprot" does not exist, skipping
DROP PROTOCOL
    CREATE PROTOCOL demoprot (
        readfunc  = read_from_file, 
        writefunc = write_to_file
    );
CREATE PROTOCOL
    -- create ext table with offending url (contains "secured_directory")
    CREATE READABLE EXTERNAL TABLE exttabtest_offending_url_r(like exttabtest)
        LOCATION('demoprot://secured_directory/exttabtest.txt') 
    FORMAT 'text';
CREATE EXTERNAL TABLE
    -- You should get "No such file or directory" error, which means validator is not enforced during execution time:
    -- ERROR:  demoprot_import: could not open file "secured_directory/exttabtest.txt" for reading: No such file or directory 
    -- Create validator function url_validator()
    DROP FUNCTION IF EXISTS url_validator();
DROP FUNCTION
    CREATE OR REPLACE FUNCTION url_validator() RETURNS void AS
        '$libdir/gpextprotocol.so', 'demoprot_validate_urls' LANGUAGE C STABLE;
CREATE FUNCTION
    -- After successfully created ext table, replace protocol with validator
    DROP PROTOCOL IF EXISTS demoprot;
DROP PROTOCOL
    CREATE PROTOCOL demoprot (
        readfunc  = read_from_file, 
        writefunc = write_to_file,
        validatorfunc = url_validator
    );
CREATE PROTOCOL
    -- Verify that validator will NOT do validation to existing ext table. should see results be returned successfully
    select count(*) from exttabtest_offending_url_r; 
psql:/path/sql_file:1: ERROR:  demoprot_import: could not open file "secured_directory/exttabtest.txt" for reading: No such file or directory  (seg0 slice1 rh55-qavm55:7532 pid=27551)
DETAIL:  External table exttabtest_offending_url_r, file demoprot://secured_directory/exttabtest.txt
    -- Drop the existing ext table and recreate
    -- Validation should take effect and cannot create the ext table
    DROP EXTERNAL TABLE IF EXISTS exttabtest_offending_url_r;
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE exttabtest_offending_url_r(like exttabtest)
        LOCATION('demoprot://secured_directory/exttabtest.txt') 
    FORMAT 'text';
psql:/path/sql_file:1: ERROR:  using 'secured_directory' in a url isn't allowed
-- ERROR: using 'secured_directory' in a url isn't allowed
-- Create multiple roles with login option so that they can be used for protocol permission tests and alter protocol tests
    -- Create another suerpuer user demoprot_super
    drop role if exists demoprot_super;
DROP ROLE
    create role demoprot_super with SUPERUSER LOGIN;
CREATE ROLE
    -- Create a non-privileged user demoprot_nopriv
    drop role if exists demoprot_nopriv;
DROP ROLE
    create role demoprot_nopriv with login ;
CREATE ROLE
psql:/path/sql_file:1: NOTICE:  resource queue required -- using default resource queue "pg_default"
    -- Create a gphdfs_user with CREATEEXTTABLE privilege using gphdfs protocol
    drop role if exists gphdfs_user;
DROP ROLE
    create role gphdfs_user with login CREATEEXTTABLE (protocol='gphdfs');
psql:/path/sql_file:1: WARNING:  GRANT/REVOKE on gphdfs is deprecated
HINT:  Issue the GRANT or REVOKE on the protocol itself
psql:/path/sql_file:1: NOTICE:  resource queue required -- using default resource queue "pg_default"
CREATE ROLE
    -- WARNING:  GRANT/REVOKE on gphdfs is deprecated
    -- HINT:  Issue the GRANT or REVOKE on the protocol itself
    -- NOTICE:  resource queue required -- using default resource queue "pg_default"
    -- CREATE ROLE
-- Test 92: Rename existing protocol
    -- Create external RET and WET
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w;
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w(like exttabtest)
        LOCATION('demoprot://exttabtest.txt') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r;
psql:/path/sql_file:1: NOTICE:  table "exttabtest_r" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE exttabtest_r(like exttabtest)
        LOCATION('demoprot://exttabtest.txt') 
    FORMAT 'text';
CREATE EXTERNAL TABLE
    -- write to WET
    SELECT * FROM clean_exttabtest_files;
 stdout 
--------
(0 rows)

    INSERT INTO exttabtest_w (SELECT * FROM exttabtest);
INSERT 0 100
    -- Rename existing protocol
    ALTER PROTOCOL demoprot RENAME to demoprot_new;
ALTER PROTOCOL
    -- checking pg_extprotocol
    select ptcname, ptctrusted 
    from pg_extprotocol 
    where ptcname like 'demoprot%' order by ptcname;
   ptcname    | ptctrusted 
--------------+------------
 demoprot_new | f
(1 row)

    -- Check existing ext table that created still refer to old protocol name
    \d exttabtest_r
    External table "exttableext.exttabtest_r"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 id     | integer               | 
 name   | character varying(20) | 
 value1 | integer               | 
 value2 | integer               | 
Type: readable
Encoding: UTF8
Format type: text
Format options: delimiter '	' null '\N' escape '\'
External location: demoprot://exttabtest.txt

    -- Create a new ext table using the new protocol name
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_new;
psql:/path/sql_file:1: NOTICE:  table "exttabtest_w_new" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_new(like exttabtest)
        LOCATION('demoprot_new://exttabtest.txt') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_new;
psql:/path/sql_file:1: NOTICE:  table "exttabtest_r_new" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE exttabtest_r_new(like exttabtest)
        LOCATION('demoprot_new://exttabtest.txt') 
    FORMAT 'text';
CREATE EXTERNAL TABLE
    -- Verify access old ext table that referencing old protocol name would fail
    -- This is expected.
    select * from exttabtest_r;
psql:/path/sql_file:1: ERROR:  protocol "demoprot" does not exist  (seg0 slice1 rh55-qavm55:7532 pid=18394)
    -- ERROR:  protocol "demoprot" does not exist  (seg1 slice1 rh55-qavm57:5533 pid=8558)
    -- Verify access new ext table would be successful
    -- However demoprot implementation prevents using any other protocol name than "demoprot"
    -- therefore the error is expected.
    select count(*) from exttabtest_r_new;
psql:/path/sql_file:1: ERROR:  internal error: demoprot called with a different protocol (demoprot_new) (gpextprotocol.c:86)  (seg0 slice1 rh55-qavm55:7532 pid=18394) (cdbdisp.c:1453)
DETAIL:  External table exttabtest_r_new, file demoprot_new://exttabtest.txt
    -- Rename protocol name back to demoprot
    ALTER PROTOCOL demoprot_new RENAME to demoprot;
ALTER PROTOCOL
    -- Verify access old ext table that referencing old protocol name would succeed
    select count(*) from exttabtest_r;
 count 
-------
   100
(1 row)

-- Test 93: Trusted protocol - Change ownership
-- The owner of trusted protocol (not a superuser) can create external table
-- using the protocol, even without SELECT or INSERT permission granted
    -- login as superuser huangh5
    -- create trusted protocol demoprot
    DROP PROTOCOL IF EXISTS demoprot;
DROP PROTOCOL
    CREATE TRUSTED PROTOCOL demoprot (
        readfunc = read_from_file_stable,
        writefunc = write_to_file_stable
    );
CREATE PROTOCOL
    -- Check the owner of trusted protocl demoprot is current user
    select ptcname, ptctrusted 
    from pg_extprotocol join pg_user 
    on pg_extprotocol.ptcowner=pg_user.usesysid
    where ptcname='demoprot' 
    and usename=(select user);
 ptcname  | ptctrusted 
----------+------------
 demoprot | t
(1 row)

    -- Change protocol demoprot owner to non-privileged user "demoprot_nopriv"
    ALTER PROTOCOL demoprot OWNER TO demoprot_nopriv;
ALTER PROTOCOL
    -- Drop the existing external RET and WET
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_new;
DROP EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_new;
DROP EXTERNAL TABLE
    -- Check the owner of demoprot is demoprot_nopriv
    -- and no protocol permission has been granted
    select ptcname, ptctrusted,ptcacl, usename 
    from pg_extprotocol join pg_user 
    on pg_extprotocol.ptcowner=pg_user.usesysid
    where ptcname='demoprot';
 ptcname  | ptctrusted | ptcacl |     usename     
----------+------------+--------+-----------------
 demoprot | t          |        | demoprot_nopriv
(1 row)

    -- Check a dependency entry is added into pg_shdepend table
    select count(*)
    from pg_shdepend, pg_extprotocol, pg_user 
    where pg_extprotocol.ptcowner=pg_user.usesysid 
    and pg_shdepend.objid=pg_extprotocol.oid 
    and pg_extprotocol.ptcname='demoprot' 
    and pg_user.usename='demoprot_nopriv';
 count 
-------
     1
(1 row)

    -- As superuser, GRANT SELECT permission on heap table "exttabtest"
    -- to non-privileged user "demoprot_nopriv" so that this user
    -- can try to create external table using format: (like exttabtest)
    GRANT SELECT ON exttabtest TO demoprot_nopriv;
GRANT
    -- As superuser, REVOKE ALL privileges on protocol from owner demoprot_nopriv
    REVOKE ALL ON PROTOCOL demoprot FROM demoprot_nopriv;
REVOKE
    -- connect as non-privileged user "demoprot_nopriv"
    -- which is the owner of trusted demoprot 
    SET ROLE demoprot_nopriv;
SET
    select user;
  current_user   
-----------------
 demoprot_nopriv
(1 row)

   -- Verify that even though no permission has been 
    -- granted to non-privileged user "demoprot_nopriv",
    -- this user can still create new ext tables 
    -- using trusted protocol demoprot, because the user 
    -- is the owner of the protocol demoprot.
    CREATE READABLE EXTERNAL TABLE exttabtest_r_new (like exttabtest)
        LOCATION('demoprot://exttabtest_new.txt') 
    FORMAT 'text';
CREATE EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_new(like exttabtest)
        LOCATION('demoprot://exttabtest_new.txt') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
CREATE EXTERNAL TABLE
    -- Verify non-privileged user "demoprot_nopriv" can export data via new created WET exttabtest_w_new
    SELECT * FROM clean_exttabtest_files;
 stdout 
--------
(0 rows)

    INSERT INTO exttabtest_w_new (SELECT * FROM exttabtest);
INSERT 0 100
    -- Verify non-privileged user "demoprot_nopriv" can load data via new created RET exttabtest_r_new
    select count(*) from exttabtest_r_new;
 count 
-------
   100
(1 row)

    -- Verified owner (non superuser) can drop the protocol
    DROP PROTOCOL demoprot;
DROP PROTOCOL
RESET ROLE;
RESET
-- Test 94: Untrusted protocol - Change ownership
-- The owner of untrusted protocol (not a superuser) can still create external table
-- using the untrusted protocol.
    -- connect as superuser
    -- create untrusted protocol demoprot
    DROP PROTOCOL IF EXISTS demoprot;
psql:/path/sql_file:1: NOTICE:  protocol "demoprot" does not exist, skipping
DROP PROTOCOL
    CREATE PROTOCOL demoprot (
        readfunc = read_from_file_stable,
        writefunc = write_to_file_stable
    );
CREATE PROTOCOL
    -- Try to change protocol demoprot owner to non-privileged user "demoprot_nopriv"
    -- Should get: ERROR:  untrusted protocol "demoprot" can't be owned by non superuser
    -- Therefore the owner of trusted protocl demoprot is still the current superuser
    ALTER PROTOCOL demoprot OWNER TO demoprot_nopriv;
psql:/path/sql_file:1: ERROR:  untrusted protocol "demoprot" can't be owned by non superuser
    -- As superuser, GRANT SELECT permission on heap table "exttabtest"
    -- to non-privileged user "demoprot_nopriv" so that this user
    -- can try to create external table using format: (like exttabtest)
    GRANT SELECT ON exttabtest TO demoprot_nopriv;
GRANT
    -- As superuser, REVOKE ALL privileges on protocol from owner demoprot_nopriv
    -- The error is correctly shown 
    REVOKE ALL ON PROTOCOL demoprot FROM demoprot_nopriv;
psql:/path/sql_file:1: ERROR:  protocol "demoprot" is not trusted
HINT:  Only superusers may use untrusted protocols.
    -- ERROR:  protocol "demoprot" is not trusted
    -- login as non-privileged user "demoprot_nopriv"
    SET ROLE demoprot_nopriv;
SET
    select user;
  current_user   
-----------------
 demoprot_nopriv
(1 row)

    -- Verify that no permission has been 
    -- granted to non-privileged user "demoprot_nopriv",
    -- this user can cannot create new ext tables 
    -- using untrusted protocol demoprot.
    CREATE READABLE EXTERNAL TABLE exttabtest_r_new2 (like exttabtest)
        LOCATION('demoprot://exttabtest_new.txt') 
    FORMAT 'text';
psql:/path/sql_file:1: ERROR:  permission denied for external protocol demoprot
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_new2 (like exttabtest)
        LOCATION('demoprot://exttabtest_new.txt') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
psql:/path/sql_file:1: ERROR:  permission denied for external protocol demoprot
    -- Verify non-privileged user "demoprot_nopriv" can export data via existing WET exttabtest_w_new
    SELECT * FROM clean_exttabtest_files;
 stdout 
--------
(0 rows)

    INSERT INTO exttabtest_w_new (SELECT * FROM exttabtest);
INSERT 0 100
    -- Verify non-privileged user "demoprot_nopriv" can load data via existing RET exttabtest_r_new
    select count(*) from exttabtest_r_new;
 count 
-------
   100
(1 row)

    -- Verified non superuser cannot drop the protocol
    DROP PROTOCOL demoprot;
psql:/path/sql_file:1: ERROR:  must be owner of external protocol demoprot
-- Test 95: Alter protocol negative tests
    ALTER PROTOCOL demoprot (
        readfunc = read_from_file_immutable,
        writefunc = write_to_file_immutable
    );
psql:/path/sql_file:1: ERROR:  syntax error at or near "("
LINE 1: ALTER PROTOCOL demoprot (
                                ^
--    ERROR:  syntax error at or near "("
    ALTER PROTOCOL demoprot update readfunc = read_from_file_immutable;
psql:/path/sql_file:1: ERROR:  syntax error at or near "update"
LINE 1: ALTER PROTOCOL demoprot update readfunc = read_from_file_imm...
                                ^
--    ERROR:  syntax error at or near "update"
    ALTER PROTOCOL demoprot trusted;
psql:/path/sql_file:1: ERROR:  syntax error at or near "trusted"
LINE 1: ALTER PROTOCOL demoprot trusted;
                                ^
--    ERROR:  syntax error at or near "trusted"
RESET ROLE;
RESET
-- Test 96: Untrusted protocol - Superuser
-- Non-owner superuser does not have any limitation when using non-trusted protocol.
    -- login as superuser huangh5
    -- create untrusted protocol demoprot
    DROP PROTOCOL IF EXISTS demoprot;
psql:/path/sql_file:1: NOTICE:  protocol "demoprot" does not exist, skipping
DROP PROTOCOL
    CREATE PROTOCOL demoprot (
        readfunc = read_from_file_stable,
        writefunc = write_to_file_stable
    );
CREATE PROTOCOL
    -- Check the owner of trusted protocl demoprot is current superuser
    select ptcname, ptctrusted 
    from pg_extprotocol join pg_user 
    on pg_extprotocol.ptcowner=pg_user.usesysid
    where ptcname='demoprot' 
    and usename=(select user);
 ptcname  | ptctrusted 
----------+------------
 demoprot | f
(1 row)

    -- connect as a different superuser "demoprot_super"
    SET ROLE demoprot_super;
SET
    select user;
  current_user  
----------------
 demoprot_super
(1 row)

    -- Verify superuser demoprot_super can still load data via existing RET
    select count(*) from exttabtest_r;
psql:/path/sql_file:1: ERROR:  demoprot_import: could not open file "exttabtest.txt" for reading: No such file or directory  (seg0 slice1 rh55-qavm55:7532 pid=23594)
DETAIL:  External table exttabtest_r, file demoprot://exttabtest.txt
    -- Verify superuser demoprot_super can still export data via existing WET
    SELECT * FROM clean_exttabtest_files;
 stdout 
--------
(0 rows)

    INSERT INTO exttabtest_w (SELECT * FROM exttabtest);
INSERT 0 100
    -- Verify superuser "demoprot_super" can create new ext table using untrusted protocol demoprot
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_new;
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE exttabtest_r_new(like exttabtest)
        LOCATION('demoprot://exttabtest_new.txt') 
    FORMAT 'text';
CREATE EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_new;
DROP EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_new(like exttabtest)
        LOCATION('demoprot://exttabtest_new.txt') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
CREATE EXTERNAL TABLE
    -- Verify superuser demoprot_super can still export data via new created WET exttabtest_w_new
    INSERT INTO exttabtest_w_new (SELECT * FROM exttabtest);
INSERT 0 100
    -- Verify superuser demoprot_super can access new created RET exttabtest_r_new
    select count(*) from exttabtest_r_new;
 count 
-------
   100
(1 row)

RESET ROLE;
RESET
  
-- Test 97: Non-trusted protocol - non-priv user
-- Non-privileged user cannot use non-trusted protocol to create external table.
-- With granted permissions on existing external table, Non-privileged user can access existing WET and RET
    -- As superuser, GRANT SELECT permission on RET
    -- and INSERT permission on WET to on-privileged user "demoprot_nopriv"
    -- to non-privileged user "demoprot_nopriv"
    GRANT SELECT ON exttabtest_r TO demoprot_nopriv;
GRANT
    GRANT INSERT ON exttabtest_w TO demoprot_nopriv;
GRANT
    -- As superuser, GRANT SELECT permission on heap table "exttabtest"
    -- to non-privileged user "demoprot_nopriv" so that this user
    -- can try to create external table using format: (like exttabtest)
    GRANT SELECT ON exttabtest TO demoprot_nopriv;
GRANT
    -- connect as non-privileged user "demoprot_nopriv"
    SET ROLE demoprot_nopriv;
SET
    select user;
  current_user   
-----------------
 demoprot_nopriv
(1 row)

    -- Check current user has the SELECT permission on 'exttabtest_r'
    select has_table_privilege('exttabtest_r','select');
 has_table_privilege 
---------------------
 t
(1 row)

    -- Check current user has the INSERT permission on 'exttabtest_w'
    select has_table_privilege('exttabtest_w','insert');
 has_table_privilege 
---------------------
 t
(1 row)

    -- Check current user has the SELECT permission on 'exttabtest'
    select has_table_privilege('exttabtest','select');
 has_table_privilege 
---------------------
 t
(1 row)

    -- Verify with INSERT permission granted, non-privileged user "demoprot_nopriv" 
    -- can export data via WET that was created using non-trusted protocol
    SELECT * FROM clean_exttabtest_files;
 stdout 
--------
(0 rows)

    INSERT INTO exttabtest_w (SELECT * FROM exttabtest);
INSERT 0 100
    -- Verify with SELECT permission granted, non-privileged user "demoprot_nopriv" 
    -- can load data via RET that was created using non-trusted protocol
    select count(*) from exttabtest_r;
 count 
-------
   100
(1 row)

    -- Verify non-privileged user "demoprot_nopriv" cannot create new ext table 
    -- using untrusted protocol demoprot
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_new2;
psql:/path/sql_file:1: NOTICE:  table "exttabtest_r_new2" does not exist, skipping
DROP EXTERNAL TABLE
    CREATE READABLE EXTERNAL TABLE exttabtest_r_new2 (like exttabtest)
        LOCATION('demoprot://exttabtest.txt') 
    FORMAT 'text';
psql:/path/sql_file:1: ERROR:  permission denied for external protocol demoprot
-- Test 98: Trusted Protocol - Negative Tests
    -- create protocol using incorrect keyword TRUST instead of TRUSTED
    DROP PROTOCOL IF EXISTS demoprot_trusted_bad;
psql:/path/sql_file:1: NOTICE:  protocol "demoprot_trusted_bad" does not exist, skipping
DROP PROTOCOL
    CREATE TRUST PROTOCOL demoprot_trusted_bad (
        readfunc = read_from_file_stable,
        writefunc = write_to_file_stable
    );
psql:/path/sql_file:1: ERROR:  syntax error at or near "TRUST"
LINE 1: CREATE TRUST PROTOCOL demoprot_trusted_bad (
               ^
    -- create protocol using incorrect keyword UNTRUSTED
    DROP PROTOCOL IF EXISTS demoprot_trusted_bad;
psql:/path/sql_file:1: NOTICE:  protocol "demoprot_trusted_bad" does not exist, skipping
DROP PROTOCOL
    CREATE UNTRUSTED PROTOCOL demoprot_trusted_bad (
        readfunc = read_from_file_stable,
        writefunc = write_to_file_stable
    );
psql:/path/sql_file:1: ERROR:  syntax error at or near "UNTRUSTED"
LINE 1: CREATE UNTRUSTED PROTOCOL demoprot_trusted_bad (
               ^
    -- create protocol using TRUSTED at wrong position
    DROP PROTOCOL IF EXISTS demoprot_trusted_bad;
psql:/path/sql_file:1: NOTICE:  protocol "demoprot_trusted_bad" does not exist, skipping
DROP PROTOCOL
    CREATE PROTOCOL TRUSTED demoprot_trusted_bad (
        readfunc = read_from_file_stable,
        writefunc = write_to_file_stable
    );
psql:/path/sql_file:1: ERROR:  syntax error at or near "demoprot_trusted_bad"
LINE 1: CREATE PROTOCOL TRUSTED demoprot_trusted_bad (
                                ^
    -- create protocol using TRUSTED at wrong position
    DROP PROTOCOL IF EXISTS demoprot_trusted_bad;
psql:/path/sql_file:1: NOTICE:  protocol "demoprot_trusted_bad" does not exist, skipping
DROP PROTOCOL
    CREATE PROTOCOL demoprot_trusted_bad TRUSTED (
        readfunc = read_from_file_stable,
        writefunc = write_to_file_stable
    );
psql:/path/sql_file:1: ERROR:  syntax error at or near "TRUSTED"
LINE 1: CREATE PROTOCOL demoprot_trusted_bad TRUSTED (
                                             ^
RESET ROLE;
RESET
-- Test 99: Trusted protocol - Grant All
-- Grant all permissions ON trusted protocol to non-privileged user
-- Non-privileged user can use trusted protocol to create external table.
    -- connect as superuser 
    -- create trusted protocol demoprot
    DROP PROTOCOL IF EXISTS demoprot;
DROP PROTOCOL
    CREATE TRUSTED PROTOCOL demoprot (
        readfunc = read_from_file_stable,
        writefunc = write_to_file_stable
    );
CREATE PROTOCOL
    -- As superuser, GRANT SELECT permission on heap table "exttabtest"
    -- to non-privileged user "demoprot_nopriv" so that this user
    -- can try to create external table using format: (like exttabtest)
    GRANT SELECT ON exttabtest TO demoprot_nopriv;
GRANT
    -- Drop existing WET and RET
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_new;
DROP EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_new;
DROP EXTERNAL TABLE
    -- As superuser, GRANT ALL privileges on protocol to non-privileged user demoprot_nopriv
    GRANT ALL ON PROTOCOL demoprot TO demoprot_nopriv;
GRANT
    -- login as non-privileged user "demoprot_nopriv"
    SET ROLE demoprot_nopriv;
SET
    select user;
  current_user   
-----------------
 demoprot_nopriv
(1 row)

    -- Verify non-privileged user "demoprot_nopriv" can create new ext table 
    -- using trusted protocol demoprot
    CREATE READABLE EXTERNAL TABLE exttabtest_r_new (like exttabtest)
        LOCATION('demoprot://exttabtest_new.txt') 
    FORMAT 'text';
CREATE EXTERNAL TABLE
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_new (like exttabtest)
        LOCATION('demoprot://exttabtest_new.txt') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
CREATE EXTERNAL TABLE
    -- Verify non-privileged user "demoprot_nopriv" can export data via new created WET exttabtest_w_new
    SELECT * FROM clean_exttabtest_files;
 stdout 
--------
(0 rows)

    INSERT INTO exttabtest_w_new (SELECT * FROM exttabtest);
INSERT 0 100
    -- Verify non-privileged user "demoprot_nopriv" can load data via new created RET exttabtest_r_new
    select count(*) from exttabtest_r_new;
 count 
-------
   100
(1 row)

RESET ROLE;
RESET
-- Test 99a: Trusted protocol - Revoke All
-- Revoke all permissions ON trusted protocol from non-privileged user
    -- connect as superuser 
    -- create trusted protocol demoprot
    DROP PROTOCOL IF EXISTS demoprot;
DROP PROTOCOL
    CREATE TRUSTED PROTOCOL demoprot (
        readfunc = read_from_file_stable,
        writefunc = write_to_file_stable
    );
CREATE PROTOCOL
    -- As superuser, GRANT SELECT permission on heap table "exttabtest"
    -- to non-privileged user "demoprot_nopriv" so that this user
    -- can try to create external table using format: (like exttabtest)
    GRANT SELECT ON exttabtest TO demoprot_nopriv;
GRANT
    -- As superuser, REVOKE ALL privileges on protocol from non-privileged user demoprot_nopriv
    -- Both SELECT and INSERT permissions are revoked
    REVOKE ALL ON PROTOCOL demoprot FROM demoprot_nopriv;
REVOKE
    -- login as non-privileged user "demoprot_nopriv"
    SET ROLE demoprot_nopriv;
SET
    select user;
  current_user   
-----------------
 demoprot_nopriv
(1 row)

    -- Verify non-privileged user "demoprot_nopriv" can still export data via existing WET exttabtest_w
    SELECT * FROM clean_exttabtest_files;
 stdout 
--------
(0 rows)

    INSERT INTO exttabtest_w (SELECT * FROM exttabtest);
INSERT 0 100
    -- Verify non-privileged user "demoprot_nopriv" can still load data via existing RET exttabtest_r
    select count(*) from exttabtest_r;
 count 
-------
   100
(1 row)

    -- Verify after permissions have been revoked
    -- non-privileged user "demoprot_nopriv" cannot create new ext table 
    -- using the trusted protocol demoprot
    CREATE READABLE EXTERNAL TABLE exttabtest_r_new (like exttabtest)
        LOCATION('demoprot://exttabtest_new.txt') 
    FORMAT 'text';
psql:/path/sql_file:1: ERROR:  permission denied for external protocol demoprot
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_new (like exttabtest)
        LOCATION('demoprot://exttabtest_new.txt') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
psql:/path/sql_file:1: ERROR:  permission denied for external protocol demoprot
RESET ROLE;
RESET
-- Test 101: Trusted protocol - Grant Select
-- Grant SELECT permission ON trusted protocol to non-privileged user
-- Non-privileged user can use trusted protocol to create readable external table.
    -- Create exttabtest_new.txt data file
    SELECT * FROM clean_exttabtest_files;
 stdout 
--------
(0 rows)

    INSERT INTO exttabtest_w (SELECT * FROM exttabtest);
INSERT 0 100
    -- As superuser, demoport is created as a trusted readonly protocol
    DROP PROTOCOL IF EXISTS demoprot;
DROP PROTOCOL
    CREATE TRUSTED PROTOCOL demoprot (
        readfunc = read_from_file_stable
    );
CREATE PROTOCOL
    -- As superuser, GRANT SELECT permission on heap table "exttabtest"
    -- to non-privileged user "demoprot_nopriv" so that this user
    -- can try to create external table using format: (like exttabtest)
    GRANT SELECT ON exttabtest TO demoprot_nopriv;
GRANT
    -- Drop existing WET and RET
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_new;
DROP EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_new;
DROP EXTERNAL TABLE
    -- As superuser, GRANT SELECT permission on read protocol to non-privileged user demoprot_nopriv
    GRANT SELECT ON PROTOCOL demoprot TO demoprot_nopriv;
GRANT
    -- login as non-privileged user "demoprot_nopriv"
    SET ROLE demoprot_nopriv;
SET
    select user;
  current_user   
-----------------
 demoprot_nopriv
(1 row)

    -- Verify non-privileged user "demoprot_nopriv" can create new readable ext table 
    -- using trusted protocol demoprot
    CREATE READABLE EXTERNAL TABLE exttabtest_r_new (like exttabtest)
        LOCATION('demoprot://exttabtest_new.txt') 
    FORMAT 'text';
CREATE EXTERNAL TABLE
    -- Verify non-privileged user "demoprot_nopriv" cannot create new writable ext table 
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_new (like exttabtest)
        LOCATION('demoprot://exttabtest_new.txt') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
psql:/path/sql_file:1: ERROR:  permission denied for external protocol demoprot
    -- Verify non-privileged user "demoprot_nopriv" can load data via new created RET exttabtest_r_new
    select count(*) from exttabtest_r_new;
psql:/path/sql_file:1: ERROR:  demoprot_import: could not open file "exttabtest_new.txt" for reading: No such file or directory  (seg0 slice1 rh55-qavm55:7532 pid=12818)
DETAIL:  External table exttabtest_r_new, file demoprot://exttabtest_new.txt
RESET ROLE;
RESET
-- Test 102: Trusted protocol - Revoke Select
-- Revoke SELECT permission ON trusted protocol from non-privileged user
    -- connect as superuser 
    -- create trusted protocol demoprot
    DROP PROTOCOL IF EXISTS demoprot;
DROP PROTOCOL
    CREATE TRUSTED PROTOCOL demoprot (
        readfunc = read_from_file_stable,
        writefunc = write_to_file_stable
    );
CREATE PROTOCOL
    -- As superuser, GRANT SELECT permission on heap table "exttabtest"
    -- to non-privileged user "demoprot_nopriv" so that this user
    -- can try to create external table using format: (like exttabtest)
    GRANT SELECT ON exttabtest TO demoprot_nopriv;
GRANT
    -- As superuser, REVOKE SElECT privilege on protocol from non-privileged user demoprot_nopriv
    REVOKE SELECT ON PROTOCOL demoprot FROM demoprot_nopriv;
REVOKE
    -- login as non-privileged user "demoprot_nopriv"
    SET ROLE demoprot_nopriv;
SET
    select user;
  current_user   
-----------------
 demoprot_nopriv
(1 row)

    -- Verify after SELECT permission has been revoked
    -- non-privileged user "demoprot_nopriv" cannot create new readable ext table 
    -- using the trusted protocol demoprot
    CREATE READABLE EXTERNAL TABLE exttabtest_r_new2 (like exttabtest)
        LOCATION('demoprot://exttabtest_new.txt') 
    FORMAT 'text';
psql:/path/sql_file:1: ERROR:  permission denied for external protocol demoprot
RESET ROLE;
RESET
-- Test 103: Trusted protocol - Grant Insert
-- Grant INSERT permission ON trusted protocol to non-privileged user
-- Non-privileged user can use trusted protocol to create writable external table.
    -- As superuser, demoport is created as a trusted readonly protocol
    DROP PROTOCOL IF EXISTS demoprot;
DROP PROTOCOL
    CREATE TRUSTED PROTOCOL demoprot (
        writefunc = write_to_file_stable
    );
CREATE PROTOCOL
    -- As superuser, GRANT SELECT permission on heap table "exttabtest"
    -- to non-privileged user "demoprot_nopriv" so that this user
    -- can try to create external table using format: (like exttabtest)
    GRANT SELECT ON exttabtest TO demoprot_nopriv;
GRANT
    -- Drop existing WET and RET
    DROP EXTERNAL TABLE IF EXISTS exttabtest_r_new;
DROP EXTERNAL TABLE
    DROP EXTERNAL TABLE IF EXISTS exttabtest_w_new;
psql:/path/sql_file:1: NOTICE:  table "exttabtest_w_new" does not exist, skipping
DROP EXTERNAL TABLE
    -- As superuser, GRANT INSERT permission on read protocol to non-privileged user demoprot_nopriv
    GRANT INSERT ON PROTOCOL demoprot TO demoprot_nopriv;
GRANT
    -- login as non-privileged user "demoprot_nopriv"
    SET ROLE demoprot_nopriv;
SET
    select user;
  current_user   
-----------------
 demoprot_nopriv
(1 row)

    -- Verify non-privileged user "demoprot_nopriv" cannot create new readable ext table 
    -- using trusted protocol demoprot
    CREATE READABLE EXTERNAL TABLE exttabtest_r_new (like exttabtest)
        LOCATION('demoprot://exttabtest_new.txt') 
    FORMAT 'text';
psql:/path/sql_file:1: ERROR:  permission denied for external protocol demoprot
    -- Verify non-privileged user "demoprot_nopriv" can create new writable ext table 
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_new (like exttabtest)
        LOCATION('demoprot://exttabtest_new.txt') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
CREATE EXTERNAL TABLE
    -- Verify non-privileged user "demoprot_nopriv" can export data via new created WET exttabtest_w_new
    SELECT * FROM clean_exttabtest_files;
 stdout 
--------
(0 rows)

    INSERT INTO exttabtest_w_new (SELECT * FROM exttabtest);
INSERT 0 100
RESET ROLE;
RESET
-- Test 104: Trusted protocol - Revoke Insert
-- Revoke INSERT permission ON trusted protocol from non-privileged user
    -- connect as superuser 
    -- create trusted protocol demoprot
    DROP PROTOCOL IF EXISTS demoprot;
DROP PROTOCOL
    CREATE TRUSTED PROTOCOL demoprot (
        readfunc = read_from_file_stable,
        writefunc = write_to_file_stable
    );
CREATE PROTOCOL
    -- As superuser, GRANT SELECT permission on heap table "exttabtest"
    -- to non-privileged user "demoprot_nopriv" so that this user
    -- can try to create external table using format: (like exttabtest)
    GRANT SELECT ON exttabtest TO demoprot_nopriv;
GRANT
    -- As superuser, REVOKE INSERT privilege on protocol from non-privileged user demoprot_nopriv
    REVOKE INSERT ON PROTOCOL demoprot FROM demoprot_nopriv;
REVOKE
    -- login as non-privileged user "demoprot_nopriv"
    SET ROLE demoprot_nopriv;
SET
    select user;
  current_user   
-----------------
 demoprot_nopriv
(1 row)

    -- Verify after INSERT permission has been revoked
    -- non-privileged user "demoprot_nopriv" cannot create new writable ext table 
    -- using the trusted protocol demoprot
    CREATE WRITABLE EXTERNAL TABLE exttabtest_w_new2 (like exttabtest)
        LOCATION('demoprot://exttabtest_new.txt') 
    FORMAT 'text'
    DISTRIBUTED BY (id);
psql:/path/sql_file:1: ERROR:  permission denied for external protocol demoprot
RESET ROLE;
RESET
