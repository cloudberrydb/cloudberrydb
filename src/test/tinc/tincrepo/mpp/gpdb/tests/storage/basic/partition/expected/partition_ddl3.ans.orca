-- start_matchsubs
-- m/%USER%/
-- s/%USER%/username/
-- s/command //
-- s/line 1: //
-- m/type: \\d+/
-- s/type: \\d+/type: XXX/
-- m/mpp6724_1_prt_r\d+_pkey/
-- s/(mpp6724_1_prt_r)\d+(_pkey)/$1xxxxxx$2/
-- end_matchsubs
set client_min_messages = WARNING;
SET
DROP SCHEMA IF EXISTS partition_ddl3 CASCADE;
DROP SCHEMA
CREATE SCHEMA partition_ddl3;
CREATE SCHEMA
set search_path to partition_ddl3;
SET
CREATE TABLE mpp3263 (
        unique1         int4,
        unique2         int4,
        two                     int4,
        four            int4,
        ten                     int4,
        twenty          int4,
        hundred         int4,
        thousand        int4,
        twothousand     int4,
        fivethous       int4,
        tenthous        int4,
        odd                     int4,
        even            int4,
        stringu1        name,
        stringu2        name,
        string4         name
) partition by range (unique1)
( partition aa start (0) end (1000) every (500), default partition default_part );
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
alter table mpp3263 add column AAA int;
ALTER TABLE
alter table mpp3263 add column BBB int;
ALTER TABLE
alter table mpp3263 drop column BBB;
ALTER TABLE
alter table mpp3263 drop partition;
ALTER TABLE
alter table mpp3263 add column CCC int;
ALTER TABLE
insert into mpp3263 (unique1) values (1111);
INSERT 0 1
drop table mpp3263;
DROP TABLE
CREATE TABLE mpp3541 (f1 time(2) with time zone, f2 char(4), f3 varchar(10))
partition by list (f2)
subpartition by range (f3)
subpartition template (
  subpartition male values ('Male','M'),
  subpartition female values ('Female','F')
)
( partition pst values ('PST'),
  partition est values ('EST')
);
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  invalid use of LIST boundary specification in partition "male" of type RANGE (at depth 2)
LINE 5:   subpartition male values ('Male','M'),
                            ^
CREATE TABLE mpp3541 (f1 time(2) with time zone, f2 char(4), f3 varchar(10))
partition by range (f2)
subpartition by list (f3)
subpartition template (
  subpartition male values ('Male','M'),
  subpartition female values ('Female','F')
)
( partition pst values ('PST'),
  partition est values ('EST')
);
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  invalid use of LIST boundary specification in partition "pst" of type RANGE
LINE 8: ( partition pst values ('PST'),
                        ^
CREATE TABLE mpp3541 (f1 time(2) with time zone, f2 char(4), f3 varchar(10))
partition by range (f2)
subpartition by range (f3)
subpartition template (
  subpartition male values ('Male','M'),
  subpartition female values ('Female','F')
)
( partition pst values ('PST'),
  partition est values ('EST')
);
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  invalid use of LIST boundary specification in partition "pst" of type RANGE
LINE 8: ( partition pst values ('PST'),
                        ^
-- start_ignore
-- end_ignore
CREATE TABLE mpp3542_000000000011111111112222222222333333333344444444445555555555556666666666777777777788888888889999999999 (f1 time(2) with time zone)
partition by range (f1)
(
  partition "Los Angeles" start (time with time zone '00:00 PST') end (time with time zone '23:00 PST') EVERY (INTERVAL '1 hour'),
  partition "New York" start (time with time zone '00:00 EST') end (time with time zone '23:00 EST') EVERY (INTERVAL '1 hour')
);
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
psql:/path/sql_file:1: ERROR:  starting value of partition "Los Angeles_1" overlaps previous range
LINE 4:   partition "Los Angeles" start (time with time zone '00:00 ...
                                  ^
-- Truncates the table name to mpp3542_0000000000111111111122222222223333333333444444444455555, but partition name is too long, so ERROR
alter table mpp3542_000000000011111111112222222222333333333344444444445555555555556666666666777777777788888888889999999999 rename partition "Los Angeles_1" to "123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890";
psql:/path/sql_file:1: ERROR:  relation "mpp3542_0000000000111111111122222222223333333333444444444455555" does not exist
-- Truncates the table name to mpp3542_0000000000111111111122222222223333333333444444444455555, and partition name is safe, so renamed
alter table mpp3542_000000000011111111112222222222333333333344444444445555555555556666666666777777777788888888889999999999 rename partition "Los Angeles_1" to "LA1";
psql:/path/sql_file:1: ERROR:  relation "mpp3542_0000000000111111111122222222223333333333444444444455555" does not exist
-- Use the actual table name
alter table mpp3542_0000000000111111111122222222223333333333444444444455555 rename partition "Los Angeles_2" to "LA2";
psql:/path/sql_file:1: ERROR:  relation "mpp3542_0000000000111111111122222222223333333333444444444455555" does not exist
-- MPP-3542
alter table  mpp3542_0000000000111111111122222222223333333333444444444455555 rename to m; 
psql:/path/sql_file:1: ERROR:  relation "mpp3542_0000000000111111111122222222223333333333444444444455555" does not exist
CREATE TABLE MULTI_PART2(a int, b int, c int, d int, e int, f int, g int, h int, i int, j int, k int, l int, m int, n int, o int, p int, q int, r int, s int, t int, u int, v int, w int, x int, y int, z int)
distributed by (a)
partition by range (a)
subpartition by range (b) subpartition template ( start (1) end (2) every (1)),
subpartition by range (c) subpartition template ( start (1) end (2) every (1)),
subpartition by range (d) subpartition template ( start (1) end (2) every (1)),
subpartition by range (e) subpartition template ( start (1) end (2) every (1)),
subpartition by range (f) subpartition template ( start (1) end (2) every (1)),
subpartition by range (g) subpartition template ( start (1) end (2) every (1)),
subpartition by range (h) subpartition template ( start (1) end (2) every (1)),
subpartition by range (i) subpartition template ( start (1) end (2) every (1)),
subpartition by range (j) subpartition template ( start (1) end (2) every (1)),
subpartition by range (k) subpartition template ( start (1) end (2) every (1)),
subpartition by range (l) subpartition template ( start (1) end (2) every (1)),
subpartition by range (m) subpartition template ( start (1) end (2) every (1)),
subpartition by range (n) subpartition template ( start (1) end (2) every (1)),
subpartition by range (o) subpartition template ( start (1) end (2) every (1)),
subpartition by range (p) subpartition template ( start (1) end (2) every (1)),
subpartition by range (q) subpartition template ( start (1) end (2) every (1)),
subpartition by range (r) subpartition template ( start (1) end (2) every (1)),
subpartition by range (s) subpartition template ( start (1) end (2) every (1)),
subpartition by range (t) subpartition template ( start (1) end (2) every (1)),
subpartition by range (u) subpartition template ( start (1) end (2) every (1)),
subpartition by range (v) subpartition template ( start (1) end (2) every (1)),
subpartition by range (w) subpartition template ( start (1) end (2) every (1)),
subpartition by range (x) subpartition template ( start (1) end (2) every (1)),
subpartition by range (y) subpartition template ( start (1) end (2) every (1)),
subpartition by range (z) subpartition template ( start (1) end (2) every (1))
( start (1) end (2) every (1));
CREATE TABLE
alter table multi_part2 rename to multi_part2_0000000;
psql:/path/sql_file:1: ERROR:  relation name "multi_part2_0000000_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6_prt_1" for child partition is too long
alter table multi_part2 rename to m_0000000;
psql:/path/sql_file:1: WARNING:  renamed 6 partitions, skipped 20 child partitions due to name truncation
ALTER TABLE
-- We want to check both m and m_00000, thus I didn't put where clause
-- Assumes that there are no other partitions
-- order 2
select tablename, partitionlevel, partitiontablename, partitionname, partitionrank, partitionboundary from pg_partitions where tablename like 'm_000%' order by tablename;
 tablename | partitionlevel |                       partitiontablename                        | partitionname | partitionrank |      partitionboundary      
-----------+----------------+-----------------------------------------------------------------+---------------+---------------+-----------------------------
 m_0000000 |              0 | m_0000000_1_prt_1                                               |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |              1 | m_0000000_1_prt_1_2_prt_1                                       |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |              2 | m_0000000_1_prt_1_2_prt_1_3_prt_1                               |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |              3 | m_0000000_1_prt_1_2_prt_1_3_prt_1_4_prt_1                       |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |              4 | m_0000000_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1               |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |              5 | m_0000000_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6_prt_1       |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |              6 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6_p_7_prt_1 |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |              7 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6_p_8_prt_1 |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |              8 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6_p_9_prt_1 |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |              9 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6__10_prt_1 |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |             10 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6__11_prt_1 |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |             11 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6__12_prt_1 |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |             12 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6__13_prt_1 |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |             13 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6__14_prt_1 |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |             14 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6__15_prt_1 |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |             15 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6__16_prt_1 |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |             16 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6__17_prt_1 |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |             17 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6__18_prt_1 |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |             18 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6__19_prt_1 |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |             19 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6__20_prt_1 |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |             20 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6__21_prt_1 |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |             21 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6__22_prt_1 |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |             22 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6__23_prt_1 |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |             23 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6__24_prt_1 |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |             24 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6__25_prt_1 |               |             1 | START (1) END (2) EVERY (1)
 m_0000000 |             25 | multi_part2_1_prt_1_2_prt_1_3_prt_1_4_prt_1_5_prt_1_6__26_prt_1 |               |             1 | START (1) END (2) EVERY (1)
(26 rows)

drop table m;
psql:/path/sql_file:1: ERROR:  table "m" does not exist
drop table m_0000000;
DROP TABLE
create table mpp3061 (i int) partition by range(i) (start(1) end(10) every(1));
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
insert into mpp3061 values(1);
INSERT 0 1
update mpp3061 set i = 2 where i = 1;
UPDATE 1
drop table mpp3061;
DROP TABLE
create table mpp3466 (i int) partition by range(i) (start(1) end(10) every(2), default partition f);
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
alter table mpp3466 split partition f at (3) into (partition f, partition new);
ERROR:  syntax error at or near "new"
LINE 1: ... split partition f at (3) into (partition f, partition new);
                                                                  ^
drop table mpp3466;
DROP TABLE
create table mpp3058 (a char(1), b date, d char(3))       
 distributed by (a)         
partition by range (b)                                                                                            
 (              
 partition aa start (date '2008-01-01') end (date '2009-01-01') 
 every (interval '10 days'));
CREATE TABLE
drop table mpp3058;
DROP TABLE
create table mpp3058 (a char(1), b date, d char(3))   
distributed by (a)     
partition by range (b)    
(        
     partition aa start ('2008-01-01') end ('2010-01-01')           
  );
CREATE TABLE
drop table mpp3058;
DROP TABLE
create table mpp3058 (a char(1), b date, d char(3))   
distributed by (a)     
partition by range (b)    
(        
     partition aa start ('2008-01-01') end ('2006-01-01')           
  );
ERROR:  START greater than END for partition "aa"
LINE 5:      partition aa start ('2008-01-01') end ('2006-01-01')   ...
                          ^
drop table mpp3058;
ERROR:  table "mpp3058" does not exist
create table mpp3058 (a char(1), b date, d char(3))   
distributed by (a)     
partition by range (b)    
(        
     partition aa start ('2008-01-01') end ('-2009-01-01')           
  );
ERROR:  time zone displacement out of range: "-2009-01-01"
drop table mpp3058;
ERROR:  table "mpp3058" does not exist
create table mpp3058 (a char(1), b date, d char(3))   
distributed by (a)     
partition by range (b)    
(        
     partition aa start ('-2008-01-01') end ('2009-01-01')           
  );
ERROR:  time zone displacement out of range: "-2008-01-01"
drop table mpp3058;
ERROR:  table "mpp3058" does not exist
create table mpp3058 (a char(1), b date, d char(3))   
distributed by (a)     
partition by range (b)    
(        
     partition aa start ('2008-01-01') end ('2010-01-01')           
  );
CREATE TABLE
drop table mpp3058;
DROP TABLE
create table mpp3058 (a char(1), b date, d char(3))   
distributed by (a)        
partition by range (b)      
 (                  
           partition aa start ('2008-01-01') end ('2008-04-01') every(interval '1 day')   
     );
CREATE TABLE
drop table mpp3058;
DROP TABLE
create table mpp3058 (a char(1), b date, d char(3))  
  distributed by (a)    
   partition by range (b)             
  (           
    partition aa start ('2008-01-01') end ('2009-01-01') every( '1 day')  
     );
ERROR:  invalid input syntax for integer: "1 day"
LINE 5: ...aa start ('2008-01-01') end ('2009-01-01') every( '1 day')  
                                                             ^
drop table mpp3058;
ERROR:  table "mpp3058" does not exist
create table mpp3058 (a char(1), b date, d char(3))  
  distributed by (a)    
   partition by range (b)             
  (           
    partition aa end ('2009-01-01') every( interval '1 day')  
     );
ERROR:  EVERY clause in partition "aa" requires START and END
LINE 5:     partition aa end ('2009-01-01') every( interval '1 day')...
                         ^
drop table mpp3058;
ERROR:  table "mpp3058" does not exist
create table mpp3058 (a char(1), b date, d char(3))  
  distributed by (a)    
   partition by range (b)             
  (           
    partition aa start ('2006-01-01') every( interval '1 day')  
     );
ERROR:  EVERY clause in partition "aa" requires START and END
LINE 5:     partition aa start ('2006-01-01') every( interval '1 day...
                         ^
drop table mpp3058;
ERROR:  table "mpp3058" does not exist
-- start_ignore
-- end_ignore
create table mpp3607 (aa int, bb int) partition by range (bb)
(partition foo start(2));
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
alter table mpp3607 add partition baz end (3); -- Expected Overlaps
psql:/path/sql_file:1: ERROR:  new partition overlaps existing partition
alter table mpp3607 add partition baz end (4); -- Expected Overlaps
psql:/path/sql_file:1: ERROR:  new partition overlaps existing partition
alter table mpp3607 add partition aa end (2); -- OK as of 4.2.0.0 (RIO)
ALTER TABLE
alter table mpp3607 add partition bb end (1); -- Expected Overlaps
psql:/path/sql_file:1: ERROR:  new partition overlaps existing partition
alter table mpp3607 add partition baz end (3); -- Expected Overlaps
psql:/path/sql_file:1: ERROR:  new partition overlaps existing partition
alter table mpp3607 add partition baz end (4); -- Expected Overlaps
psql:/path/sql_file:1: ERROR:  new partition overlaps existing partition
alter table mpp3607 add partition baz end (2); -- Expected Overlaps
psql:/path/sql_file:1: ERROR:  new partition overlaps existing partition
alter table mpp3607 add partition bb end (0); -- Expected Overlaps
psql:/path/sql_file:1: ERROR:  new partition overlaps existing partition
alter table mpp3607 drop partition aa;
ALTER TABLE
alter table mpp3607 add partition aa end (-4); -- partition rule aa < -4, foo >=2
ALTER TABLE
alter table mpp3607 add partition bb end (-3); -- Overlaps
psql:/path/sql_file:1: ERROR:  new partition overlaps existing partition
alter table mpp3607 drop partition aa;
ALTER TABLE
alter table mpp3607 add partition aa end (0); -- partition rule aa < 0, foo >=2
ALTER TABLE
alter table mpp3607 drop partition aa;
ALTER TABLE
alter table mpp3607 add partition aa start (4); -- Overlaps
psql:/path/sql_file:1: ERROR:  new partition overlaps existing partition
alter table mpp3607 add partition aa start (3) end (4); -- Overlaps
psql:/path/sql_file:1: ERROR:  new partition overlaps existing partition "foo"
alter table mpp3607 add partition aa start (0) end (1); -- partition rule aa bb>=0 and bb<1, foo bb>=2
ALTER TABLE
alter table mpp3607 add partition bb start (-1) end (0); -- partition rule bb bb>=-1 and bb<0
ALTER TABLE
alter table mpp3607 add partition cc start (-4); -- partition rule cc bb>=-4 and bb <-1
ALTER TABLE
alter table mpp3607 add partition dd start (-5) end (-4);
ALTER TABLE
alter table mpp3607 add partition ee start (-10);
ALTER TABLE
alter table mpp3607 add partition ff start (-9) end (-8); -- Overlaps
psql:/path/sql_file:1: ERROR:  new partition overlaps existing partition "ee"
drop table mpp3607;
DROP TABLE
CREATE TABLE mpp3632(a int, b int, c int, d int, e int, f int, g int, h int, i int, j int, k int, l int, m int, n int, o int, p int, q int, r int, s int, t int, u int, v int, w int, x int, y int, z int)
partition by range (a)
( partition aa start (1) end (10) every (1) );
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
alter table mpp3632 add partition a1 start (30);
ALTER TABLE
alter table mpp3632 add partition a2 start (25) end (30);
ALTER TABLE
alter table mpp3632 add partition a3 start (10) end (20);
ALTER TABLE
alter table mpp3632 add partition a4 start (20) end (21);
ALTER TABLE
alter table mpp3632 add partition a5 start (22) end (24);
ALTER TABLE
alter table mpp3632 add partition a6 start (21) end (22);
ALTER TABLE
drop table mpp3632;
DROP TABLE
-- start_ignore
-- end_ignore
create table mpp3671 (i int) partition by list(i) (partition a values(1, 2, 3, 4),
partition b values(5, 6, 7, 8), default partition default_part);
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
insert into mpp3671 select i from generate_series(1, 10) i;
INSERT 0 10
alter table mpp3671 split partition for(1) at (1,2) into (partition f1a, partition f1b);
ALTER TABLE
drop table mpp3671;
DROP TABLE
create table mpp3639 (i int) partition by range(i) (start(0) exclusive end(100) inclusive every(10));
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
insert into mpp3639 select i from generate_series(1, 100) i;
INSERT 0 100
insert into mpp3639 select i from generate_series(1, 100) i;
INSERT 0 100
insert into mpp3639 select i from generate_series(1, 100) i;
INSERT 0 100
select * from mpp3639 order by i;
  i  
-----
   1
   1
   1
   2
   2
   2
   3
   3
   3
   4
   4
   4
   5
   5
   5
   6
   6
   6
   7
   7
   7
   8
   8
   8
   9
   9
   9
  10
  10
  10
  11
  11
  11
  12
  12
  12
  13
  13
  13
  14
  14
  14
  15
  15
  15
  16
  16
  16
  17
  17
  17
  18
  18
  18
  19
  19
  19
  20
  20
  20
  21
  21
  21
  22
  22
  22
  23
  23
  23
  24
  24
  24
  25
  25
  25
  26
  26
  26
  27
  27
  27
  28
  28
  28
  29
  29
  29
  30
  30
  30
  31
  31
  31
  32
  32
  32
  33
  33
  33
  34
  34
  34
  35
  35
  35
  36
  36
  36
  37
  37
  37
  38
  38
  38
  39
  39
  39
  40
  40
  40
  41
  41
  41
  42
  42
  42
  43
  43
  43
  44
  44
  44
  45
  45
  45
  46
  46
  46
  47
  47
  47
  48
  48
  48
  49
  49
  49
  50
  50
  50
  51
  51
  51
  52
  52
  52
  53
  53
  53
  54
  54
  54
  55
  55
  55
  56
  56
  56
  57
  57
  57
  58
  58
  58
  59
  59
  59
  60
  60
  60
  61
  61
  61
  62
  62
  62
  63
  63
  63
  64
  64
  64
  65
  65
  65
  66
  66
  66
  67
  67
  67
  68
  68
  68
  69
  69
  69
  70
  70
  70
  71
  71
  71
  72
  72
  72
  73
  73
  73
  74
  74
  74
  75
  75
  75
  76
  76
  76
  77
  77
  77
  78
  78
  78
  79
  79
  79
  80
  80
  80
  81
  81
  81
  82
  82
  82
  83
  83
  83
  84
  84
  84
  85
  85
  85
  86
  86
  86
  87
  87
  87
  88
  88
  88
  89
  89
  89
  90
  90
  90
  91
  91
  91
  92
  92
  92
  93
  93
  93
  94
  94
  94
  95
  95
  95
  96
  96
  96
  97
  97
  97
  98
  98
  98
  99
  99
  99
 100
 100
 100
(300 rows)

drop table mpp3639;
DROP TABLE
-- start_ignore
-- end_ignore
create table mpp3588 (i int) partition by list(i) (partition a values(1, 2, 3, 4),
partition b values(5, 6, 7, 8));
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
insert into mpp3588 select i from generate_series(1, 8) i;
INSERT 0 8
alter table mpp3588 split partition for(1) at (1,2) into (partition fa, partition fb);
ALTER TABLE
alter table mpp3588 split partition for(1) at (1,2) into (partition f1a, partition f1b); -- This has partition rules that overlaps
psql:/path/sql_file:1: ERROR:  AT clause cannot contain all values in partition "fb"
alter table mpp3588 split partition for(1) at (1,2) into (partition f2a, partition f2b); -- 5,6 are not within the boundary of first partition
psql:/path/sql_file:1: ERROR:  AT clause cannot contain all values in partition "fb"
alter table mpp3588 split partition for(1) at (1,2) into (partition f3a, partition f3b); 
psql:/path/sql_file:1: ERROR:  AT clause cannot contain all values in partition "fb"
alter table mpp3588 split partition for(1) at (1,2) into (partition f4a, partition f4b);
psql:/path/sql_file:1: ERROR:  AT clause cannot contain all values in partition "fb"
alter table mpp3588 split partition for(1) at (1,2) into (partition f5a, partition f5b); -- Out of the original boundary specification
psql:/path/sql_file:1: ERROR:  AT clause cannot contain all values in partition "fb"
alter table mpp3588 split partition for(1) at (1,2) into (partition f6a, partition f6b); -- I can keep going and going and going....
psql:/path/sql_file:1: ERROR:  AT clause cannot contain all values in partition "fb"
alter table mpp3588 split partition for(1) at (1,2) into (partition f7a, partition f7b);
psql:/path/sql_file:1: ERROR:  AT clause cannot contain all values in partition "fb"
drop table mpp3588;
DROP TABLE
create table mpp3679 (a text, b text) partition by list (a) (partition foo values ('foo'), partition bar values ('bar'), default partition baz);
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
insert into mpp3679 values ('foo', 'blah');
INSERT 0 1
insert into mpp3679 values ('bar', 'blah');
INSERT 0 1
insert into mpp3679 values ('baz', 'blah');
INSERT 0 1
alter table mpp3679 split default partition at ('baz') into (partition bing, default partition);
ALTER TABLE
drop table mpp3679;
DROP TABLE
create table mpp3681 (id int, date date, amt decimal(10,2)) distributed by (id) partition by range(date) (start (date '2008-01-01') inclusive end ('2008-04-01') exclusive every (interval '1 month'));
CREATE TABLE
alter table mpp3681 add default partition def;
ALTER TABLE
alter table mpp3681 split default partition start('2008-04-01') inclusive end('2008-05-01') exclusive into (partition apr08, default partition);
ALTER TABLE
drop table mpp3681;
DROP TABLE
create table mpp3593 (i int) partition by range(i) (start(1) end(100) every(10));
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
insert into mpp3593 select i from generate_series(1, 99) i;
INSERT 0 99
alter table mpp3593 split partition for(1) at (5) into (partition aa, partition bb);
ALTER TABLE
alter table mpp3593 split partition for(15) at (20) into (partition a1, partition b1);
ALTER TABLE
alter table mpp3593 split partition for(25) at (30) into (partition a2, partition b2);
ALTER TABLE
alter table mpp3593 split partition for(35) at (40) into (partition a3, partition b3);
ALTER TABLE
alter table mpp3593 split partition for(55) at (60) into (partition a4, partition b4);
ALTER TABLE
alter table mpp3593 split partition for(45) at (50) into (partition a5, partition b5);
ALTER TABLE
drop table mpp3593;
DROP TABLE
CREATE TABLE mpp3742 (
c_id varchar(36),
ss_id varchar(36),
c_ts timestamp,
name varchar(36),
PRIMARY KEY (c_id,ss_id,c_ts)) partition by range (c_ts)
(
  start (date '2007-01-01')
  end (date '2008-01-01') every (interval '1 month'),
  default partition default_part
);
CREATE TABLE
alter table mpp3742 split default partition start ('2009-01-01') end ('2009-02-01') into (partition a3, default partition);
ALTER TABLE
drop table mpp3742;
DROP TABLE
-- start_ignore
-- end_ignore
create table mpp3597 (i int) partition by list(i) (partition a values(1, 2, 3, 4),
partition b values(5, 6, 7, 8), default partition default_part);
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
insert into mpp3597 select i from generate_series(1, 100) i;
INSERT 0 100
insert into mpp3597 values (NULL);
INSERT 0 1
alter table mpp3597 split default partition at (NULL);
ALTER TABLE
insert into mpp3597 values (NULL);
INSERT 0 1
select * from mpp3597_1_prt_default_part where i=NULL; -- No NULL values
 i 
---
(0 rows)

drop table mpp3597;
DROP TABLE
create table mpp3594 (i date) partition by range(i) (start('2008-01-01') end('2009-01-01') every(interval '1 month'), default partition default_part);
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
alter table mpp3594 split default partition start ('2009-01-01') end ('2009-02-01') into (partition aa, partition nodate);
ERROR:  default partition name missing from INTO clause
drop table mpp3594;
DROP TABLE
-- start_ignore
-- end_ignore
CREATE TABLE mpp3512 (id int, rank int, year int, gender char(1), count int)
DISTRIBUTED BY (id);
CREATE TABLE
create table mpp3512_part (like mpp3512) partition by range (year) ( start (2001) end (2006) every ('1'));
CREATE TABLE
create table mpp3512a (like mpp3512_part);
CREATE TABLE
\d mpp3512
      Table "partition_ddl3.mpp3512"
 Column |     Type     | Modifiers 
--------+--------------+-----------
 id     | integer      | 
 rank   | integer      | 
 year   | integer      | 
 gender | character(1) | 
 count  | integer      | 
Distributed by: (id)

\d mpp3512a
      Table "partition_ddl3.mpp3512a"
 Column |     Type     | Modifiers 
--------+--------------+-----------
 id     | integer      | 
 rank   | integer      | 
 year   | integer      | 
 gender | character(1) | 
 count  | integer      | 
Distributed by: (id)

select * from pg_partitions where tablename='mpp3512_part';
 schemaname |  tablename   | partitionschemaname |  partitiontablename  | partitionname | parentpartitiontablename | parentpartitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |         partitionboundary         | parenttablespace | partitiontablespace 
------------+--------------+---------------------+----------------------+---------------+--------------------------+---------------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+-----------------------------------+------------------+---------------------
 partition_ddl3     | mpp3512_part | partition_ddl3              | mpp3512_part_1_prt_1 |               |                          |                     | range         |              0 |             1 |                 1 |                     | 2001                | t                       | 2002              | f                     | 1                    | f                  | START (2001) END (2002) EVERY (1) | pg_default       | pg_default
 partition_ddl3     | mpp3512_part | partition_ddl3              | mpp3512_part_1_prt_2 |               |                          |                     | range         |              0 |             2 |                 2 |                     | 2002                | t                       | 2003              | f                     | 1                    | f                  | START (2002) END (2003) EVERY (1) | pg_default       | pg_default
 partition_ddl3     | mpp3512_part | partition_ddl3              | mpp3512_part_1_prt_3 |               |                          |                     | range         |              0 |             3 |                 3 |                     | 2003                | t                       | 2004              | f                     | 1                    | f                  | START (2003) END (2004) EVERY (1) | pg_default       | pg_default
 partition_ddl3     | mpp3512_part | partition_ddl3              | mpp3512_part_1_prt_4 |               |                          |                     | range         |              0 |             4 |                 4 |                     | 2004                | t                       | 2005              | f                     | 1                    | f                  | START (2004) END (2005) EVERY (1) | pg_default       | pg_default
 partition_ddl3     | mpp3512_part | partition_ddl3              | mpp3512_part_1_prt_5 |               |                          |                     | range         |              0 |             5 |                 5 |                     | 2005                | t                       | 2006              | f                     | 1                    | f                  | START (2005) END (2006) EVERY (1) | pg_default       | pg_default
(5 rows)

drop table mpp3512;
DROP TABLE
drop table mpp3512_part;
DROP TABLE
drop table mpp3512a;
DROP TABLE
CREATE TABLE mpp3988 ( ps_partkey integer,
ps_suppkey integer, ps_availqty integer,
ps_supplycost numeric, ps_comment character varying(199) )
PARTITION BY RANGE(ps_supplycost)
subpartition by range (ps_supplycost)
(default partition foo (default subpartition bar));
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
drop table mpp3988;
DROP TABLE
CREATE TABLE mpp3816 (
        unique1         int4,
        unique2         int4,
        two                     int4,
        four            int4,
        ten                     int4,
        twenty          int4,
        hundred         int4,
        thousand        int4,
        twothousand     int4,
        fivethous       int4,
        tenthous        int4,
        odd                     int4,
        even            int4,
        stringu1        name,
        stringu2        name,
        string4         name,
	startDate       date		
) partition by range (startDate)
( start ('2007-01-01') end ('2008-01-01') every (interval '1 month'), default partition default_part );
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
alter table mpp3816 add column AAA int;
ALTER TABLE
alter table mpp3816 add column BBB int;
ALTER TABLE
alter table mpp3816 drop column BBB;
ALTER TABLE
alter table mpp3816 drop column startDate;
ERROR:  cannot drop partitioning column "startdate"
drop table mpp3816;
DROP TABLE
CREATE TABLE mpp3762_cities (
        city     varchar(80) primary key,
        location point
);
CREATE TABLE
CREATE TABLE mpp3762_weather (
        city      varchar(80) references mpp3762_cities(city),
        temp_lo   int,
        temp_hi   int,
        prcp      real,
        date      date
);
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
WARNING:  Referential integrity (FOREIGN KEY) constraints are not supported in Greenplum Database, will not be enforced.
CREATE TABLE
CREATE TABLE mpp3762_cities_partition (
        city     varchar(80) primary key,
        location point
)  partition by list (city) ( partition a values ('Los Angeles'), partition b values ('San Mateo') );
CREATE TABLE
CREATE TABLE mpp3762_weather_partition (
        city      varchar(80) references mpp3762_cities_partition(city),
        temp_lo   int,
        temp_hi   int,
        prcp      real,
        date      date
) partition by range(date) ( start('2008-01-01') end ('2009-01-01') every (interval '1 month'));
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
WARNING:  Referential integrity (FOREIGN KEY) constraints are not supported in Greenplum Database, will not be enforced.
WARNING:  Referential integrity (FOREIGN KEY) constraints are not supported in Greenplum Database, will not be enforced.
WARNING:  Referential integrity (FOREIGN KEY) constraints are not supported in Greenplum Database, will not be enforced.
WARNING:  Referential integrity (FOREIGN KEY) constraints are not supported in Greenplum Database, will not be enforced.
WARNING:  Referential integrity (FOREIGN KEY) constraints are not supported in Greenplum Database, will not be enforced.
WARNING:  Referential integrity (FOREIGN KEY) constraints are not supported in Greenplum Database, will not be enforced.
WARNING:  Referential integrity (FOREIGN KEY) constraints are not supported in Greenplum Database, will not be enforced.
WARNING:  Referential integrity (FOREIGN KEY) constraints are not supported in Greenplum Database, will not be enforced.
WARNING:  Referential integrity (FOREIGN KEY) constraints are not supported in Greenplum Database, will not be enforced.
WARNING:  Referential integrity (FOREIGN KEY) constraints are not supported in Greenplum Database, will not be enforced.
WARNING:  Referential integrity (FOREIGN KEY) constraints are not supported in Greenplum Database, will not be enforced.
WARNING:  Referential integrity (FOREIGN KEY) constraints are not supported in Greenplum Database, will not be enforced.
WARNING:  Referential integrity (FOREIGN KEY) constraints are not supported in Greenplum Database, will not be enforced.
CREATE TABLE
drop table mpp3762_cities, mpp3762_weather cascade;
DROP TABLE
drop table mpp3762_cities_partition, mpp3762_weather_partition cascade;
DROP TABLE
create table mpp3754a ( i int, d date, primary key (d)) partition by range(d) ( start ('2008-01-01')  inclusive end ('2008-12-01')  exclusive every (interval '1 month'));
CREATE TABLE
create table mpp3754b ( i int, d date, constraint prim_tr primary key (d)) partition by range(d) ( start ('2008-01-01')  inclusive end ('2008-12-01')  exclusive every (interval '1 month'));
CREATE TABLE
drop table mpp3754a;
DROP TABLE
drop table mpp3754b;
DROP TABLE
create table mpp4172 (a char(1), b int)
distributed by (b)
partition by range(a)
(
partition aa start ('2006') end ('2009'), partition bb start ('2007') end ('2008')
);
ERROR:  value too long for type character(1)
CREATE TABLE mpp4582 (id int,
mpp4582 int, year date, gender char(1))
DISTRIBUTED BY (id, gender, year)
partition by list (gender)
subpartition by range (year)
subpartition template (
start (date '2001-01-01')
end (date '2006-01-01') every (interval '1 year')) (
partition boys values ('M'),
partition girls values ('F'),
default partition neuter
);
CREATE TABLE
ALTER table mpp4582 drop partition for ('-1');
ERROR:  value too long for type character(1)
ALTER table mpp4582 drop partition for ('--');
ERROR:  value too long for type character(1)
alter table mpp4582 drop partition for (';');
ERROR:  FOR expression matches DEFAULT partition "neuter" of relation "mpp4582"
HINT:  FOR expression may only specify a non-default partition in this context.
alter table mpp4582 drop partition for ();
ERROR:  syntax error at or near ")"
LINE 1: alter table mpp4582 drop partition for ();
                                                ^
alter table mpp4582 drop partition for (NULL);
ERROR:  FOR expression matches DEFAULT partition "neuter" of relation "mpp4582"
HINT:  FOR expression may only specify a non-default partition in this context.
alter table mpp4582 drop partition for ('NULL');
ERROR:  value too long for type character(1)
drop table mpp4582;
DROP TABLE
-- start_ignore
-- end_ignore
CREATE TABLE mpp3641a (
        unique1         int4,
        unique2         int4,
        two                     int4,
        four            int4,
        ten                     int4,
        twenty          int4,
        hundred         int4,
        thousand        int4,
        twothousand     int4,
        fivethous       int4,
        tenthous        int4,
        odd                     int4,
        even            int4,
        stringu1        name,
        stringu2        name,
        string4         name
) partition by range (unique1)
( partition aa start (0) end (1000) every (100), default partition default_part );
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
CREATE TABLE mpp3641b (
        unique1         int4,
        unique2         int4,
        two                     int4,
        four            int4,
        ten                     int4,
        twenty          int4,
        hundred         int4,
        thousand        int4,
        twothousand     int4,
        fivethous       int4,
        tenthous        int4,
        odd                     int4,
        even            int4,
        stringu1        name,
        stringu2        name,
        string4         name
) partition by range (unique1)
subpartition by range (unique2) subpartition template ( start (0) end (1000) every (100) )
( start (0) end (1000) every (100));
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
alter table mpp3641b add default partition default_part;
ALTER TABLE
CREATE INDEX mpp3641a_unique1 ON mpp3641a USING btree(unique1 int4_ops);
CREATE INDEX
CREATE INDEX mpp3641a_unique2 ON mpp3641a USING btree(unique2 int4_ops);
CREATE INDEX
CREATE INDEX mpp3641a_hundred ON mpp3641a USING btree(hundred int4_ops);
CREATE INDEX
CREATE INDEX mpp3641a_stringu1 ON mpp3641a USING btree(stringu1 name_ops);
CREATE INDEX
CREATE INDEX mpp3641b_unique1 ON mpp3641b USING btree(unique1 int4_ops);
CREATE INDEX
CREATE INDEX mpp3641b_unique2 ON mpp3641b USING btree(unique2 int4_ops);
CREATE INDEX
CREATE INDEX mpp3641b_hundred ON mpp3641b USING btree(hundred int4_ops);
CREATE INDEX
CREATE INDEX mpp3641b_stringu1 ON mpp3641b USING btree(stringu1 name_ops);
CREATE INDEX
\t
Showing only tuples.
\di mpp3641*
 partition_ddl3 | mpp3641a_hundred                              | index | %USER% | heap    | mpp3641a
 partition_ddl3 | mpp3641a_hundred_1_prt_aa_1                   | index | %USER% | heap    | mpp3641a_1_prt_aa_1
 partition_ddl3 | mpp3641a_hundred_1_prt_aa_10                  | index | %USER% | heap    | mpp3641a_1_prt_aa_10
 partition_ddl3 | mpp3641a_hundred_1_prt_aa_2                   | index | %USER% | heap    | mpp3641a_1_prt_aa_2
 partition_ddl3 | mpp3641a_hundred_1_prt_aa_3                   | index | %USER% | heap    | mpp3641a_1_prt_aa_3
 partition_ddl3 | mpp3641a_hundred_1_prt_aa_4                   | index | %USER% | heap    | mpp3641a_1_prt_aa_4
 partition_ddl3 | mpp3641a_hundred_1_prt_aa_5                   | index | %USER% | heap    | mpp3641a_1_prt_aa_5
 partition_ddl3 | mpp3641a_hundred_1_prt_aa_6                   | index | %USER% | heap    | mpp3641a_1_prt_aa_6
 partition_ddl3 | mpp3641a_hundred_1_prt_aa_7                   | index | %USER% | heap    | mpp3641a_1_prt_aa_7
 partition_ddl3 | mpp3641a_hundred_1_prt_aa_8                   | index | %USER% | heap    | mpp3641a_1_prt_aa_8
 partition_ddl3 | mpp3641a_hundred_1_prt_aa_9                   | index | %USER% | heap    | mpp3641a_1_prt_aa_9
 partition_ddl3 | mpp3641a_hundred_1_prt_default_part           | index | %USER% | heap    | mpp3641a_1_prt_default_part
 partition_ddl3 | mpp3641a_stringu1                             | index | %USER% | heap    | mpp3641a
 partition_ddl3 | mpp3641a_stringu1_1_prt_aa_1                  | index | %USER% | heap    | mpp3641a_1_prt_aa_1
 partition_ddl3 | mpp3641a_stringu1_1_prt_aa_10                 | index | %USER% | heap    | mpp3641a_1_prt_aa_10
 partition_ddl3 | mpp3641a_stringu1_1_prt_aa_2                  | index | %USER% | heap    | mpp3641a_1_prt_aa_2
 partition_ddl3 | mpp3641a_stringu1_1_prt_aa_3                  | index | %USER% | heap    | mpp3641a_1_prt_aa_3
 partition_ddl3 | mpp3641a_stringu1_1_prt_aa_4                  | index | %USER% | heap    | mpp3641a_1_prt_aa_4
 partition_ddl3 | mpp3641a_stringu1_1_prt_aa_5                  | index | %USER% | heap    | mpp3641a_1_prt_aa_5
 partition_ddl3 | mpp3641a_stringu1_1_prt_aa_6                  | index | %USER% | heap    | mpp3641a_1_prt_aa_6
 partition_ddl3 | mpp3641a_stringu1_1_prt_aa_7                  | index | %USER% | heap    | mpp3641a_1_prt_aa_7
 partition_ddl3 | mpp3641a_stringu1_1_prt_aa_8                  | index | %USER% | heap    | mpp3641a_1_prt_aa_8
 partition_ddl3 | mpp3641a_stringu1_1_prt_aa_9                  | index | %USER% | heap    | mpp3641a_1_prt_aa_9
 partition_ddl3 | mpp3641a_stringu1_1_prt_default_part          | index | %USER% | heap    | mpp3641a_1_prt_default_part
 partition_ddl3 | mpp3641a_unique1                              | index | %USER% | heap    | mpp3641a
 partition_ddl3 | mpp3641a_unique1_1_prt_aa_1                   | index | %USER% | heap    | mpp3641a_1_prt_aa_1
 partition_ddl3 | mpp3641a_unique1_1_prt_aa_10                  | index | %USER% | heap    | mpp3641a_1_prt_aa_10
 partition_ddl3 | mpp3641a_unique1_1_prt_aa_2                   | index | %USER% | heap    | mpp3641a_1_prt_aa_2
 partition_ddl3 | mpp3641a_unique1_1_prt_aa_3                   | index | %USER% | heap    | mpp3641a_1_prt_aa_3
 partition_ddl3 | mpp3641a_unique1_1_prt_aa_4                   | index | %USER% | heap    | mpp3641a_1_prt_aa_4
 partition_ddl3 | mpp3641a_unique1_1_prt_aa_5                   | index | %USER% | heap    | mpp3641a_1_prt_aa_5
 partition_ddl3 | mpp3641a_unique1_1_prt_aa_6                   | index | %USER% | heap    | mpp3641a_1_prt_aa_6
 partition_ddl3 | mpp3641a_unique1_1_prt_aa_7                   | index | %USER% | heap    | mpp3641a_1_prt_aa_7
 partition_ddl3 | mpp3641a_unique1_1_prt_aa_8                   | index | %USER% | heap    | mpp3641a_1_prt_aa_8
 partition_ddl3 | mpp3641a_unique1_1_prt_aa_9                   | index | %USER% | heap    | mpp3641a_1_prt_aa_9
 partition_ddl3 | mpp3641a_unique1_1_prt_default_part           | index | %USER% | heap    | mpp3641a_1_prt_default_part
 partition_ddl3 | mpp3641a_unique2                              | index | %USER% | heap    | mpp3641a
 partition_ddl3 | mpp3641a_unique2_1_prt_aa_1                   | index | %USER% | heap    | mpp3641a_1_prt_aa_1
 partition_ddl3 | mpp3641a_unique2_1_prt_aa_10                  | index | %USER% | heap    | mpp3641a_1_prt_aa_10
 partition_ddl3 | mpp3641a_unique2_1_prt_aa_2                   | index | %USER% | heap    | mpp3641a_1_prt_aa_2
 partition_ddl3 | mpp3641a_unique2_1_prt_aa_3                   | index | %USER% | heap    | mpp3641a_1_prt_aa_3
 partition_ddl3 | mpp3641a_unique2_1_prt_aa_4                   | index | %USER% | heap    | mpp3641a_1_prt_aa_4
 partition_ddl3 | mpp3641a_unique2_1_prt_aa_5                   | index | %USER% | heap    | mpp3641a_1_prt_aa_5
 partition_ddl3 | mpp3641a_unique2_1_prt_aa_6                   | index | %USER% | heap    | mpp3641a_1_prt_aa_6
 partition_ddl3 | mpp3641a_unique2_1_prt_aa_7                   | index | %USER% | heap    | mpp3641a_1_prt_aa_7
 partition_ddl3 | mpp3641a_unique2_1_prt_aa_8                   | index | %USER% | heap    | mpp3641a_1_prt_aa_8
 partition_ddl3 | mpp3641a_unique2_1_prt_aa_9                   | index | %USER% | heap    | mpp3641a_1_prt_aa_9
 partition_ddl3 | mpp3641a_unique2_1_prt_default_part           | index | %USER% | heap    | mpp3641a_1_prt_default_part
 partition_ddl3 | mpp3641b_hundred                              | index | %USER% | heap    | mpp3641b
 partition_ddl3 | mpp3641b_hundred_1_prt_1                      | index | %USER% | heap    | mpp3641b_1_prt_1
 partition_ddl3 | mpp3641b_hundred_1_prt_10                     | index | %USER% | heap    | mpp3641b_1_prt_10
 partition_ddl3 | mpp3641b_hundred_1_prt_10_2_prt_1             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_1
 partition_ddl3 | mpp3641b_hundred_1_prt_10_2_prt_10            | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_10
 partition_ddl3 | mpp3641b_hundred_1_prt_10_2_prt_2             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_2
 partition_ddl3 | mpp3641b_hundred_1_prt_10_2_prt_3             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_3
 partition_ddl3 | mpp3641b_hundred_1_prt_10_2_prt_4             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_4
 partition_ddl3 | mpp3641b_hundred_1_prt_10_2_prt_5             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_5
 partition_ddl3 | mpp3641b_hundred_1_prt_10_2_prt_6             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_6
 partition_ddl3 | mpp3641b_hundred_1_prt_10_2_prt_7             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_7
 partition_ddl3 | mpp3641b_hundred_1_prt_10_2_prt_8             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_8
 partition_ddl3 | mpp3641b_hundred_1_prt_10_2_prt_9             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_9
 partition_ddl3 | mpp3641b_hundred_1_prt_1_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_1
 partition_ddl3 | mpp3641b_hundred_1_prt_1_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_10
 partition_ddl3 | mpp3641b_hundred_1_prt_1_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_2
 partition_ddl3 | mpp3641b_hundred_1_prt_1_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_3
 partition_ddl3 | mpp3641b_hundred_1_prt_1_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_4
 partition_ddl3 | mpp3641b_hundred_1_prt_1_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_5
 partition_ddl3 | mpp3641b_hundred_1_prt_1_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_6
 partition_ddl3 | mpp3641b_hundred_1_prt_1_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_7
 partition_ddl3 | mpp3641b_hundred_1_prt_1_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_8
 partition_ddl3 | mpp3641b_hundred_1_prt_1_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_9
 partition_ddl3 | mpp3641b_hundred_1_prt_2                      | index | %USER% | heap    | mpp3641b_1_prt_2
 partition_ddl3 | mpp3641b_hundred_1_prt_2_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_1
 partition_ddl3 | mpp3641b_hundred_1_prt_2_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_10
 partition_ddl3 | mpp3641b_hundred_1_prt_2_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_2
 partition_ddl3 | mpp3641b_hundred_1_prt_2_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_3
 partition_ddl3 | mpp3641b_hundred_1_prt_2_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_4
 partition_ddl3 | mpp3641b_hundred_1_prt_2_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_5
 partition_ddl3 | mpp3641b_hundred_1_prt_2_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_6
 partition_ddl3 | mpp3641b_hundred_1_prt_2_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_7
 partition_ddl3 | mpp3641b_hundred_1_prt_2_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_8
 partition_ddl3 | mpp3641b_hundred_1_prt_2_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_9
 partition_ddl3 | mpp3641b_hundred_1_prt_3                      | index | %USER% | heap    | mpp3641b_1_prt_3
 partition_ddl3 | mpp3641b_hundred_1_prt_3_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_1
 partition_ddl3 | mpp3641b_hundred_1_prt_3_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_10
 partition_ddl3 | mpp3641b_hundred_1_prt_3_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_2
 partition_ddl3 | mpp3641b_hundred_1_prt_3_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_3
 partition_ddl3 | mpp3641b_hundred_1_prt_3_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_4
 partition_ddl3 | mpp3641b_hundred_1_prt_3_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_5
 partition_ddl3 | mpp3641b_hundred_1_prt_3_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_6
 partition_ddl3 | mpp3641b_hundred_1_prt_3_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_7
 partition_ddl3 | mpp3641b_hundred_1_prt_3_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_8
 partition_ddl3 | mpp3641b_hundred_1_prt_3_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_9
 partition_ddl3 | mpp3641b_hundred_1_prt_4                      | index | %USER% | heap    | mpp3641b_1_prt_4
 partition_ddl3 | mpp3641b_hundred_1_prt_4_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_1
 partition_ddl3 | mpp3641b_hundred_1_prt_4_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_10
 partition_ddl3 | mpp3641b_hundred_1_prt_4_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_2
 partition_ddl3 | mpp3641b_hundred_1_prt_4_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_3
 partition_ddl3 | mpp3641b_hundred_1_prt_4_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_4
 partition_ddl3 | mpp3641b_hundred_1_prt_4_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_5
 partition_ddl3 | mpp3641b_hundred_1_prt_4_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_6
 partition_ddl3 | mpp3641b_hundred_1_prt_4_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_7
 partition_ddl3 | mpp3641b_hundred_1_prt_4_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_8
 partition_ddl3 | mpp3641b_hundred_1_prt_4_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_9
 partition_ddl3 | mpp3641b_hundred_1_prt_5                      | index | %USER% | heap    | mpp3641b_1_prt_5
 partition_ddl3 | mpp3641b_hundred_1_prt_5_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_1
 partition_ddl3 | mpp3641b_hundred_1_prt_5_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_10
 partition_ddl3 | mpp3641b_hundred_1_prt_5_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_2
 partition_ddl3 | mpp3641b_hundred_1_prt_5_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_3
 partition_ddl3 | mpp3641b_hundred_1_prt_5_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_4
 partition_ddl3 | mpp3641b_hundred_1_prt_5_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_5
 partition_ddl3 | mpp3641b_hundred_1_prt_5_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_6
 partition_ddl3 | mpp3641b_hundred_1_prt_5_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_7
 partition_ddl3 | mpp3641b_hundred_1_prt_5_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_8
 partition_ddl3 | mpp3641b_hundred_1_prt_5_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_9
 partition_ddl3 | mpp3641b_hundred_1_prt_6                      | index | %USER% | heap    | mpp3641b_1_prt_6
 partition_ddl3 | mpp3641b_hundred_1_prt_6_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_1
 partition_ddl3 | mpp3641b_hundred_1_prt_6_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_10
 partition_ddl3 | mpp3641b_hundred_1_prt_6_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_2
 partition_ddl3 | mpp3641b_hundred_1_prt_6_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_3
 partition_ddl3 | mpp3641b_hundred_1_prt_6_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_4
 partition_ddl3 | mpp3641b_hundred_1_prt_6_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_5
 partition_ddl3 | mpp3641b_hundred_1_prt_6_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_6
 partition_ddl3 | mpp3641b_hundred_1_prt_6_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_7
 partition_ddl3 | mpp3641b_hundred_1_prt_6_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_8
 partition_ddl3 | mpp3641b_hundred_1_prt_6_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_9
 partition_ddl3 | mpp3641b_hundred_1_prt_7                      | index | %USER% | heap    | mpp3641b_1_prt_7
 partition_ddl3 | mpp3641b_hundred_1_prt_7_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_1
 partition_ddl3 | mpp3641b_hundred_1_prt_7_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_10
 partition_ddl3 | mpp3641b_hundred_1_prt_7_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_2
 partition_ddl3 | mpp3641b_hundred_1_prt_7_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_3
 partition_ddl3 | mpp3641b_hundred_1_prt_7_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_4
 partition_ddl3 | mpp3641b_hundred_1_prt_7_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_5
 partition_ddl3 | mpp3641b_hundred_1_prt_7_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_6
 partition_ddl3 | mpp3641b_hundred_1_prt_7_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_7
 partition_ddl3 | mpp3641b_hundred_1_prt_7_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_8
 partition_ddl3 | mpp3641b_hundred_1_prt_7_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_9
 partition_ddl3 | mpp3641b_hundred_1_prt_8                      | index | %USER% | heap    | mpp3641b_1_prt_8
 partition_ddl3 | mpp3641b_hundred_1_prt_8_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_1
 partition_ddl3 | mpp3641b_hundred_1_prt_8_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_10
 partition_ddl3 | mpp3641b_hundred_1_prt_8_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_2
 partition_ddl3 | mpp3641b_hundred_1_prt_8_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_3
 partition_ddl3 | mpp3641b_hundred_1_prt_8_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_4
 partition_ddl3 | mpp3641b_hundred_1_prt_8_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_5
 partition_ddl3 | mpp3641b_hundred_1_prt_8_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_6
 partition_ddl3 | mpp3641b_hundred_1_prt_8_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_7
 partition_ddl3 | mpp3641b_hundred_1_prt_8_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_8
 partition_ddl3 | mpp3641b_hundred_1_prt_8_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_9
 partition_ddl3 | mpp3641b_hundred_1_prt_9                      | index | %USER% | heap    | mpp3641b_1_prt_9
 partition_ddl3 | mpp3641b_hundred_1_prt_9_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_1
 partition_ddl3 | mpp3641b_hundred_1_prt_9_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_10
 partition_ddl3 | mpp3641b_hundred_1_prt_9_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_2
 partition_ddl3 | mpp3641b_hundred_1_prt_9_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_3
 partition_ddl3 | mpp3641b_hundred_1_prt_9_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_4
 partition_ddl3 | mpp3641b_hundred_1_prt_9_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_5
 partition_ddl3 | mpp3641b_hundred_1_prt_9_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_6
 partition_ddl3 | mpp3641b_hundred_1_prt_9_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_7
 partition_ddl3 | mpp3641b_hundred_1_prt_9_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_8
 partition_ddl3 | mpp3641b_hundred_1_prt_9_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_9
 partition_ddl3 | mpp3641b_hundred_1_prt_default_part           | index | %USER% | heap    | mpp3641b_1_prt_default_part
 partition_ddl3 | mpp3641b_hundred_1_prt_default_part_2_prt_1   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_1
 partition_ddl3 | mpp3641b_hundred_1_prt_default_part_2_prt_10  | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_10
 partition_ddl3 | mpp3641b_hundred_1_prt_default_part_2_prt_2   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_2
 partition_ddl3 | mpp3641b_hundred_1_prt_default_part_2_prt_3   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_3
 partition_ddl3 | mpp3641b_hundred_1_prt_default_part_2_prt_4   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_4
 partition_ddl3 | mpp3641b_hundred_1_prt_default_part_2_prt_5   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_5
 partition_ddl3 | mpp3641b_hundred_1_prt_default_part_2_prt_6   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_6
 partition_ddl3 | mpp3641b_hundred_1_prt_default_part_2_prt_7   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_7
 partition_ddl3 | mpp3641b_hundred_1_prt_default_part_2_prt_8   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_8
 partition_ddl3 | mpp3641b_hundred_1_prt_default_part_2_prt_9   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_9
 partition_ddl3 | mpp3641b_stringu1                             | index | %USER% | heap    | mpp3641b
 partition_ddl3 | mpp3641b_stringu1_1_prt_1                     | index | %USER% | heap    | mpp3641b_1_prt_1
 partition_ddl3 | mpp3641b_stringu1_1_prt_10                    | index | %USER% | heap    | mpp3641b_1_prt_10
 partition_ddl3 | mpp3641b_stringu1_1_prt_10_2_prt_1            | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_1
 partition_ddl3 | mpp3641b_stringu1_1_prt_10_2_prt_10           | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_10
 partition_ddl3 | mpp3641b_stringu1_1_prt_10_2_prt_2            | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_2
 partition_ddl3 | mpp3641b_stringu1_1_prt_10_2_prt_3            | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_3
 partition_ddl3 | mpp3641b_stringu1_1_prt_10_2_prt_4            | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_4
 partition_ddl3 | mpp3641b_stringu1_1_prt_10_2_prt_5            | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_5
 partition_ddl3 | mpp3641b_stringu1_1_prt_10_2_prt_6            | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_6
 partition_ddl3 | mpp3641b_stringu1_1_prt_10_2_prt_7            | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_7
 partition_ddl3 | mpp3641b_stringu1_1_prt_10_2_prt_8            | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_8
 partition_ddl3 | mpp3641b_stringu1_1_prt_10_2_prt_9            | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_9
 partition_ddl3 | mpp3641b_stringu1_1_prt_1_2_prt_1             | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_1
 partition_ddl3 | mpp3641b_stringu1_1_prt_1_2_prt_10            | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_10
 partition_ddl3 | mpp3641b_stringu1_1_prt_1_2_prt_2             | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_2
 partition_ddl3 | mpp3641b_stringu1_1_prt_1_2_prt_3             | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_3
 partition_ddl3 | mpp3641b_stringu1_1_prt_1_2_prt_4             | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_4
 partition_ddl3 | mpp3641b_stringu1_1_prt_1_2_prt_5             | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_5
 partition_ddl3 | mpp3641b_stringu1_1_prt_1_2_prt_6             | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_6
 partition_ddl3 | mpp3641b_stringu1_1_prt_1_2_prt_7             | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_7
 partition_ddl3 | mpp3641b_stringu1_1_prt_1_2_prt_8             | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_8
 partition_ddl3 | mpp3641b_stringu1_1_prt_1_2_prt_9             | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_9
 partition_ddl3 | mpp3641b_stringu1_1_prt_2                     | index | %USER% | heap    | mpp3641b_1_prt_2
 partition_ddl3 | mpp3641b_stringu1_1_prt_2_2_prt_1             | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_1
 partition_ddl3 | mpp3641b_stringu1_1_prt_2_2_prt_10            | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_10
 partition_ddl3 | mpp3641b_stringu1_1_prt_2_2_prt_2             | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_2
 partition_ddl3 | mpp3641b_stringu1_1_prt_2_2_prt_3             | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_3
 partition_ddl3 | mpp3641b_stringu1_1_prt_2_2_prt_4             | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_4
 partition_ddl3 | mpp3641b_stringu1_1_prt_2_2_prt_5             | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_5
 partition_ddl3 | mpp3641b_stringu1_1_prt_2_2_prt_6             | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_6
 partition_ddl3 | mpp3641b_stringu1_1_prt_2_2_prt_7             | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_7
 partition_ddl3 | mpp3641b_stringu1_1_prt_2_2_prt_8             | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_8
 partition_ddl3 | mpp3641b_stringu1_1_prt_2_2_prt_9             | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_9
 partition_ddl3 | mpp3641b_stringu1_1_prt_3                     | index | %USER% | heap    | mpp3641b_1_prt_3
 partition_ddl3 | mpp3641b_stringu1_1_prt_3_2_prt_1             | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_1
 partition_ddl3 | mpp3641b_stringu1_1_prt_3_2_prt_10            | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_10
 partition_ddl3 | mpp3641b_stringu1_1_prt_3_2_prt_2             | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_2
 partition_ddl3 | mpp3641b_stringu1_1_prt_3_2_prt_3             | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_3
 partition_ddl3 | mpp3641b_stringu1_1_prt_3_2_prt_4             | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_4
 partition_ddl3 | mpp3641b_stringu1_1_prt_3_2_prt_5             | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_5
 partition_ddl3 | mpp3641b_stringu1_1_prt_3_2_prt_6             | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_6
 partition_ddl3 | mpp3641b_stringu1_1_prt_3_2_prt_7             | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_7
 partition_ddl3 | mpp3641b_stringu1_1_prt_3_2_prt_8             | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_8
 partition_ddl3 | mpp3641b_stringu1_1_prt_3_2_prt_9             | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_9
 partition_ddl3 | mpp3641b_stringu1_1_prt_4                     | index | %USER% | heap    | mpp3641b_1_prt_4
 partition_ddl3 | mpp3641b_stringu1_1_prt_4_2_prt_1             | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_1
 partition_ddl3 | mpp3641b_stringu1_1_prt_4_2_prt_10            | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_10
 partition_ddl3 | mpp3641b_stringu1_1_prt_4_2_prt_2             | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_2
 partition_ddl3 | mpp3641b_stringu1_1_prt_4_2_prt_3             | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_3
 partition_ddl3 | mpp3641b_stringu1_1_prt_4_2_prt_4             | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_4
 partition_ddl3 | mpp3641b_stringu1_1_prt_4_2_prt_5             | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_5
 partition_ddl3 | mpp3641b_stringu1_1_prt_4_2_prt_6             | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_6
 partition_ddl3 | mpp3641b_stringu1_1_prt_4_2_prt_7             | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_7
 partition_ddl3 | mpp3641b_stringu1_1_prt_4_2_prt_8             | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_8
 partition_ddl3 | mpp3641b_stringu1_1_prt_4_2_prt_9             | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_9
 partition_ddl3 | mpp3641b_stringu1_1_prt_5                     | index | %USER% | heap    | mpp3641b_1_prt_5
 partition_ddl3 | mpp3641b_stringu1_1_prt_5_2_prt_1             | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_1
 partition_ddl3 | mpp3641b_stringu1_1_prt_5_2_prt_10            | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_10
 partition_ddl3 | mpp3641b_stringu1_1_prt_5_2_prt_2             | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_2
 partition_ddl3 | mpp3641b_stringu1_1_prt_5_2_prt_3             | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_3
 partition_ddl3 | mpp3641b_stringu1_1_prt_5_2_prt_4             | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_4
 partition_ddl3 | mpp3641b_stringu1_1_prt_5_2_prt_5             | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_5
 partition_ddl3 | mpp3641b_stringu1_1_prt_5_2_prt_6             | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_6
 partition_ddl3 | mpp3641b_stringu1_1_prt_5_2_prt_7             | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_7
 partition_ddl3 | mpp3641b_stringu1_1_prt_5_2_prt_8             | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_8
 partition_ddl3 | mpp3641b_stringu1_1_prt_5_2_prt_9             | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_9
 partition_ddl3 | mpp3641b_stringu1_1_prt_6                     | index | %USER% | heap    | mpp3641b_1_prt_6
 partition_ddl3 | mpp3641b_stringu1_1_prt_6_2_prt_1             | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_1
 partition_ddl3 | mpp3641b_stringu1_1_prt_6_2_prt_10            | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_10
 partition_ddl3 | mpp3641b_stringu1_1_prt_6_2_prt_2             | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_2
 partition_ddl3 | mpp3641b_stringu1_1_prt_6_2_prt_3             | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_3
 partition_ddl3 | mpp3641b_stringu1_1_prt_6_2_prt_4             | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_4
 partition_ddl3 | mpp3641b_stringu1_1_prt_6_2_prt_5             | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_5
 partition_ddl3 | mpp3641b_stringu1_1_prt_6_2_prt_6             | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_6
 partition_ddl3 | mpp3641b_stringu1_1_prt_6_2_prt_7             | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_7
 partition_ddl3 | mpp3641b_stringu1_1_prt_6_2_prt_8             | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_8
 partition_ddl3 | mpp3641b_stringu1_1_prt_6_2_prt_9             | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_9
 partition_ddl3 | mpp3641b_stringu1_1_prt_7                     | index | %USER% | heap    | mpp3641b_1_prt_7
 partition_ddl3 | mpp3641b_stringu1_1_prt_7_2_prt_1             | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_1
 partition_ddl3 | mpp3641b_stringu1_1_prt_7_2_prt_10            | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_10
 partition_ddl3 | mpp3641b_stringu1_1_prt_7_2_prt_2             | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_2
 partition_ddl3 | mpp3641b_stringu1_1_prt_7_2_prt_3             | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_3
 partition_ddl3 | mpp3641b_stringu1_1_prt_7_2_prt_4             | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_4
 partition_ddl3 | mpp3641b_stringu1_1_prt_7_2_prt_5             | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_5
 partition_ddl3 | mpp3641b_stringu1_1_prt_7_2_prt_6             | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_6
 partition_ddl3 | mpp3641b_stringu1_1_prt_7_2_prt_7             | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_7
 partition_ddl3 | mpp3641b_stringu1_1_prt_7_2_prt_8             | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_8
 partition_ddl3 | mpp3641b_stringu1_1_prt_7_2_prt_9             | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_9
 partition_ddl3 | mpp3641b_stringu1_1_prt_8                     | index | %USER% | heap    | mpp3641b_1_prt_8
 partition_ddl3 | mpp3641b_stringu1_1_prt_8_2_prt_1             | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_1
 partition_ddl3 | mpp3641b_stringu1_1_prt_8_2_prt_10            | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_10
 partition_ddl3 | mpp3641b_stringu1_1_prt_8_2_prt_2             | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_2
 partition_ddl3 | mpp3641b_stringu1_1_prt_8_2_prt_3             | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_3
 partition_ddl3 | mpp3641b_stringu1_1_prt_8_2_prt_4             | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_4
 partition_ddl3 | mpp3641b_stringu1_1_prt_8_2_prt_5             | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_5
 partition_ddl3 | mpp3641b_stringu1_1_prt_8_2_prt_6             | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_6
 partition_ddl3 | mpp3641b_stringu1_1_prt_8_2_prt_7             | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_7
 partition_ddl3 | mpp3641b_stringu1_1_prt_8_2_prt_8             | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_8
 partition_ddl3 | mpp3641b_stringu1_1_prt_8_2_prt_9             | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_9
 partition_ddl3 | mpp3641b_stringu1_1_prt_9                     | index | %USER% | heap    | mpp3641b_1_prt_9
 partition_ddl3 | mpp3641b_stringu1_1_prt_9_2_prt_1             | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_1
 partition_ddl3 | mpp3641b_stringu1_1_prt_9_2_prt_10            | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_10
 partition_ddl3 | mpp3641b_stringu1_1_prt_9_2_prt_2             | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_2
 partition_ddl3 | mpp3641b_stringu1_1_prt_9_2_prt_3             | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_3
 partition_ddl3 | mpp3641b_stringu1_1_prt_9_2_prt_4             | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_4
 partition_ddl3 | mpp3641b_stringu1_1_prt_9_2_prt_5             | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_5
 partition_ddl3 | mpp3641b_stringu1_1_prt_9_2_prt_6             | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_6
 partition_ddl3 | mpp3641b_stringu1_1_prt_9_2_prt_7             | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_7
 partition_ddl3 | mpp3641b_stringu1_1_prt_9_2_prt_8             | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_8
 partition_ddl3 | mpp3641b_stringu1_1_prt_9_2_prt_9             | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_9
 partition_ddl3 | mpp3641b_stringu1_1_prt_default_part          | index | %USER% | heap    | mpp3641b_1_prt_default_part
 partition_ddl3 | mpp3641b_stringu1_1_prt_default_part_2_prt_1  | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_1
 partition_ddl3 | mpp3641b_stringu1_1_prt_default_part_2_prt_10 | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_10
 partition_ddl3 | mpp3641b_stringu1_1_prt_default_part_2_prt_2  | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_2
 partition_ddl3 | mpp3641b_stringu1_1_prt_default_part_2_prt_3  | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_3
 partition_ddl3 | mpp3641b_stringu1_1_prt_default_part_2_prt_4  | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_4
 partition_ddl3 | mpp3641b_stringu1_1_prt_default_part_2_prt_5  | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_5
 partition_ddl3 | mpp3641b_stringu1_1_prt_default_part_2_prt_6  | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_6
 partition_ddl3 | mpp3641b_stringu1_1_prt_default_part_2_prt_7  | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_7
 partition_ddl3 | mpp3641b_stringu1_1_prt_default_part_2_prt_8  | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_8
 partition_ddl3 | mpp3641b_stringu1_1_prt_default_part_2_prt_9  | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_9
 partition_ddl3 | mpp3641b_unique1                              | index | %USER% | heap    | mpp3641b
 partition_ddl3 | mpp3641b_unique1_1_prt_1                      | index | %USER% | heap    | mpp3641b_1_prt_1
 partition_ddl3 | mpp3641b_unique1_1_prt_10                     | index | %USER% | heap    | mpp3641b_1_prt_10
 partition_ddl3 | mpp3641b_unique1_1_prt_10_2_prt_1             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_1
 partition_ddl3 | mpp3641b_unique1_1_prt_10_2_prt_10            | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_10
 partition_ddl3 | mpp3641b_unique1_1_prt_10_2_prt_2             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_2
 partition_ddl3 | mpp3641b_unique1_1_prt_10_2_prt_3             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_3
 partition_ddl3 | mpp3641b_unique1_1_prt_10_2_prt_4             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_4
 partition_ddl3 | mpp3641b_unique1_1_prt_10_2_prt_5             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_5
 partition_ddl3 | mpp3641b_unique1_1_prt_10_2_prt_6             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_6
 partition_ddl3 | mpp3641b_unique1_1_prt_10_2_prt_7             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_7
 partition_ddl3 | mpp3641b_unique1_1_prt_10_2_prt_8             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_8
 partition_ddl3 | mpp3641b_unique1_1_prt_10_2_prt_9             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_9
 partition_ddl3 | mpp3641b_unique1_1_prt_1_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_1
 partition_ddl3 | mpp3641b_unique1_1_prt_1_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_10
 partition_ddl3 | mpp3641b_unique1_1_prt_1_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_2
 partition_ddl3 | mpp3641b_unique1_1_prt_1_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_3
 partition_ddl3 | mpp3641b_unique1_1_prt_1_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_4
 partition_ddl3 | mpp3641b_unique1_1_prt_1_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_5
 partition_ddl3 | mpp3641b_unique1_1_prt_1_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_6
 partition_ddl3 | mpp3641b_unique1_1_prt_1_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_7
 partition_ddl3 | mpp3641b_unique1_1_prt_1_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_8
 partition_ddl3 | mpp3641b_unique1_1_prt_1_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_9
 partition_ddl3 | mpp3641b_unique1_1_prt_2                      | index | %USER% | heap    | mpp3641b_1_prt_2
 partition_ddl3 | mpp3641b_unique1_1_prt_2_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_1
 partition_ddl3 | mpp3641b_unique1_1_prt_2_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_10
 partition_ddl3 | mpp3641b_unique1_1_prt_2_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_2
 partition_ddl3 | mpp3641b_unique1_1_prt_2_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_3
 partition_ddl3 | mpp3641b_unique1_1_prt_2_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_4
 partition_ddl3 | mpp3641b_unique1_1_prt_2_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_5
 partition_ddl3 | mpp3641b_unique1_1_prt_2_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_6
 partition_ddl3 | mpp3641b_unique1_1_prt_2_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_7
 partition_ddl3 | mpp3641b_unique1_1_prt_2_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_8
 partition_ddl3 | mpp3641b_unique1_1_prt_2_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_9
 partition_ddl3 | mpp3641b_unique1_1_prt_3                      | index | %USER% | heap    | mpp3641b_1_prt_3
 partition_ddl3 | mpp3641b_unique1_1_prt_3_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_1
 partition_ddl3 | mpp3641b_unique1_1_prt_3_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_10
 partition_ddl3 | mpp3641b_unique1_1_prt_3_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_2
 partition_ddl3 | mpp3641b_unique1_1_prt_3_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_3
 partition_ddl3 | mpp3641b_unique1_1_prt_3_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_4
 partition_ddl3 | mpp3641b_unique1_1_prt_3_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_5
 partition_ddl3 | mpp3641b_unique1_1_prt_3_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_6
 partition_ddl3 | mpp3641b_unique1_1_prt_3_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_7
 partition_ddl3 | mpp3641b_unique1_1_prt_3_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_8
 partition_ddl3 | mpp3641b_unique1_1_prt_3_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_9
 partition_ddl3 | mpp3641b_unique1_1_prt_4                      | index | %USER% | heap    | mpp3641b_1_prt_4
 partition_ddl3 | mpp3641b_unique1_1_prt_4_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_1
 partition_ddl3 | mpp3641b_unique1_1_prt_4_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_10
 partition_ddl3 | mpp3641b_unique1_1_prt_4_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_2
 partition_ddl3 | mpp3641b_unique1_1_prt_4_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_3
 partition_ddl3 | mpp3641b_unique1_1_prt_4_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_4
 partition_ddl3 | mpp3641b_unique1_1_prt_4_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_5
 partition_ddl3 | mpp3641b_unique1_1_prt_4_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_6
 partition_ddl3 | mpp3641b_unique1_1_prt_4_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_7
 partition_ddl3 | mpp3641b_unique1_1_prt_4_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_8
 partition_ddl3 | mpp3641b_unique1_1_prt_4_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_9
 partition_ddl3 | mpp3641b_unique1_1_prt_5                      | index | %USER% | heap    | mpp3641b_1_prt_5
 partition_ddl3 | mpp3641b_unique1_1_prt_5_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_1
 partition_ddl3 | mpp3641b_unique1_1_prt_5_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_10
 partition_ddl3 | mpp3641b_unique1_1_prt_5_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_2
 partition_ddl3 | mpp3641b_unique1_1_prt_5_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_3
 partition_ddl3 | mpp3641b_unique1_1_prt_5_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_4
 partition_ddl3 | mpp3641b_unique1_1_prt_5_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_5
 partition_ddl3 | mpp3641b_unique1_1_prt_5_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_6
 partition_ddl3 | mpp3641b_unique1_1_prt_5_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_7
 partition_ddl3 | mpp3641b_unique1_1_prt_5_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_8
 partition_ddl3 | mpp3641b_unique1_1_prt_5_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_9
 partition_ddl3 | mpp3641b_unique1_1_prt_6                      | index | %USER% | heap    | mpp3641b_1_prt_6
 partition_ddl3 | mpp3641b_unique1_1_prt_6_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_1
 partition_ddl3 | mpp3641b_unique1_1_prt_6_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_10
 partition_ddl3 | mpp3641b_unique1_1_prt_6_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_2
 partition_ddl3 | mpp3641b_unique1_1_prt_6_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_3
 partition_ddl3 | mpp3641b_unique1_1_prt_6_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_4
 partition_ddl3 | mpp3641b_unique1_1_prt_6_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_5
 partition_ddl3 | mpp3641b_unique1_1_prt_6_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_6
 partition_ddl3 | mpp3641b_unique1_1_prt_6_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_7
 partition_ddl3 | mpp3641b_unique1_1_prt_6_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_8
 partition_ddl3 | mpp3641b_unique1_1_prt_6_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_9
 partition_ddl3 | mpp3641b_unique1_1_prt_7                      | index | %USER% | heap    | mpp3641b_1_prt_7
 partition_ddl3 | mpp3641b_unique1_1_prt_7_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_1
 partition_ddl3 | mpp3641b_unique1_1_prt_7_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_10
 partition_ddl3 | mpp3641b_unique1_1_prt_7_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_2
 partition_ddl3 | mpp3641b_unique1_1_prt_7_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_3
 partition_ddl3 | mpp3641b_unique1_1_prt_7_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_4
 partition_ddl3 | mpp3641b_unique1_1_prt_7_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_5
 partition_ddl3 | mpp3641b_unique1_1_prt_7_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_6
 partition_ddl3 | mpp3641b_unique1_1_prt_7_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_7
 partition_ddl3 | mpp3641b_unique1_1_prt_7_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_8
 partition_ddl3 | mpp3641b_unique1_1_prt_7_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_9
 partition_ddl3 | mpp3641b_unique1_1_prt_8                      | index | %USER% | heap    | mpp3641b_1_prt_8
 partition_ddl3 | mpp3641b_unique1_1_prt_8_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_1
 partition_ddl3 | mpp3641b_unique1_1_prt_8_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_10
 partition_ddl3 | mpp3641b_unique1_1_prt_8_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_2
 partition_ddl3 | mpp3641b_unique1_1_prt_8_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_3
 partition_ddl3 | mpp3641b_unique1_1_prt_8_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_4
 partition_ddl3 | mpp3641b_unique1_1_prt_8_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_5
 partition_ddl3 | mpp3641b_unique1_1_prt_8_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_6
 partition_ddl3 | mpp3641b_unique1_1_prt_8_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_7
 partition_ddl3 | mpp3641b_unique1_1_prt_8_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_8
 partition_ddl3 | mpp3641b_unique1_1_prt_8_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_9
 partition_ddl3 | mpp3641b_unique1_1_prt_9                      | index | %USER% | heap    | mpp3641b_1_prt_9
 partition_ddl3 | mpp3641b_unique1_1_prt_9_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_1
 partition_ddl3 | mpp3641b_unique1_1_prt_9_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_10
 partition_ddl3 | mpp3641b_unique1_1_prt_9_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_2
 partition_ddl3 | mpp3641b_unique1_1_prt_9_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_3
 partition_ddl3 | mpp3641b_unique1_1_prt_9_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_4
 partition_ddl3 | mpp3641b_unique1_1_prt_9_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_5
 partition_ddl3 | mpp3641b_unique1_1_prt_9_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_6
 partition_ddl3 | mpp3641b_unique1_1_prt_9_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_7
 partition_ddl3 | mpp3641b_unique1_1_prt_9_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_8
 partition_ddl3 | mpp3641b_unique1_1_prt_9_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_9
 partition_ddl3 | mpp3641b_unique1_1_prt_default_part           | index | %USER% | heap    | mpp3641b_1_prt_default_part
 partition_ddl3 | mpp3641b_unique1_1_prt_default_part_2_prt_1   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_1
 partition_ddl3 | mpp3641b_unique1_1_prt_default_part_2_prt_10  | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_10
 partition_ddl3 | mpp3641b_unique1_1_prt_default_part_2_prt_2   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_2
 partition_ddl3 | mpp3641b_unique1_1_prt_default_part_2_prt_3   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_3
 partition_ddl3 | mpp3641b_unique1_1_prt_default_part_2_prt_4   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_4
 partition_ddl3 | mpp3641b_unique1_1_prt_default_part_2_prt_5   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_5
 partition_ddl3 | mpp3641b_unique1_1_prt_default_part_2_prt_6   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_6
 partition_ddl3 | mpp3641b_unique1_1_prt_default_part_2_prt_7   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_7
 partition_ddl3 | mpp3641b_unique1_1_prt_default_part_2_prt_8   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_8
 partition_ddl3 | mpp3641b_unique1_1_prt_default_part_2_prt_9   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_9
 partition_ddl3 | mpp3641b_unique2                              | index | %USER% | heap    | mpp3641b
 partition_ddl3 | mpp3641b_unique2_1_prt_1                      | index | %USER% | heap    | mpp3641b_1_prt_1
 partition_ddl3 | mpp3641b_unique2_1_prt_10                     | index | %USER% | heap    | mpp3641b_1_prt_10
 partition_ddl3 | mpp3641b_unique2_1_prt_10_2_prt_1             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_1
 partition_ddl3 | mpp3641b_unique2_1_prt_10_2_prt_10            | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_10
 partition_ddl3 | mpp3641b_unique2_1_prt_10_2_prt_2             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_2
 partition_ddl3 | mpp3641b_unique2_1_prt_10_2_prt_3             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_3
 partition_ddl3 | mpp3641b_unique2_1_prt_10_2_prt_4             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_4
 partition_ddl3 | mpp3641b_unique2_1_prt_10_2_prt_5             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_5
 partition_ddl3 | mpp3641b_unique2_1_prt_10_2_prt_6             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_6
 partition_ddl3 | mpp3641b_unique2_1_prt_10_2_prt_7             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_7
 partition_ddl3 | mpp3641b_unique2_1_prt_10_2_prt_8             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_8
 partition_ddl3 | mpp3641b_unique2_1_prt_10_2_prt_9             | index | %USER% | heap    | mpp3641b_1_prt_10_2_prt_9
 partition_ddl3 | mpp3641b_unique2_1_prt_1_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_1
 partition_ddl3 | mpp3641b_unique2_1_prt_1_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_10
 partition_ddl3 | mpp3641b_unique2_1_prt_1_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_2
 partition_ddl3 | mpp3641b_unique2_1_prt_1_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_3
 partition_ddl3 | mpp3641b_unique2_1_prt_1_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_4
 partition_ddl3 | mpp3641b_unique2_1_prt_1_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_5
 partition_ddl3 | mpp3641b_unique2_1_prt_1_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_6
 partition_ddl3 | mpp3641b_unique2_1_prt_1_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_7
 partition_ddl3 | mpp3641b_unique2_1_prt_1_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_8
 partition_ddl3 | mpp3641b_unique2_1_prt_1_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_1_2_prt_9
 partition_ddl3 | mpp3641b_unique2_1_prt_2                      | index | %USER% | heap    | mpp3641b_1_prt_2
 partition_ddl3 | mpp3641b_unique2_1_prt_2_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_1
 partition_ddl3 | mpp3641b_unique2_1_prt_2_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_10
 partition_ddl3 | mpp3641b_unique2_1_prt_2_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_2
 partition_ddl3 | mpp3641b_unique2_1_prt_2_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_3
 partition_ddl3 | mpp3641b_unique2_1_prt_2_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_4
 partition_ddl3 | mpp3641b_unique2_1_prt_2_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_5
 partition_ddl3 | mpp3641b_unique2_1_prt_2_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_6
 partition_ddl3 | mpp3641b_unique2_1_prt_2_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_7
 partition_ddl3 | mpp3641b_unique2_1_prt_2_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_8
 partition_ddl3 | mpp3641b_unique2_1_prt_2_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_2_2_prt_9
 partition_ddl3 | mpp3641b_unique2_1_prt_3                      | index | %USER% | heap    | mpp3641b_1_prt_3
 partition_ddl3 | mpp3641b_unique2_1_prt_3_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_1
 partition_ddl3 | mpp3641b_unique2_1_prt_3_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_10
 partition_ddl3 | mpp3641b_unique2_1_prt_3_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_2
 partition_ddl3 | mpp3641b_unique2_1_prt_3_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_3
 partition_ddl3 | mpp3641b_unique2_1_prt_3_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_4
 partition_ddl3 | mpp3641b_unique2_1_prt_3_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_5
 partition_ddl3 | mpp3641b_unique2_1_prt_3_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_6
 partition_ddl3 | mpp3641b_unique2_1_prt_3_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_7
 partition_ddl3 | mpp3641b_unique2_1_prt_3_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_8
 partition_ddl3 | mpp3641b_unique2_1_prt_3_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_3_2_prt_9
 partition_ddl3 | mpp3641b_unique2_1_prt_4                      | index | %USER% | heap    | mpp3641b_1_prt_4
 partition_ddl3 | mpp3641b_unique2_1_prt_4_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_1
 partition_ddl3 | mpp3641b_unique2_1_prt_4_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_10
 partition_ddl3 | mpp3641b_unique2_1_prt_4_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_2
 partition_ddl3 | mpp3641b_unique2_1_prt_4_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_3
 partition_ddl3 | mpp3641b_unique2_1_prt_4_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_4
 partition_ddl3 | mpp3641b_unique2_1_prt_4_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_5
 partition_ddl3 | mpp3641b_unique2_1_prt_4_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_6
 partition_ddl3 | mpp3641b_unique2_1_prt_4_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_7
 partition_ddl3 | mpp3641b_unique2_1_prt_4_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_8
 partition_ddl3 | mpp3641b_unique2_1_prt_4_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_4_2_prt_9
 partition_ddl3 | mpp3641b_unique2_1_prt_5                      | index | %USER% | heap    | mpp3641b_1_prt_5
 partition_ddl3 | mpp3641b_unique2_1_prt_5_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_1
 partition_ddl3 | mpp3641b_unique2_1_prt_5_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_10
 partition_ddl3 | mpp3641b_unique2_1_prt_5_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_2
 partition_ddl3 | mpp3641b_unique2_1_prt_5_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_3
 partition_ddl3 | mpp3641b_unique2_1_prt_5_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_4
 partition_ddl3 | mpp3641b_unique2_1_prt_5_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_5
 partition_ddl3 | mpp3641b_unique2_1_prt_5_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_6
 partition_ddl3 | mpp3641b_unique2_1_prt_5_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_7
 partition_ddl3 | mpp3641b_unique2_1_prt_5_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_8
 partition_ddl3 | mpp3641b_unique2_1_prt_5_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_5_2_prt_9
 partition_ddl3 | mpp3641b_unique2_1_prt_6                      | index | %USER% | heap    | mpp3641b_1_prt_6
 partition_ddl3 | mpp3641b_unique2_1_prt_6_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_1
 partition_ddl3 | mpp3641b_unique2_1_prt_6_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_10
 partition_ddl3 | mpp3641b_unique2_1_prt_6_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_2
 partition_ddl3 | mpp3641b_unique2_1_prt_6_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_3
 partition_ddl3 | mpp3641b_unique2_1_prt_6_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_4
 partition_ddl3 | mpp3641b_unique2_1_prt_6_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_5
 partition_ddl3 | mpp3641b_unique2_1_prt_6_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_6
 partition_ddl3 | mpp3641b_unique2_1_prt_6_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_7
 partition_ddl3 | mpp3641b_unique2_1_prt_6_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_8
 partition_ddl3 | mpp3641b_unique2_1_prt_6_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_6_2_prt_9
 partition_ddl3 | mpp3641b_unique2_1_prt_7                      | index | %USER% | heap    | mpp3641b_1_prt_7
 partition_ddl3 | mpp3641b_unique2_1_prt_7_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_1
 partition_ddl3 | mpp3641b_unique2_1_prt_7_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_10
 partition_ddl3 | mpp3641b_unique2_1_prt_7_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_2
 partition_ddl3 | mpp3641b_unique2_1_prt_7_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_3
 partition_ddl3 | mpp3641b_unique2_1_prt_7_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_4
 partition_ddl3 | mpp3641b_unique2_1_prt_7_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_5
 partition_ddl3 | mpp3641b_unique2_1_prt_7_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_6
 partition_ddl3 | mpp3641b_unique2_1_prt_7_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_7
 partition_ddl3 | mpp3641b_unique2_1_prt_7_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_8
 partition_ddl3 | mpp3641b_unique2_1_prt_7_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_7_2_prt_9
 partition_ddl3 | mpp3641b_unique2_1_prt_8                      | index | %USER% | heap    | mpp3641b_1_prt_8
 partition_ddl3 | mpp3641b_unique2_1_prt_8_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_1
 partition_ddl3 | mpp3641b_unique2_1_prt_8_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_10
 partition_ddl3 | mpp3641b_unique2_1_prt_8_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_2
 partition_ddl3 | mpp3641b_unique2_1_prt_8_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_3
 partition_ddl3 | mpp3641b_unique2_1_prt_8_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_4
 partition_ddl3 | mpp3641b_unique2_1_prt_8_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_5
 partition_ddl3 | mpp3641b_unique2_1_prt_8_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_6
 partition_ddl3 | mpp3641b_unique2_1_prt_8_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_7
 partition_ddl3 | mpp3641b_unique2_1_prt_8_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_8
 partition_ddl3 | mpp3641b_unique2_1_prt_8_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_8_2_prt_9
 partition_ddl3 | mpp3641b_unique2_1_prt_9                      | index | %USER% | heap    | mpp3641b_1_prt_9
 partition_ddl3 | mpp3641b_unique2_1_prt_9_2_prt_1              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_1
 partition_ddl3 | mpp3641b_unique2_1_prt_9_2_prt_10             | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_10
 partition_ddl3 | mpp3641b_unique2_1_prt_9_2_prt_2              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_2
 partition_ddl3 | mpp3641b_unique2_1_prt_9_2_prt_3              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_3
 partition_ddl3 | mpp3641b_unique2_1_prt_9_2_prt_4              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_4
 partition_ddl3 | mpp3641b_unique2_1_prt_9_2_prt_5              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_5
 partition_ddl3 | mpp3641b_unique2_1_prt_9_2_prt_6              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_6
 partition_ddl3 | mpp3641b_unique2_1_prt_9_2_prt_7              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_7
 partition_ddl3 | mpp3641b_unique2_1_prt_9_2_prt_8              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_8
 partition_ddl3 | mpp3641b_unique2_1_prt_9_2_prt_9              | index | %USER% | heap    | mpp3641b_1_prt_9_2_prt_9
 partition_ddl3 | mpp3641b_unique2_1_prt_default_part           | index | %USER% | heap    | mpp3641b_1_prt_default_part
 partition_ddl3 | mpp3641b_unique2_1_prt_default_part_2_prt_1   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_1
 partition_ddl3 | mpp3641b_unique2_1_prt_default_part_2_prt_10  | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_10
 partition_ddl3 | mpp3641b_unique2_1_prt_default_part_2_prt_2   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_2
 partition_ddl3 | mpp3641b_unique2_1_prt_default_part_2_prt_3   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_3
 partition_ddl3 | mpp3641b_unique2_1_prt_default_part_2_prt_4   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_4
 partition_ddl3 | mpp3641b_unique2_1_prt_default_part_2_prt_5   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_5
 partition_ddl3 | mpp3641b_unique2_1_prt_default_part_2_prt_6   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_6
 partition_ddl3 | mpp3641b_unique2_1_prt_default_part_2_prt_7   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_7
 partition_ddl3 | mpp3641b_unique2_1_prt_default_part_2_prt_8   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_8
 partition_ddl3 | mpp3641b_unique2_1_prt_default_part_2_prt_9   | index | %USER% | heap    | mpp3641b_1_prt_default_part_2_prt_9

drop table mpp3641a;
DROP TABLE
drop table mpp3641b;
DROP TABLE
\di mpp3641*
No matching relations found.
\t
Tuples only is off.
create schema rgs;
CREATE SCHEMA
show search_path;
  search_path   
----------------
 partition_ddl3
(1 row)

create table rgs.mpp4604(
	id int,
	time timestamp
) partition by range( time ) (
	partition p1 start (date '2008-10-14') end (date '2008-10-15'),
	partition p2 end (date '2008-11-01')
);
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
ALTER TABLE rgs.mpp4604 SPLIT PARTITION p2 AT( '2008-10-20' ) INTO( PARTITION p2_tmp, PARTITION p3 );
ALTER TABLE
alter table rgs.mpp4604 drop partition p3;
ALTER TABLE
drop schema rgs cascade;
DROP SCHEMA
-- start_ignore
-- end_ignore
CREATE TABLE mpp3817 (
        unique1         int4,
        unique2         int4,
        two                     int4,
        four            int4,
        ten                     int4,
        twenty          int4,
        hundred         int4,
        thousand        int4,
        twothousand     int4,
        fivethous       int4,
        tenthous        int4,
        odd                     int4,
        even            int4,
        stringu1        name,
        stringu2        name,
        string4         name,
	startDate       date		
) partition by range (startDate)
( start ('2007-01-01') end ('2008-01-01') every (interval '1 month'), default partition default_part );
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
alter table mpp3817 drop column unique1; -- Set distribution key to randomly
ALTER TABLE
alter table mpp3817 drop column unique2;
ALTER TABLE
\d mpp3817
      Table "partition_ddl3.mpp3817"
   Column    |  Type   | Modifiers 
-------------+---------+-----------
 two         | integer | 
 four        | integer | 
 ten         | integer | 
 twenty      | integer | 
 hundred     | integer | 
 thousand    | integer | 
 twothousand | integer | 
 fivethous   | integer | 
 tenthous    | integer | 
 odd         | integer | 
 even        | integer | 
 stringu1    | name    | 
 stringu2    | name    | 
 string4     | name    | 
 startdate   | date    | 
Number of child tables: 13 (Use \d+ to list them.)
Distributed randomly

\d mpp3817_1_prt_10
  Table "partition_ddl3.mpp3817_1_prt_10"
   Column    |  Type   | Modifiers 
-------------+---------+-----------
 two         | integer | 
 four        | integer | 
 ten         | integer | 
 twenty      | integer | 
 hundred     | integer | 
 thousand    | integer | 
 twothousand | integer | 
 fivethous   | integer | 
 tenthous    | integer | 
 odd         | integer | 
 even        | integer | 
 stringu1    | name    | 
 stringu2    | name    | 
 string4     | name    | 
 startdate   | date    | 
Check constraints:
    "mpp3817_1_prt_10_check" CHECK (startdate >= '2007-09-01'::date AND startdate < '2007-10-01'::date)
Inherits: mpp3817
Distributed randomly

\d mpp3817_1_prt_default_part
Table "partition_ddl3.mpp3817_1_prt_default_part"
   Column    |  Type   | Modifiers 
-------------+---------+-----------
 two         | integer | 
 four        | integer | 
 ten         | integer | 
 twenty      | integer | 
 hundred     | integer | 
 thousand    | integer | 
 twothousand | integer | 
 fivethous   | integer | 
 tenthous    | integer | 
 odd         | integer | 
 even        | integer | 
 stringu1    | name    | 
 stringu2    | name    | 
 string4     | name    | 
 startdate   | date    | 
Inherits: mpp3817
Distributed randomly

drop table mpp3817;
DROP TABLE
CREATE TABLE NATION (
            N_NATIONKEY INTEGER,
            N_NAME CHAR(25),
            N_REGIONKEY INTEGER,
            N_COMMENT VARCHAR(152)
            )
partition by range (n_regionkey) 
(
partition p1 start('0') end('1') inclusive, partition p2 start('1') end('5') inclusive
);
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  starting value of partition "p2" overlaps previous range
LINE 9: ...on p1 start('0') end('1') inclusive, partition p2 start('1')...
                                                             ^
CREATE TABLE ORDERS (
                O_ORDERKEY INT8,
                O_CUSTKEY INTEGER,
                O_ORDERSTATUS CHAR(1),
                O_TOTALPRICE decimal,
                O_ORDERDATE date,
                O_ORDERPRIORITY CHAR(15),
                O_CLERK CHAR(15),
                O_SHIPPRIORITY integer,
                O_COMMENT VARCHAR(79)
                )
partition by range (o_custkey) 
subpartition by range (o_orderkey) 
(
partition p1 start('1') end('150001') every 9 (150000)
(subpartition sp1 start('1') end('1500000'),subpartition sp2 start('1351816') end('6000001'))
);
ERROR:  syntax error at or near "9"
LINE 15: partition p1 start('1') end('150001') every 9 (150000)
                                                     ^
CREATE TABLE LINEITEM (
                L_ORDERKEY INT8,
                L_PARTKEY INTEGER,
                L_SUPPKEY INTEGER,
                L_LINENUMBER integer,
                L_QUANTITY decimal,
                L_EXTENDEDPRICE decimal,
                L_DISCOUNT decimal,
                L_TAX decimal,
                L_RETURNFLAG CHAR(1),
                L_LINESTATUS CHAR(1),
                L_SHIPDATE date,
                L_COMMITDATE date,
                L_RECEIPTDATE date,
                L_SHIPINSTRUCT CHAR(25),
                L_SHIPMODE CHAR(10),
                L_COMMENT VARCHAR(44)
                )
partition by range (l_discount) 
subpartition by range (l_quantity) 
,subpartition by range (l_tax) subpartition template (start('0') end('1.08') every 6 (1))
,subpartition by range (l_receiptdate) subpartition template (subpartition sp1 start('1992-01-03') end('1999-01-01'), subpartition sp2 start('1993-01-03') end ('1997-01-01'))
(
partition p1 start('0') end('1.1') 
(subpartition sp1 start('1') end('51') every(10)
) , partition p2 start('1.1') end ('2.2') (subpartition sp1 start('1') end('51') every (5))
);
ERROR:  syntax error at or near "6"
LINE 21: ...) subpartition template (start('0') end('1.08') every 6 (1))
                                                                  ^
CREATE TABLE ORDERS (
                O_ORDERKEY INT8,
                O_CUSTKEY INTEGER,
                O_ORDERSTATUS CHAR(1),
                O_TOTALPRICE decimal,
                O_ORDERDATE date,
                O_ORDERPRIORITY CHAR(15),
                O_CLERK CHAR(15),
                O_SHIPPRIORITY integer,
                O_COMMENT VARCHAR(79)
                )
partition by range (o_custkey) 
subpartition by range (o_orderdate) subpartition template (start('1992-01-01') end('1998-08-03') every 3 (interval '12 months')
)
,subpartition by range (o_orderkey) subpartition template (start('1') end('6000001') every 3 (3000000)
)
(
partition p1 start('1') , partition p2 start('55170') end('114873'), partition p3 start('44717') end('56000'), partition p4 start('114873') end('150001')
);
ERROR:  syntax error at or near "3"
LINE 13: ...late (start('1992-01-01') end('1998-08-03') every 3 (interva...
                                                              ^
CREATE TABLE mpp3114 (f1 time(2) with time zone)
partition by range (f1)
(
  partition pst start (time with time zone '00:00 PST') end (time with time zone '23:00 PST') EVERY (INTERVAL '1 hour'),
  partition est start (time with time zone '00:00 EST') end (time with time zone '23:00 EST') EVERY (INTERVAL '1 hour')
);
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  starting value of partition "pst_1" overlaps previous range
LINE 4:   partition pst start (time with time zone '00:00 PST') end ...
                        ^
DROP TABLE mpp3114;
ERROR:  table "mpp3114" does not exist
CREATE TABLE sg_cal_detail_r1 (
     datacenter character varying(32),
     poolname character varying(128),
     machinename character varying(128),
     transactionid character varying(32),
     threadid integer,
     transactionorder integer,
     eventclass character(1),
     eventtime timestamp(2) without time zone,
     eventtype character varying(128),
     eventname character varying(128),
     status character varying(128),
     duration numeric(18,2),
     data character varying(4096)
)
WITH (appendonly=true, compresslevel=5, blocksize=2097152)
DISTRIBUTED BY (transactionid)
PARTITION BY RANGE(eventtime) 
SUBPARTITION BY LIST(datacenter)
SUBPARTITION TEMPLATE
(
SUBPARTITION SMF VALUES ('smf01','smf02'),
SUBPARTITION SJC VALUES ('sjc01','sjc02'),
SUBPARTITION DEN VALUES ('den01','den02'),
SUBPARTITION PHX VALUES ('phx01','phx02'),
DEFAULT SUBPARTITION xdc
)
SUBPARTITION BY LIST(eventtype)
SUBPARTITION TEMPLATE
(
SUBPARTITION ET1 VALUES ('EXEC'),
SUBPARTITION ET2 VALUES ('URL','EXECP','ufb'),
SUBPARTITION ET3 VALUES
('EXECT','V3Rules','SOJ','MEQ','RTM','TL','ActiveRules','RTMe','API',
'Info','BizProcess','APIRequest','_ui','Warning','Consume','XML','DSAPar
serTransform'),
SUBPARTITION ET4 VALUES('InflowHandler',
'TaskType',
'LOG',
'FETCH',
'TD',
'AxisInflowPipeline',
'AxisOutflowPipeline',
'API Security',
'SD_DSBE',
'SD_ExpressSale',
'V4Header',
'V4Footer',
'SOAP_Handler',
'MLR',
'EvictedStmtRemove',
'CT',
'DSATransform',
'APIClient',
'DSAQueryExec',
'processDSA',
'FilterEngine',
'Prefetch',
'AsyncCb',
'MC',
'SQL',
'SD_UInfo',
'TnSPayload',
'Serialization',
'CxtSetup',
'LazyInit',
'Deserialization',
'CleanUp',
'RESTDeserialize',
'RESTSerialize',
'SD_StoreNames',
'Serialize',
'Deserialize',
'SVC_INVOKE',
'SD_TitleAggr',
'eLVIS',
'SD_Promo',
'ServerCalLogId',
'SD_DSA',
'ClientCalLogId',
'NCF Async processor',
'V3Rules_OLAP',
'RTAM',
'SOAP_Handlers',
'SOAP_Ser',
'SOAP_Exec',
'RtmAB',
'RTPromotionOptimizer',
'crypt',
'Error',
'DBGetDataHlp',
'NoEncoding',
'Default',
'PromoAppCenter',
'BES_CONSUMER',
'TitleKeywordsModel',
'SOA_CLIENT',
'SD_UserContent',
'NCF',
'BEGenericPortlet',
'PortletExecution',
'SoaPortlet',
'ICEP',
'LOGIC',
'SYI_Eval_Detail',
'SD_Catalog',
'SignIn_Eval_Detail',
'Elvis Client',
'BES',
'TIMESTAMP',
'TLH',
'TLH-PRE-SYI',
'RFC',
'Offer_Eval_Detail',
'SFE_RunQuery',
'DBGetData',
'TKOItem2',
'Notification',
'XSHModel',
'APIDefinition',
'captcha',
'SD_HalfItem',
'Mail_Transport',
'MODPUT',
'60DAY_OLD_ITEM_FETCHED',
'List',
'RemotePortlet',
'MakeOffer_Eval_Detail',
'60_TO_90_DAY_OLD_ITEM_FETCHED',
'Logic',
'RtmGetContentName',
'BEPortletService',
'SYI_EUP_Rbo',
'SYI_Rbo',
'EOA',
'SEC',
'CCHP',
'TKOItem3',
'TnsFindingModelBucket',
'Mail_Send',
'SignIn_Rbo',
'SignIn=23_elvisEvl',
'TnsFindingModelXSH',
'RtmSvc',
'SWEET_TOOTH_LOCATOR_EXPIRED',
'COOKIE_INFO',
'Database',
'RYI_Eval_Detail',
'TnsFindingModelSNP',
'TitleRiskScoringModel_2_0',
'ClientIPin10',
'TnsFindingModelFraud',
'SignIn_BaseRbo2',
'Offer_EUP_Rbo',
'Offer_Rbo',
'FSA',
'Processing_elvis_events',
'NSS_API',
'MyebayBetaRedirect',
'MOTORS_PARTNER_RECIPIENT_HANDLER',
'ElvisEngine',
'PreSyi_Eval_Detail',
'RADAR',
'Latency',
'SD_TAggrCache',
'MEA',
'SD_TitleAggregatorShopping',
'KEM',
'SD_Batch',
'KG',
'ITEM_VISIBILITY',
'APPLOGIC',
'OOPexecute',
'ERRPAGE',
'FQ_RECIPIENT_HANDLER',
'RADAR_POST_Eval_Detail',
'Captcha',
'V3Rules_Detail',
'FilterEngDetail_AAQBuyerSentPre',
'Task',
'SYI_EUP_Report',
'WRITE_MOVE_FILE',
'KG_SYI',
'BatchRecord',
'SD_TitleDesc',
'B001_RTAM',
'SignIn_Report',
'SD_StoreUrl',
'CACHE_REFRESH',
'TKOItem',
'KG_EXTERNAL_CALL',
'WatchDelSkipped',
'SD_Completed',
'RequestCounts',
'FilterEngDetail_RTQEmail',
'FilterEngDetail_AAQBuyerSentPost',
'RYI_EUP_Rbo',
'RYI_Rbo',
'MF_RECIPIENT_HANDLER',
'SYI_Report',
'LCBT',
'HalfRyiSingle_Eval_Detail',
'FilterEngDetail_AAQBuyerSentEmail',
'ViewAdAbTests',
'MakeOffer_EUP_Rbo',
'MakeOffer_Rbo',
'ShipCalc Url',
'Offer_Report',
'TKOUser',
'RADAR_POST_EUP_Rbo',
'SiteStat_LeftNav',
'SiteStat_UserIsSeller',
'FilterEngDetail_RTQPost',
'INFO',
'Offer_EUP_Report',
'RADAR_POST_Rbo',
'SignIn_EUP_Rbo',
'Mail_XML',
'Processing_item_events',
'GEM',
'Mail',
'ELVIS',
'FilterEngDetail_SYIRYI',
'SD_TitleCach',
'Processing_itemend_events',
'HalfRyiSingle_EUP_Rbo',
'AlertNotify',
'AVSRedirectLog',
'BillerService',
'MENMSG',
'UserSegSvc',
'PRICE_CHANGE_ALERT_RECIPIENT_HANDLER',
'NSSOptP',
'PreSyi_Rbo',
'PreSyi_EUP_Rbo',
'NOTIFICATION.BES.BID_NEW',
'Mail_Connect',
'Mail_Close',
'GEMRECORD',
'McapCommunicatorTx',
'IMGPROC',
'KnownGood',
'FilterEngDetail_RTQPre',
'AUTH',
'BULKAPI',
'AAQBuyerSentPre_Eval_Detail',
'RYI_EUP_Report',
'HalfRyiSingle_Rbo',
'MakeOffer_Report',
'ItemClosureLOGIC',
'MakeOffer_EUP_Report',
'RADAR_POST_Report',
'BidBinStats',
'Iterator',
'RADAR_POST_EUP_Report',
'SessionStats',
'RYI_Report',
'SIBE',
'EOT',
'UsageProcessingTx',
'Processing_itemrevised_events',
'HalfSyiSingle_Eval_Detail',
'SignIn_EUP_Report',
'Referer',
'RTQEmail_Eval_Detail',
'AAQBuyerSentPost_Eval_Detail',
'AAQBuyerSentEmail_Eval_Detail',
'NCFEvent',
'CHKOUT',
'SocketWriter',
'RTQPost_Eval_Detail',
'HalfRyiSingle_Report',
'HalfRyiSingle_EUP_Report',
'DcpConnectRequest',
'SD_CatalogCache',
'PreSyi_Report',
'BotSignIn',
'Total Listing : BE_MAIN',
'Z',
'ItemPopularityScore',
'SD_TitleCacheOverflow',
'UserSegmentationCommand',
'FilterEngDetail_AAQSellerSentPre',
'PreSyi_EUP_Report',
'FilterEngDetail_AAQSellerSentPost',
'FilterEngDetail_BestOffer',
'RS',
'FilterEngDetail_AAQSellerSentEmail',
'HalfSyiSingle_EUP_Rbo',
'Service',
'Total Listing : BE_DE',
'BULK.API.HALF.PUT'),
DEFAULT SUBPARTITION etx
)
(
START ('2008-09-30')
END ('2008-10-01')
EVERY (INTERVAL '1 day')
);
CREATE TABLE
ALTER TABLE sg_cal_detail_r1 ADD PARTITION START ('2008-10-01') INCLUSIVE END ('2008-10-02') EXCLUSIVE
WITH (appendonly=true, compresslevel=5, blocksize=2097152);
ALTER TABLE
select count(*) from pg_partitions where tablename = 'sg_cal_detail_r1';
 count 
-------
    62
(1 row)

drop table sg_cal_detail_r1;
DROP TABLE
create table j (i int, a date) partition by range(i)
subpartition by list(a) subpartition template
(subpartition a values(1, 2, 3, 4),
subpartition b values(5, 6, 7, 8))
(
start (date '2001-01-01'),
start (date '2002-01-01'),
start (date '2003-01-01'),
start (date '2004-01-01'),
start (date '2005-01-01')
);
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  cannot coerce RANGE partition parameter ('2001-01-01'::date) to column type (integer)
set optimizer_analyze_root_partition=on;
SET
create table mpp3487 (i int) partition by range (i) (start(1) end(10) every(1));
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
insert into mpp3487 select i from generate_series(1, 9) i;
INSERT 0 9
vacuum analyze mpp3487;
VACUUM
select unnest(string_to_array(array_to_string(most_common_vals,','),',')) from pg_stats where tablename='mpp3487' order by 1;
 unnest 
--------
 1
 2
 3
 4
 5
 6
 7
 8
 9
(9 rows)

select tablename,most_common_vals from pg_stats where tablename like 'mpp3487_%' order by 1;
    tablename    | most_common_vals 
-----------------+------------------
 mpp3487_1_prt_1 | {1}
 mpp3487_1_prt_2 | {2}
 mpp3487_1_prt_3 | {3}
 mpp3487_1_prt_4 | {4}
 mpp3487_1_prt_5 | {5}
 mpp3487_1_prt_6 | {6}
 mpp3487_1_prt_7 | {7}
 mpp3487_1_prt_8 | {8}
 mpp3487_1_prt_9 | {9}
(9 rows)

select  schemaname, tablename, attname, null_frac, avg_width, n_distinct, most_common_freqs, histogram_bounds, correlation from pg_stats where tablename like 'mpp3487%' order by 2;
 schemaname |    tablename    | attname | null_frac | avg_width | n_distinct |                                 most_common_freqs                                  | histogram_bounds | correlation 
------------+-----------------+---------+-----------+-----------+------------+------------------------------------------------------------------------------------+------------------+-------------
 partition_ddl3     | mpp3487         | i       |         0 |         4 |         -1 | {0.111111,0.111111,0.111111,0.111111,0.111111,0.111111,0.111111,0.111111,0.111111} | {}               |            
 partition_ddl3     | mpp3487_1_prt_1 | i       |         0 |         4 |         -1 | {1}                                                                                | {}               |            
 partition_ddl3     | mpp3487_1_prt_2 | i       |         0 |         4 |         -1 | {1}                                                                                | {}               |            
 partition_ddl3     | mpp3487_1_prt_3 | i       |         0 |         4 |         -1 | {1}                                                                                | {}               |            
 partition_ddl3     | mpp3487_1_prt_4 | i       |         0 |         4 |         -1 | {1}                                                                                | {}               |            
 partition_ddl3     | mpp3487_1_prt_5 | i       |         0 |         4 |         -1 | {1}                                                                                | {}               |            
 partition_ddl3     | mpp3487_1_prt_6 | i       |         0 |         4 |         -1 | {1}                                                                                | {}               |            
 partition_ddl3     | mpp3487_1_prt_7 | i       |         0 |         4 |         -1 | {1}                                                                                | {}               |            
 partition_ddl3     | mpp3487_1_prt_8 | i       |         0 |         4 |         -1 | {1}                                                                                | {}               |            
 partition_ddl3     | mpp3487_1_prt_9 | i       |         0 |         4 |         -1 | {1}                                                                                | {}               |            
(10 rows)

drop table mpp3487;
DROP TABLE
-- Negative Test for Alter subpartition template
CREATE TABLE qa147sales (trans_id int, date date, amount 
decimal(9,2), region text)  
DISTRIBUTED BY (trans_id) 
PARTITION BY RANGE (date) 
SUBPARTITION BY LIST (region) 
SUBPARTITION TEMPLATE 
( SUBPARTITION usa VALUES ('usa'), 
  SUBPARTITION asia VALUES ('asia'), 
  SUBPARTITION europe VALUES ('europe') ) 
( START (date '2008-01-01') INCLUSIVE 
   END (date '2009-01-01') EXCLUSIVE 
   EVERY (INTERVAL '1 month') ); 
CREATE TABLE
-- Invalid TEMPLATE
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (NULL);
psql:/path/sql_file:1: ERROR:  syntax error at or near "NULL"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (NULL);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (-1);
psql:/path/sql_file:1: ERROR:  syntax error at or near "-"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (-1);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (10000);
psql:/path/sql_file:1: ERROR:  syntax error at or near "10000"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (10000);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE ('');
psql:/path/sql_file:1: ERROR:  syntax error at or near "''"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE ('');
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE ("");
psql:/path/sql_file:1: ERROR:  zero-length delimited identifier at or near """"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE ("");
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (*);
psql:/path/sql_file:1: ERROR:  syntax error at or near "*"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (*);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (1*);
psql:/path/sql_file:1: ERROR:  syntax error at or near "1"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (1*);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE ("1*");
psql:/path/sql_file:1: ERROR:  syntax error at or near ""1*""
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE ("1*");
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (ABC);
psql:/path/sql_file:1: ERROR:  syntax error at or near "ABC"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (ABC);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE ($);
psql:/path/sql_file:1: ERROR:  syntax error at or near "$"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE ($);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (%%);
psql:/path/sql_file:1: ERROR:  syntax error at or near "%%"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (%%);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (#);
psql:/path/sql_file:1: ERROR:  syntax error at or near "#"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (#);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (!);
psql:/path/sql_file:1: ERROR:  syntax error at or near "!"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (!);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (&);
psql:/path/sql_file:1: ERROR:  syntax error at or near "&"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (&);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (^);
psql:/path/sql_file:1: ERROR:  syntax error at or near "^"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (^);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (@);
psql:/path/sql_file:1: ERROR:  syntax error at or near "@"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (@);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (<);
psql:/path/sql_file:1: ERROR:  syntax error at or near "<"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (<);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (>);
psql:/path/sql_file:1: ERROR:  syntax error at or near ">"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (>);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (.);
psql:/path/sql_file:1: ERROR:  syntax error at or near "."
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (.);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (?);
psql:/path/sql_file:1: ERROR:  syntax error at or near "?"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (?);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (/);
psql:/path/sql_file:1: ERROR:  syntax error at or near "/"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (/);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (|);
psql:/path/sql_file:1: ERROR:  syntax error at or near "|"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (|);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (~);
psql:/path/sql_file:1: ERROR:  syntax error at or near "~"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (~);
                                                          ^
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (`);
psql:/path/sql_file:1: ERROR:  syntax error at or near "`"
LINE 1: ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE (`);
                                                          ^
select * from pg_partition_templates where tablename='qa147sales';
 schemaname | tablename  | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |          partitionboundary           
------------+------------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+--------------------------------------
 partition_ddl3     | qa147sales | usa           | list          |              1 |               |                 1 | 'usa'::text         |                     |                         |                   |                       |                      | f                  | SUBPARTITION usa VALUES('usa')
 partition_ddl3     | qa147sales | asia          | list          |              1 |               |                 2 | 'asia'::text        |                     |                         |                   |                       |                      | f                  | SUBPARTITION asia VALUES('asia')
 partition_ddl3     | qa147sales | europe        | list          |              1 |               |                 3 | 'europe'::text      |                     |                         |                   |                       |                      | f                  | SUBPARTITION europe VALUES('europe')
(3 rows)

drop table qa147sales;
DROP TABLE
select * from pg_partition_templates where tablename='qa147sales';;
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault | partitionboundary 
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+-------------------
(0 rows)

-- Now with Schema
-- Negative Test for alter subpartition template with Schema
create schema qa147;
CREATE SCHEMA
CREATE TABLE qa147.sales (trans_id int, date date, amount
decimal(9,2), region text)
DISTRIBUTED BY (trans_id)
PARTITION BY RANGE (date)
SUBPARTITION BY LIST (region)
SUBPARTITION TEMPLATE
( SUBPARTITION usa VALUES ('usa'),
  SUBPARTITION asia VALUES ('asia'),
  SUBPARTITION europe VALUES ('europe') )
( START (date '2008-01-01') INCLUSIVE
   END (date '2009-01-01') EXCLUSIVE
   EVERY (INTERVAL '1 month') );
CREATE TABLE
-- Invalid TEMPLATE
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (NULL);
psql:/path/sql_file:1: ERROR:  syntax error at or near "NULL"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (NULL);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (-1);
psql:/path/sql_file:1: ERROR:  syntax error at or near "-"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (-1);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (10000);
psql:/path/sql_file:1: ERROR:  syntax error at or near "10000"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (10000);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE ('');
psql:/path/sql_file:1: ERROR:  syntax error at or near "''"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE ('');
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE ("");
psql:/path/sql_file:1: ERROR:  zero-length delimited identifier at or near """"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE ("");
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (*);
psql:/path/sql_file:1: ERROR:  syntax error at or near "*"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (*);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (1*);
psql:/path/sql_file:1: ERROR:  syntax error at or near "1"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (1*);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE ("1*");
psql:/path/sql_file:1: ERROR:  syntax error at or near ""1*""
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE ("1*");
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (ABC);
psql:/path/sql_file:1: ERROR:  syntax error at or near "ABC"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (ABC);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE ($);
psql:/path/sql_file:1: ERROR:  syntax error at or near "$"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE ($);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (%%);
psql:/path/sql_file:1: ERROR:  syntax error at or near "%%"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (%%);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (#);
psql:/path/sql_file:1: ERROR:  syntax error at or near "#"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (#);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (!);
psql:/path/sql_file:1: ERROR:  syntax error at or near "!"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (!);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (&);
psql:/path/sql_file:1: ERROR:  syntax error at or near "&"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (&);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (^);
psql:/path/sql_file:1: ERROR:  syntax error at or near "^"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (^);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (@);
psql:/path/sql_file:1: ERROR:  syntax error at or near "@"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (@);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (<);
psql:/path/sql_file:1: ERROR:  syntax error at or near "<"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (<);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (>);
psql:/path/sql_file:1: ERROR:  syntax error at or near ">"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (>);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (.);
psql:/path/sql_file:1: ERROR:  syntax error at or near "."
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (.);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (?);
psql:/path/sql_file:1: ERROR:  syntax error at or near "?"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (?);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (/);
psql:/path/sql_file:1: ERROR:  syntax error at or near "/"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (/);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (|);
psql:/path/sql_file:1: ERROR:  syntax error at or near "|"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (|);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (~);
psql:/path/sql_file:1: ERROR:  syntax error at or near "~"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (~);
                                                           ^
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (`);
psql:/path/sql_file:1: ERROR:  syntax error at or near "`"
LINE 1: ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE (`);
                                                           ^
select * from pg_partition_templates where schemaname='qa147' and tablename='sales';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |          partitionboundary           
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+--------------------------------------
 qa147      | sales     | usa           | list          |              1 |               |                 1 | 'usa'::text         |                     |                         |                   |                       |                      | f                  | SUBPARTITION usa VALUES('usa')
 qa147      | sales     | asia          | list          |              1 |               |                 2 | 'asia'::text        |                     |                         |                   |                       |                      | f                  | SUBPARTITION asia VALUES('asia')
 qa147      | sales     | europe        | list          |              1 |               |                 3 | 'europe'::text      |                     |                         |                   |                       |                      | f                  | SUBPARTITION europe VALUES('europe')
(3 rows)

drop schema qa147 cascade;
DROP SCHEMA
select * from pg_partition_templates where schemaname='qa147' and tablename='sales';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault | partitionboundary 
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+-------------------
(0 rows)

-- start_ignore
-- end_ignore
-- Mix-Match for Alter subpartition template
CREATE TABLE qa147sales (trans_id int, date date, amount 
decimal(9,2), region text)  
DISTRIBUTED BY (trans_id) 
PARTITION BY RANGE (date) 
SUBPARTITION BY LIST (region) 
SUBPARTITION TEMPLATE 
( SUBPARTITION usa VALUES ('usa'), 
  SUBPARTITION asia VALUES ('asia'), 
  SUBPARTITION europe VALUES ('europe') ) 
( START (date '2008-01-01') INCLUSIVE 
   END (date '2009-01-01') EXCLUSIVE 
   EVERY (INTERVAL '1 month') ); 
CREATE TABLE
-- Clear TEMPLATE
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE ();
ALTER TABLE
select * from pg_partition_templates where tablename='qa147sales';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault | partitionboundary 
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+-------------------
(0 rows)

-- This will overwrite previous subpartition template
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE
( SUBPARTITION usa VALUES ('usa'), SUBPARTITION asia VALUES ('asia') );
ALTER TABLE
select * from pg_partition_templates where tablename='qa147sales';
 schemaname | tablename  | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |        partitionboundary         
------------+------------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+----------------------------------
 partition_ddl3     | qa147sales | usa           | list          |              1 |               |                 1 | 'usa'::text         |                     |                         |                   |                       |                      | f                  | SUBPARTITION usa VALUES('usa')
 partition_ddl3     | qa147sales | asia          | list          |              1 |               |                 2 | 'asia'::text        |                     |                         |                   |                       |                      | f                  | SUBPARTITION asia VALUES('asia')
(2 rows)

-- Invalid subpartition
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE
( SUBPARTITION usam1 start (date '2008-01-01') INCLUSIVE END (date '2008-02-01') EXCLUSIVE );
psql:/path/sql_file:1: ERROR:  invalid boundary specification for LIST partition
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE
( SUBPARTITION usam1 start (date '2008-01-01') INCLUSIVE END (date '2009-01-01') EXCLUSIVE EVERY (INTERVAL '1 month') );
psql:/path/sql_file:1: ERROR:  invalid boundary specification for LIST partition
select * from pg_partition_templates where tablename='qa147sales';
 schemaname | tablename  | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |        partitionboundary         
------------+------------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+----------------------------------
 partition_ddl3     | qa147sales | usa           | list          |              1 |               |                 1 | 'usa'::text         |                     |                         |                   |                       |                      | f                  | SUBPARTITION usa VALUES('usa')
 partition_ddl3     | qa147sales | asia          | list          |              1 |               |                 2 | 'asia'::text        |                     |                         |                   |                       |                      | f                  | SUBPARTITION asia VALUES('asia')
(2 rows)

-- Mix and Match RANGE/LIST . Expect to Error
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE
( 
SUBPARTITION usa1 VALUES('usa'),
SUBPARTITION usadate start (date '2008-01-01') INCLUSIVE END(date '2009-01-01') EXCLUSIVE);
psql:/path/sql_file:1: ERROR:  invalid boundary specification for LIST partition
select * from pg_partition_templates where tablename='qa147sales';
 schemaname | tablename  | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |        partitionboundary         
------------+------------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+----------------------------------
 partition_ddl3     | qa147sales | usa           | list          |              1 |               |                 1 | 'usa'::text         |                     |                         |                   |                       |                      | f                  | SUBPARTITION usa VALUES('usa')
 partition_ddl3     | qa147sales | asia          | list          |              1 |               |                 2 | 'asia'::text        |                     |                         |                   |                       |                      | f                  | SUBPARTITION asia VALUES('asia')
(2 rows)

-- Mix and Match RANGE/LIST . Expect to Error
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE
( 
SUBPARTITION usadate start (date '2008-01-01') INCLUSIVE END(date '2009-01-01') EXCLUSIVE,
SUBPARTITION usa1 VALUES('usa'));
psql:/path/sql_file:1: ERROR:  invalid boundary specification for LIST partition
select * from pg_partition_templates where tablename='qa147sales';
 schemaname | tablename  | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |        partitionboundary         
------------+------------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+----------------------------------
 partition_ddl3     | qa147sales | usa           | list          |              1 |               |                 1 | 'usa'::text         |                     |                         |                   |                       |                      | f                  | SUBPARTITION usa VALUES('usa')
 partition_ddl3     | qa147sales | asia          | list          |              1 |               |                 2 | 'asia'::text        |                     |                         |                   |                       |                      | f                  | SUBPARTITION asia VALUES('asia')
(2 rows)

drop table qa147sales;
DROP TABLE
CREATE TABLE qa147sales (trans_id int, date date, amount
decimal(9,2), region text)
DISTRIBUTED BY (trans_id)
PARTITION BY LIST (region)
SUBPARTITION BY RANGE (date)
SUBPARTITION TEMPLATE
( START (date '2008-01-01') INCLUSIVE
   END (date '2009-01-01') EXCLUSIVE
   EVERY (INTERVAL '1 month') )
(
  PARTITION usa VALUES ('usa'),
  PARTITION asia VALUES ('asia'),
  PARTITION europe VALUES ('europe') );
CREATE TABLE
-- Clear TEMPLATE
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE ();
ALTER TABLE
select * from pg_partition_templates where tablename='qa147sales';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault | partitionboundary 
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+-------------------
(0 rows)

-- This will overwrite previous subpartition template
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE
( SUBPARTITION usam1 start (date '2008-01-01') INCLUSIVE END (date '2008-02-01') EXCLUSIVE );
ALTER TABLE
select * from pg_partition_templates where tablename='qa147sales';
 schemaname | tablename  | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend  | partitionendinclusive | partitioneveryclause | partitionisdefault |                           partitionboundary                            
------------+------------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+--------------------+-----------------------+----------------------+--------------------+------------------------------------------------------------------------
 partition_ddl3     | qa147sales | usam1         | range         |              1 |             1 |                 1 |                     | '2008-01-01'::date  | t                       | '2008-02-01'::date | f                     |                      | f                  | SUBPARTITION usam1 START ('2008-01-01'::date) END ('2008-02-01'::date)
(1 row)

ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE
( SUBPARTITION usam1 start (date '2008-01-01') INCLUSIVE END (date '2009-01-01') EXCLUSIVE EVERY (INTERVAL '1 month') );
ALTER TABLE
select * from pg_partition_templates where tablename='qa147sales';
 schemaname | tablename  | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend  | partitionendinclusive | partitioneveryclause | partitionisdefault |                                          partitionboundary                                          
------------+------------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+--------------------+-----------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------
 partition_ddl3     | qa147sales | usam1_1       | range         |              1 |             1 |                 1 |                     | '2008-01-01'::date  | t                       | '2008-02-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_1 START ('2008-01-01'::date) END ('2008-02-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_2       | range         |              1 |             2 |                 2 |                     | '2008-02-01'::date  | t                       | '2008-03-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_2 START ('2008-02-01'::date) END ('2008-03-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_3       | range         |              1 |             3 |                 3 |                     | '2008-03-01'::date  | t                       | '2008-04-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_3 START ('2008-03-01'::date) END ('2008-04-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_4       | range         |              1 |             4 |                 4 |                     | '2008-04-01'::date  | t                       | '2008-05-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_4 START ('2008-04-01'::date) END ('2008-05-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_5       | range         |              1 |             5 |                 5 |                     | '2008-05-01'::date  | t                       | '2008-06-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_5 START ('2008-05-01'::date) END ('2008-06-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_6       | range         |              1 |             6 |                 6 |                     | '2008-06-01'::date  | t                       | '2008-07-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_6 START ('2008-06-01'::date) END ('2008-07-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_7       | range         |              1 |             7 |                 7 |                     | '2008-07-01'::date  | t                       | '2008-08-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_7 START ('2008-07-01'::date) END ('2008-08-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_8       | range         |              1 |             8 |                 8 |                     | '2008-08-01'::date  | t                       | '2008-09-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_8 START ('2008-08-01'::date) END ('2008-09-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_9       | range         |              1 |             9 |                 9 |                     | '2008-09-01'::date  | t                       | '2008-10-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_9 START ('2008-09-01'::date) END ('2008-10-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_10      | range         |              1 |            10 |                10 |                     | '2008-10-01'::date  | t                       | '2008-11-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_10 START ('2008-10-01'::date) END ('2008-11-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_11      | range         |              1 |            11 |                11 |                     | '2008-11-01'::date  | t                       | '2008-12-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_11 START ('2008-11-01'::date) END ('2008-12-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_12      | range         |              1 |            12 |                12 |                     | '2008-12-01'::date  | t                       | '2009-01-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_12 START ('2008-12-01'::date) END ('2009-01-01'::date) EVERY ('1 mon'::interval)
(12 rows)

-- Invalid subpartition template
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE
( SUBPARTITION usa VALUES ('usa'), SUBPARTITION asia VALUES ('asia') );
psql:/path/sql_file:1: ERROR:  invalid use of LIST boundary specification in partition "usa" of type RANGE (at depth 2)
select * from pg_partition_templates where tablename='qa147sales';
 schemaname | tablename  | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend  | partitionendinclusive | partitioneveryclause | partitionisdefault |                                          partitionboundary                                          
------------+------------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+--------------------+-----------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------
 partition_ddl3     | qa147sales | usam1_1       | range         |              1 |             1 |                 1 |                     | '2008-01-01'::date  | t                       | '2008-02-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_1 START ('2008-01-01'::date) END ('2008-02-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_2       | range         |              1 |             2 |                 2 |                     | '2008-02-01'::date  | t                       | '2008-03-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_2 START ('2008-02-01'::date) END ('2008-03-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_3       | range         |              1 |             3 |                 3 |                     | '2008-03-01'::date  | t                       | '2008-04-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_3 START ('2008-03-01'::date) END ('2008-04-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_4       | range         |              1 |             4 |                 4 |                     | '2008-04-01'::date  | t                       | '2008-05-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_4 START ('2008-04-01'::date) END ('2008-05-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_5       | range         |              1 |             5 |                 5 |                     | '2008-05-01'::date  | t                       | '2008-06-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_5 START ('2008-05-01'::date) END ('2008-06-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_6       | range         |              1 |             6 |                 6 |                     | '2008-06-01'::date  | t                       | '2008-07-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_6 START ('2008-06-01'::date) END ('2008-07-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_7       | range         |              1 |             7 |                 7 |                     | '2008-07-01'::date  | t                       | '2008-08-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_7 START ('2008-07-01'::date) END ('2008-08-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_8       | range         |              1 |             8 |                 8 |                     | '2008-08-01'::date  | t                       | '2008-09-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_8 START ('2008-08-01'::date) END ('2008-09-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_9       | range         |              1 |             9 |                 9 |                     | '2008-09-01'::date  | t                       | '2008-10-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_9 START ('2008-09-01'::date) END ('2008-10-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_10      | range         |              1 |            10 |                10 |                     | '2008-10-01'::date  | t                       | '2008-11-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_10 START ('2008-10-01'::date) END ('2008-11-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_11      | range         |              1 |            11 |                11 |                     | '2008-11-01'::date  | t                       | '2008-12-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_11 START ('2008-11-01'::date) END ('2008-12-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_12      | range         |              1 |            12 |                12 |                     | '2008-12-01'::date  | t                       | '2009-01-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_12 START ('2008-12-01'::date) END ('2009-01-01'::date) EVERY ('1 mon'::interval)
(12 rows)

-- Mix and Match RANGE/LIST . Expect to Error
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE
(
SUBPARTITION usa1 VALUES('usa'),
SUBPARTITION usadate start (date '2008-01-01') INCLUSIVE END(date '2009-01-01') EXCLUSIVE);
psql:/path/sql_file:1: ERROR:  invalid use of LIST boundary specification in partition "usa1" of type RANGE (at depth 2)
select * from pg_partition_templates where tablename='qa147sales';
 schemaname | tablename  | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend  | partitionendinclusive | partitioneveryclause | partitionisdefault |                                          partitionboundary                                          
------------+------------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+--------------------+-----------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------
 partition_ddl3     | qa147sales | usam1_1       | range         |              1 |             1 |                 1 |                     | '2008-01-01'::date  | t                       | '2008-02-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_1 START ('2008-01-01'::date) END ('2008-02-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_2       | range         |              1 |             2 |                 2 |                     | '2008-02-01'::date  | t                       | '2008-03-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_2 START ('2008-02-01'::date) END ('2008-03-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_3       | range         |              1 |             3 |                 3 |                     | '2008-03-01'::date  | t                       | '2008-04-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_3 START ('2008-03-01'::date) END ('2008-04-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_4       | range         |              1 |             4 |                 4 |                     | '2008-04-01'::date  | t                       | '2008-05-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_4 START ('2008-04-01'::date) END ('2008-05-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_5       | range         |              1 |             5 |                 5 |                     | '2008-05-01'::date  | t                       | '2008-06-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_5 START ('2008-05-01'::date) END ('2008-06-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_6       | range         |              1 |             6 |                 6 |                     | '2008-06-01'::date  | t                       | '2008-07-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_6 START ('2008-06-01'::date) END ('2008-07-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_7       | range         |              1 |             7 |                 7 |                     | '2008-07-01'::date  | t                       | '2008-08-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_7 START ('2008-07-01'::date) END ('2008-08-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_8       | range         |              1 |             8 |                 8 |                     | '2008-08-01'::date  | t                       | '2008-09-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_8 START ('2008-08-01'::date) END ('2008-09-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_9       | range         |              1 |             9 |                 9 |                     | '2008-09-01'::date  | t                       | '2008-10-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_9 START ('2008-09-01'::date) END ('2008-10-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_10      | range         |              1 |            10 |                10 |                     | '2008-10-01'::date  | t                       | '2008-11-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_10 START ('2008-10-01'::date) END ('2008-11-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_11      | range         |              1 |            11 |                11 |                     | '2008-11-01'::date  | t                       | '2008-12-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_11 START ('2008-11-01'::date) END ('2008-12-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_12      | range         |              1 |            12 |                12 |                     | '2008-12-01'::date  | t                       | '2009-01-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_12 START ('2008-12-01'::date) END ('2009-01-01'::date) EVERY ('1 mon'::interval)
(12 rows)

-- Mix and Match RANGE/LIST . Expect to Error
ALTER TABLE qa147sales SET SUBPARTITION TEMPLATE
( 
SUBPARTITION usadate start (date '2008-01-01') INCLUSIVE END(date '2009-01-01') EXCLUSIVE,
SUBPARTITION usa1 VALUES('usa'));
psql:/path/sql_file:1: ERROR:  invalid use of LIST boundary specification in partition "usa1" of type RANGE (at depth 2)
select * from pg_partition_templates where tablename='qa147sales';
 schemaname | tablename  | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend  | partitionendinclusive | partitioneveryclause | partitionisdefault |                                          partitionboundary                                          
------------+------------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+--------------------+-----------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------
 partition_ddl3     | qa147sales | usam1_1       | range         |              1 |             1 |                 1 |                     | '2008-01-01'::date  | t                       | '2008-02-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_1 START ('2008-01-01'::date) END ('2008-02-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_2       | range         |              1 |             2 |                 2 |                     | '2008-02-01'::date  | t                       | '2008-03-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_2 START ('2008-02-01'::date) END ('2008-03-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_3       | range         |              1 |             3 |                 3 |                     | '2008-03-01'::date  | t                       | '2008-04-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_3 START ('2008-03-01'::date) END ('2008-04-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_4       | range         |              1 |             4 |                 4 |                     | '2008-04-01'::date  | t                       | '2008-05-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_4 START ('2008-04-01'::date) END ('2008-05-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_5       | range         |              1 |             5 |                 5 |                     | '2008-05-01'::date  | t                       | '2008-06-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_5 START ('2008-05-01'::date) END ('2008-06-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_6       | range         |              1 |             6 |                 6 |                     | '2008-06-01'::date  | t                       | '2008-07-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_6 START ('2008-06-01'::date) END ('2008-07-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_7       | range         |              1 |             7 |                 7 |                     | '2008-07-01'::date  | t                       | '2008-08-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_7 START ('2008-07-01'::date) END ('2008-08-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_8       | range         |              1 |             8 |                 8 |                     | '2008-08-01'::date  | t                       | '2008-09-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_8 START ('2008-08-01'::date) END ('2008-09-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_9       | range         |              1 |             9 |                 9 |                     | '2008-09-01'::date  | t                       | '2008-10-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_9 START ('2008-09-01'::date) END ('2008-10-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_10      | range         |              1 |            10 |                10 |                     | '2008-10-01'::date  | t                       | '2008-11-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_10 START ('2008-10-01'::date) END ('2008-11-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_11      | range         |              1 |            11 |                11 |                     | '2008-11-01'::date  | t                       | '2008-12-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_11 START ('2008-11-01'::date) END ('2008-12-01'::date) EVERY ('1 mon'::interval)
 partition_ddl3     | qa147sales | usam1_12      | range         |              1 |            12 |                12 |                     | '2008-12-01'::date  | t                       | '2009-01-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_12 START ('2008-12-01'::date) END ('2009-01-01'::date) EVERY ('1 mon'::interval)
(12 rows)

drop table qa147sales;
DROP TABLE
select * from pg_partition_templates where tablename='qa147sales';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault | partitionboundary 
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+-------------------
(0 rows)

-- Now with Schema
-- Mix-Match for Alter subpartition template in a schema
create schema qa147;
CREATE SCHEMA
CREATE TABLE qa147.sales (trans_id int, date date, amount
decimal(9,2), region text)
DISTRIBUTED BY (trans_id)
PARTITION BY RANGE (date)
SUBPARTITION BY LIST (region)
SUBPARTITION TEMPLATE
( SUBPARTITION usa VALUES ('usa'),
  SUBPARTITION asia VALUES ('asia'),
  SUBPARTITION europe VALUES ('europe') )
( START (date '2008-01-01') INCLUSIVE
   END (date '2009-01-01') EXCLUSIVE
   EVERY (INTERVAL '1 month') );
CREATE TABLE
-- Clear TEMPLATE
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE ();
ALTER TABLE
select * from pg_partition_templates where schemaname='qa147' and tablename='sales';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault | partitionboundary 
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+-------------------
(0 rows)

-- This will overwrite previous subpartition template
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE
( SUBPARTITION usa VALUES ('usa'), SUBPARTITION asia VALUES ('asia') );
ALTER TABLE
select * from pg_partition_templates where schemaname='qa147' and tablename='sales';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |        partitionboundary         
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+----------------------------------
 qa147      | sales     | usa           | list          |              1 |               |                 1 | 'usa'::text         |                     |                         |                   |                       |                      | f                  | SUBPARTITION usa VALUES('usa')
 qa147      | sales     | asia          | list          |              1 |               |                 2 | 'asia'::text        |                     |                         |                   |                       |                      | f                  | SUBPARTITION asia VALUES('asia')
(2 rows)

-- Invalid subpartition
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE
( SUBPARTITION usam1 start (date '2008-01-01') INCLUSIVE END (date '2008-02-01') EXCLUSIVE );
psql:/path/sql_file:1: ERROR:  invalid boundary specification for LIST partition
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE
( SUBPARTITION usam1 start (date '2008-01-01') INCLUSIVE END (date '2009-01-01') EXCLUSIVE EVERY (INTERVAL '1 month') );
psql:/path/sql_file:1: ERROR:  invalid boundary specification for LIST partition
select * from pg_partition_templates where schemaname='qa147' and tablename='sales';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |        partitionboundary         
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+----------------------------------
 qa147      | sales     | usa           | list          |              1 |               |                 1 | 'usa'::text         |                     |                         |                   |                       |                      | f                  | SUBPARTITION usa VALUES('usa')
 qa147      | sales     | asia          | list          |              1 |               |                 2 | 'asia'::text        |                     |                         |                   |                       |                      | f                  | SUBPARTITION asia VALUES('asia')
(2 rows)

-- Mix and Match RANGE/LIST . Expect to Error
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE
(
SUBPARTITION usa1 VALUES('usa'),
SUBPARTITION usadate start (date '2008-01-01') INCLUSIVE END(date '2009-01-01') EXCLUSIVE);
psql:/path/sql_file:1: ERROR:  invalid boundary specification for LIST partition
select * from pg_partition_templates where schemaname='qa147' and tablename='sales';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |        partitionboundary         
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+----------------------------------
 qa147      | sales     | usa           | list          |              1 |               |                 1 | 'usa'::text         |                     |                         |                   |                       |                      | f                  | SUBPARTITION usa VALUES('usa')
 qa147      | sales     | asia          | list          |              1 |               |                 2 | 'asia'::text        |                     |                         |                   |                       |                      | f                  | SUBPARTITION asia VALUES('asia')
(2 rows)

-- Mix and Match RANGE/LIST . Expect to Error
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE
(
SUBPARTITION usadate start (date '2008-01-01') INCLUSIVE END(date '2009-01-01') EXCLUSIVE,
SUBPARTITION usa1 VALUES('usa'));
psql:/path/sql_file:1: ERROR:  invalid boundary specification for LIST partition
select * from pg_partition_templates where schemaname='qa147' and tablename='sales';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |        partitionboundary         
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+----------------------------------
 qa147      | sales     | usa           | list          |              1 |               |                 1 | 'usa'::text         |                     |                         |                   |                       |                      | f                  | SUBPARTITION usa VALUES('usa')
 qa147      | sales     | asia          | list          |              1 |               |                 2 | 'asia'::text        |                     |                         |                   |                       |                      | f                  | SUBPARTITION asia VALUES('asia')
(2 rows)

DROP SCHEMA qa147 cascade;
DROP SCHEMA
select * from pg_partition_templates where schemaname='qa147' and tablename='sales';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault | partitionboundary 
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+-------------------
(0 rows)

CREATE SCHEMA qa147;
CREATE SCHEMA
CREATE TABLE qa147.sales (trans_id int, date date, amount
decimal(9,2), region text)
DISTRIBUTED BY (trans_id)
PARTITION BY LIST (region)
SUBPARTITION BY RANGE (date)
SUBPARTITION TEMPLATE
( START (date '2008-01-01') INCLUSIVE
   END (date '2009-01-01') EXCLUSIVE
   EVERY (INTERVAL '1 month') )
(
  PARTITION usa VALUES ('usa'),
  PARTITION asia VALUES ('asia'),
  PARTITION europe VALUES ('europe') );
CREATE TABLE
-- Clear TEMPLATE
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE ();
ALTER TABLE
select * from pg_partition_templates where schemaname='qa147' and tablename='sales';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault | partitionboundary 
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+-------------------
(0 rows)

-- This will overwrite previous subpartition template
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE
( SUBPARTITION usam1 start (date '2008-01-01') INCLUSIVE END (date '2008-02-01') EXCLUSIVE );
ALTER TABLE
select * from pg_partition_templates where schemaname='qa147' and tablename='sales';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend  | partitionendinclusive | partitioneveryclause | partitionisdefault |                           partitionboundary                            
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+--------------------+-----------------------+----------------------+--------------------+------------------------------------------------------------------------
 qa147      | sales     | usam1         | range         |              1 |             1 |                 1 |                     | '2008-01-01'::date  | t                       | '2008-02-01'::date | f                     |                      | f                  | SUBPARTITION usam1 START ('2008-01-01'::date) END ('2008-02-01'::date)
(1 row)

ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE
( SUBPARTITION usam1 start (date '2008-01-01') INCLUSIVE END (date '2009-01-01') EXCLUSIVE EVERY (INTERVAL '1 month') );
ALTER TABLE
select * from pg_partition_templates where schemaname='qa147' and tablename='sales';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend  | partitionendinclusive | partitioneveryclause | partitionisdefault |                                          partitionboundary                                          
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+--------------------+-----------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------
 qa147      | sales     | usam1_1       | range         |              1 |             1 |                 1 |                     | '2008-01-01'::date  | t                       | '2008-02-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_1 START ('2008-01-01'::date) END ('2008-02-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_2       | range         |              1 |             2 |                 2 |                     | '2008-02-01'::date  | t                       | '2008-03-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_2 START ('2008-02-01'::date) END ('2008-03-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_3       | range         |              1 |             3 |                 3 |                     | '2008-03-01'::date  | t                       | '2008-04-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_3 START ('2008-03-01'::date) END ('2008-04-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_4       | range         |              1 |             4 |                 4 |                     | '2008-04-01'::date  | t                       | '2008-05-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_4 START ('2008-04-01'::date) END ('2008-05-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_5       | range         |              1 |             5 |                 5 |                     | '2008-05-01'::date  | t                       | '2008-06-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_5 START ('2008-05-01'::date) END ('2008-06-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_6       | range         |              1 |             6 |                 6 |                     | '2008-06-01'::date  | t                       | '2008-07-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_6 START ('2008-06-01'::date) END ('2008-07-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_7       | range         |              1 |             7 |                 7 |                     | '2008-07-01'::date  | t                       | '2008-08-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_7 START ('2008-07-01'::date) END ('2008-08-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_8       | range         |              1 |             8 |                 8 |                     | '2008-08-01'::date  | t                       | '2008-09-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_8 START ('2008-08-01'::date) END ('2008-09-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_9       | range         |              1 |             9 |                 9 |                     | '2008-09-01'::date  | t                       | '2008-10-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_9 START ('2008-09-01'::date) END ('2008-10-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_10      | range         |              1 |            10 |                10 |                     | '2008-10-01'::date  | t                       | '2008-11-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_10 START ('2008-10-01'::date) END ('2008-11-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_11      | range         |              1 |            11 |                11 |                     | '2008-11-01'::date  | t                       | '2008-12-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_11 START ('2008-11-01'::date) END ('2008-12-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_12      | range         |              1 |            12 |                12 |                     | '2008-12-01'::date  | t                       | '2009-01-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_12 START ('2008-12-01'::date) END ('2009-01-01'::date) EVERY ('1 mon'::interval)
(12 rows)

-- Invalid subpartition template
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE
( SUBPARTITION usa VALUES ('usa'), SUBPARTITION asia VALUES ('asia') );
psql:/path/sql_file:1: ERROR:  invalid use of LIST boundary specification in partition "usa" of type RANGE (at depth 2)
select * from pg_partition_templates where schemaname='qa147' and tablename='sales';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend  | partitionendinclusive | partitioneveryclause | partitionisdefault |                                          partitionboundary                                          
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+--------------------+-----------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------
 qa147      | sales     | usam1_1       | range         |              1 |             1 |                 1 |                     | '2008-01-01'::date  | t                       | '2008-02-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_1 START ('2008-01-01'::date) END ('2008-02-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_2       | range         |              1 |             2 |                 2 |                     | '2008-02-01'::date  | t                       | '2008-03-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_2 START ('2008-02-01'::date) END ('2008-03-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_3       | range         |              1 |             3 |                 3 |                     | '2008-03-01'::date  | t                       | '2008-04-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_3 START ('2008-03-01'::date) END ('2008-04-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_4       | range         |              1 |             4 |                 4 |                     | '2008-04-01'::date  | t                       | '2008-05-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_4 START ('2008-04-01'::date) END ('2008-05-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_5       | range         |              1 |             5 |                 5 |                     | '2008-05-01'::date  | t                       | '2008-06-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_5 START ('2008-05-01'::date) END ('2008-06-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_6       | range         |              1 |             6 |                 6 |                     | '2008-06-01'::date  | t                       | '2008-07-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_6 START ('2008-06-01'::date) END ('2008-07-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_7       | range         |              1 |             7 |                 7 |                     | '2008-07-01'::date  | t                       | '2008-08-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_7 START ('2008-07-01'::date) END ('2008-08-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_8       | range         |              1 |             8 |                 8 |                     | '2008-08-01'::date  | t                       | '2008-09-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_8 START ('2008-08-01'::date) END ('2008-09-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_9       | range         |              1 |             9 |                 9 |                     | '2008-09-01'::date  | t                       | '2008-10-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_9 START ('2008-09-01'::date) END ('2008-10-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_10      | range         |              1 |            10 |                10 |                     | '2008-10-01'::date  | t                       | '2008-11-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_10 START ('2008-10-01'::date) END ('2008-11-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_11      | range         |              1 |            11 |                11 |                     | '2008-11-01'::date  | t                       | '2008-12-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_11 START ('2008-11-01'::date) END ('2008-12-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_12      | range         |              1 |            12 |                12 |                     | '2008-12-01'::date  | t                       | '2009-01-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_12 START ('2008-12-01'::date) END ('2009-01-01'::date) EVERY ('1 mon'::interval)
(12 rows)

-- Mix and Match RANGE/LIST . Expect to Error
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE
(
SUBPARTITION usa1 VALUES('usa'),
SUBPARTITION usadate start (date '2008-01-01') INCLUSIVE END(date '2009-01-01') EXCLUSIVE);
psql:/path/sql_file:1: ERROR:  invalid use of LIST boundary specification in partition "usa1" of type RANGE (at depth 2)
select * from pg_partition_templates where schemaname='qa147' and tablename='sales';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend  | partitionendinclusive | partitioneveryclause | partitionisdefault |                                          partitionboundary                                          
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+--------------------+-----------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------
 qa147      | sales     | usam1_1       | range         |              1 |             1 |                 1 |                     | '2008-01-01'::date  | t                       | '2008-02-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_1 START ('2008-01-01'::date) END ('2008-02-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_2       | range         |              1 |             2 |                 2 |                     | '2008-02-01'::date  | t                       | '2008-03-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_2 START ('2008-02-01'::date) END ('2008-03-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_3       | range         |              1 |             3 |                 3 |                     | '2008-03-01'::date  | t                       | '2008-04-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_3 START ('2008-03-01'::date) END ('2008-04-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_4       | range         |              1 |             4 |                 4 |                     | '2008-04-01'::date  | t                       | '2008-05-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_4 START ('2008-04-01'::date) END ('2008-05-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_5       | range         |              1 |             5 |                 5 |                     | '2008-05-01'::date  | t                       | '2008-06-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_5 START ('2008-05-01'::date) END ('2008-06-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_6       | range         |              1 |             6 |                 6 |                     | '2008-06-01'::date  | t                       | '2008-07-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_6 START ('2008-06-01'::date) END ('2008-07-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_7       | range         |              1 |             7 |                 7 |                     | '2008-07-01'::date  | t                       | '2008-08-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_7 START ('2008-07-01'::date) END ('2008-08-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_8       | range         |              1 |             8 |                 8 |                     | '2008-08-01'::date  | t                       | '2008-09-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_8 START ('2008-08-01'::date) END ('2008-09-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_9       | range         |              1 |             9 |                 9 |                     | '2008-09-01'::date  | t                       | '2008-10-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_9 START ('2008-09-01'::date) END ('2008-10-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_10      | range         |              1 |            10 |                10 |                     | '2008-10-01'::date  | t                       | '2008-11-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_10 START ('2008-10-01'::date) END ('2008-11-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_11      | range         |              1 |            11 |                11 |                     | '2008-11-01'::date  | t                       | '2008-12-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_11 START ('2008-11-01'::date) END ('2008-12-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_12      | range         |              1 |            12 |                12 |                     | '2008-12-01'::date  | t                       | '2009-01-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_12 START ('2008-12-01'::date) END ('2009-01-01'::date) EVERY ('1 mon'::interval)
(12 rows)

-- Mix and Match RANGE/LIST . Expect to Error
ALTER TABLE qa147.sales SET SUBPARTITION TEMPLATE
(
SUBPARTITION usadate start (date '2008-01-01') INCLUSIVE END(date '2009-01-01') EXCLUSIVE,
SUBPARTITION usa1 VALUES('usa'));
psql:/path/sql_file:1: ERROR:  invalid use of LIST boundary specification in partition "usa1" of type RANGE (at depth 2)
select * from pg_partition_templates where schemaname='qa147' and tablename='sales';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend  | partitionendinclusive | partitioneveryclause | partitionisdefault |                                          partitionboundary                                          
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+--------------------+-----------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------
 qa147      | sales     | usam1_1       | range         |              1 |             1 |                 1 |                     | '2008-01-01'::date  | t                       | '2008-02-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_1 START ('2008-01-01'::date) END ('2008-02-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_2       | range         |              1 |             2 |                 2 |                     | '2008-02-01'::date  | t                       | '2008-03-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_2 START ('2008-02-01'::date) END ('2008-03-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_3       | range         |              1 |             3 |                 3 |                     | '2008-03-01'::date  | t                       | '2008-04-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_3 START ('2008-03-01'::date) END ('2008-04-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_4       | range         |              1 |             4 |                 4 |                     | '2008-04-01'::date  | t                       | '2008-05-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_4 START ('2008-04-01'::date) END ('2008-05-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_5       | range         |              1 |             5 |                 5 |                     | '2008-05-01'::date  | t                       | '2008-06-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_5 START ('2008-05-01'::date) END ('2008-06-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_6       | range         |              1 |             6 |                 6 |                     | '2008-06-01'::date  | t                       | '2008-07-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_6 START ('2008-06-01'::date) END ('2008-07-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_7       | range         |              1 |             7 |                 7 |                     | '2008-07-01'::date  | t                       | '2008-08-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_7 START ('2008-07-01'::date) END ('2008-08-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_8       | range         |              1 |             8 |                 8 |                     | '2008-08-01'::date  | t                       | '2008-09-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_8 START ('2008-08-01'::date) END ('2008-09-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_9       | range         |              1 |             9 |                 9 |                     | '2008-09-01'::date  | t                       | '2008-10-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_9 START ('2008-09-01'::date) END ('2008-10-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_10      | range         |              1 |            10 |                10 |                     | '2008-10-01'::date  | t                       | '2008-11-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_10 START ('2008-10-01'::date) END ('2008-11-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_11      | range         |              1 |            11 |                11 |                     | '2008-11-01'::date  | t                       | '2008-12-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_11 START ('2008-11-01'::date) END ('2008-12-01'::date) EVERY ('1 mon'::interval)
 qa147      | sales     | usam1_12      | range         |              1 |            12 |                12 |                     | '2008-12-01'::date  | t                       | '2009-01-01'::date | f                     | '1 mon'::interval    | f                  | SUBPARTITION usam1_12 START ('2008-12-01'::date) END ('2009-01-01'::date) EVERY ('1 mon'::interval)
(12 rows)

drop schema qa147 cascade;
DROP SCHEMA
select * from pg_partition_templates where schemaname='qa147' and tablename='sales';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault | partitionboundary 
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+-------------------
(0 rows)

set gp_autostats_mode=on_change;
SET
set gp_autostats_on_change_threshold=100;
SET
create table mpp5427 (i int) partition by range (i) (start(1) end(10000000) every(100000));
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
insert into mpp5427 select i from generate_series(1, 100) i;
INSERT 0 100
select * from pg_stats where tablename like 'mpp5427%';
 schemaname | tablename | attname | null_frac | avg_width | n_distinct | most_common_vals | most_common_freqs | histogram_bounds | correlation 
------------+-----------+---------+-----------+-----------+------------+------------------+-------------------+------------------+-------------
(0 rows)

insert into mpp5427 select i from generate_series(1, 100000) i;
INSERT 0 100000
select * from pg_stats where tablename like 'mpp5427%';
 schemaname | tablename | attname | null_frac | avg_width | n_distinct | most_common_vals | most_common_freqs | histogram_bounds | correlation 
------------+-----------+---------+-----------+-----------+------------+------------------+-------------------+------------------+-------------
(0 rows)

insert into mpp5427 select i from generate_series(1, 1000000) i;
INSERT 0 1000000
select * from pg_stats where tablename like 'mpp5427%';
 schemaname | tablename | attname | null_frac | avg_width | n_distinct | most_common_vals | most_common_freqs | histogram_bounds | correlation 
------------+-----------+---------+-----------+-----------+------------+------------------+-------------------+------------------+-------------
(0 rows)

truncate table mpp5427;
TRUNCATE TABLE
alter table mpp5427 add default partition default_part;
ALTER TABLE
insert into mpp5427 select i from generate_series(1, 100) i;
INSERT 0 100
select * from pg_stats where tablename like 'mpp5427%';
 schemaname | tablename | attname | null_frac | avg_width | n_distinct | most_common_vals | most_common_freqs | histogram_bounds | correlation 
------------+-----------+---------+-----------+-----------+------------+------------------+-------------------+------------------+-------------
(0 rows)

insert into mpp5427 select i from generate_series(1, 100000) i;
INSERT 0 100000
select * from pg_stats where tablename like 'mpp5427%';
 schemaname | tablename | attname | null_frac | avg_width | n_distinct | most_common_vals | most_common_freqs | histogram_bounds | correlation 
------------+-----------+---------+-----------+-----------+------------+------------------+-------------------+------------------+-------------
(0 rows)

insert into mpp5427 select i from generate_series(1, 1000000) i;
INSERT 0 1000000
select * from pg_stats where tablename like 'mpp5427%';
 schemaname | tablename | attname | null_frac | avg_width | n_distinct | most_common_vals | most_common_freqs | histogram_bounds | correlation 
------------+-----------+---------+-----------+-----------+------------+------------------+-------------------+------------------+-------------
(0 rows)

insert into mpp5427 select i from generate_series(10000000, 15000000) i;
INSERT 0 5000001
select * from pg_stats where tablename like 'mpp5427%';
 schemaname | tablename | attname | null_frac | avg_width | n_distinct | most_common_vals | most_common_freqs | histogram_bounds | correlation 
------------+-----------+---------+-----------+-----------+------------+------------------+-------------------+------------------+-------------
(0 rows)

drop table mpp5427;
DROP TABLE
create table mpp5524 (a int, b int, c int, d int) partition by range(d) (start(1) end(20) every(1));
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
alter table mpp5524 alter partition for(rank(1)) set distributed by (b);
ERROR:  cannot ALTER PARTITION ... SET DISTRIBUTED BY for partition for rank 1 of relation "mpp5524"
HINT:  distribution policy of partition must match parent
alter table mpp5524 alter partition for(rank(2)) set distributed by (c);
ERROR:  cannot ALTER PARTITION ... SET DISTRIBUTED BY for partition for rank 2 of relation "mpp5524"
HINT:  distribution policy of partition must match parent
insert into mpp5524 select i, i+1, i+2, i+3 from generate_series(1, 10) i;
INSERT 0 10
drop table mpp5524;
DROP TABLE
CREATE TABLE sg_cal_event_silvertail_hour (
caldt date NOT NULL,
calhr smallint NOT NULL,
ip character varying(128),
transactionid character varying(32),
transactiontime timestamp(2) without time zone
)
WITH (appendonly=true, compresslevel=5)
distributed by (ip) PARTITION BY RANGE(transactiontime)
(
PARTITION "P2009041607"
START ('2009-04-16 07:00:00'::timestamp without time zone)
END ('2009-04-16 08:00:00'::timestamp without time zone),
PARTITION "P2009041608"
START ('2009-04-16 08:00:00'::timestamp without time zone)
END ('2009-04-16 09:00:00'::timestamp without time zone),
DEFAULT PARTITION st_default
);
CREATE TABLE
ALTER TABLE SG_CAL_EVENT_SILVERTAIL_HOUR SPLIT DEFAULT PARTITION
START ('2009-04-29 07:00:00'::timestamp) INCLUSIVE END ('2009-04-29
08:00:00'::timestamp) EXCLUSIVE INTO ( PARTITION P2009042907 ,
PARTITION st_default );
ALTER TABLE
select * from pg_partitions where tablename='sg_cal_event_silvertail_hour';
 schemaname |          tablename           | partitionschemaname |               partitiontablename               | partitionname | parentpartitiontablename | parentpartitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues |                partitionrangestart                 | partitionstartinclusive |                 partitionrangeend                  | partitionendinclusive | partitioneveryclause | partitionisdefault |                                                                                  partitionboundary                                                                                  | parenttablespace | partitiontablespace 
------------+------------------------------+---------------------+------------------------------------------------+---------------+--------------------------+---------------------+---------------+----------------+---------------+-------------------+---------------------+----------------------------------------------------+-------------------------+----------------------------------------------------+-----------------------+----------------------+--------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------+---------------------
 partition_ddl3     | sg_cal_event_silvertail_hour | partition_ddl3              | sg_cal_event_silvertail_hour_1_prt_st_default  | st_default    |                          |                     | range         |              0 |               |                 0 |                     |                                                    | f                       |                                                    | f                     |                      | t                  | DEFAULT PARTITION st_default  WITH (appendonly=true, compresslevel=5)                                                                                                               | pg_default       | pg_default
 partition_ddl3     | sg_cal_event_silvertail_hour | partition_ddl3              | sg_cal_event_silvertail_hour_1_prt_P2009041607 | P2009041607   |                          |                     | range         |              0 |             1 |                 2 |                     | '2009-04-16 07:00:00'::timestamp without time zone | t                       | '2009-04-16 08:00:00'::timestamp without time zone | f                     |                      | f                  | PARTITION "P2009041607" START ('2009-04-16 07:00:00'::timestamp without time zone) END ('2009-04-16 08:00:00'::timestamp without time zone) WITH (appendonly=true, compresslevel=5) | pg_default       | pg_default
 partition_ddl3     | sg_cal_event_silvertail_hour | partition_ddl3              | sg_cal_event_silvertail_hour_1_prt_P2009041608 | P2009041608   |                          |                     | range         |              0 |             2 |                 3 |                     | '2009-04-16 08:00:00'::timestamp without time zone | t                       | '2009-04-16 09:00:00'::timestamp without time zone | f                     |                      | f                  | PARTITION "P2009041608" START ('2009-04-16 08:00:00'::timestamp without time zone) END ('2009-04-16 09:00:00'::timestamp without time zone) WITH (appendonly=true, compresslevel=5) | pg_default       | pg_default
 partition_ddl3     | sg_cal_event_silvertail_hour | partition_ddl3              | sg_cal_event_silvertail_hour_1_prt_p2009042907 | p2009042907   |                          |                     | range         |              0 |             3 |                 4 |                     | '2009-04-29 07:00:00'::timestamp without time zone | t                       | '2009-04-29 08:00:00'::timestamp without time zone | f                     |                      | f                  | PARTITION p2009042907 START ('2009-04-29 07:00:00'::timestamp without time zone) END ('2009-04-29 08:00:00'::timestamp without time zone) WITH (appendonly=true, compresslevel=5)   | pg_default       | pg_default
(4 rows)

drop table sg_cal_event_silvertail_hour;
DROP TABLE
CREATE TABLE fff_main (id int, rank int, year int, gender char(1), count int)
 partition by range (year) ( start (2001) end (2006) every ('1'));
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
alter table fff_main_1_prt_1 drop oids;
ERROR:  can't drop a column from "fff_main_1_prt_1"; it is part of a partitioned table
HINT:  You may be able to perform the operation on the partitioned table as a whole.
alter table fff_main_1_prt_1 no inherit fff_main;
ERROR:  can't alter inheritance on "fff_main_1_prt_1"; it is a partitioned table or part thereof
alter table fff_main_1_prt_1 drop column rank;
ERROR:  can't drop a column from "fff_main_1_prt_1"; it is part of a partitioned table
HINT:  You may be able to perform the operation on the partitioned table as a whole.
alter table fff_main_1_prt_1 add partition;
ERROR:  can't alter "fff_main_1_prt_1"; it is part of a partitioned table
HINT:  You may be able to perform the operation on the partitioned table as a whole.
alter table fff_main_1_prt_1 drop partition;
ERROR:  can't alter "fff_main_1_prt_1"; it is part of a partitioned table
HINT:  You may be able to perform the operation on the partitioned table as a whole.
alter table fff_main_1_prt_1 add column c int;
ERROR:  can't add a column to "fff_main_1_prt_1"; it is part of a partitioned table
HINT:  You may be able to perform the operation on the partitioned table as a whole.
create table fff_main2 (like fff_main);
CREATE TABLE
alter table fff_main_1_prt_1 inherit fff_main2;
ERROR:  can't alter inheritance on "fff_main_1_prt_1"; it is a partitioned table or part thereof
alter table fff_main_1_prt_1 alter column i type bigint;
ERROR:  can't alter a column datatype of "fff_main_1_prt_1"; it is part of a partitioned table
HINT:  You may be able to perform the operation on the partitioned table as a whole.
alter table fff_main_1_prt_1 set without oids;
ERROR:  can't alter the oid setting of "fff_main_1_prt_1"; it is part of a partitioned table
HINT:  You may be able to perform the operation on the partitioned table as a whole.
alter table fff_main_1_prt_1 drop constraint fff_main_1_prt_1_check;
ERROR:  can't drop a constraint from "fff_main_1_prt_1"; it is part of a partitioned table
HINT:  You may be able to perform the operation on the partitioned table as a whole.
alter table fff_main_1_prt_1 split partition def at ('2009');
ERROR:  can't split parts of "fff_main_1_prt_1"; it is part of a partitioned table
HINT:  You may be able to perform the operation on the partitioned table as a whole.
alter table fff_main add default partition def;
ALTER TABLE
alter table fff_main_1_prt_1 split partition def at ('2009');
ERROR:  can't split parts of "fff_main_1_prt_1"; it is part of a partitioned table
HINT:  You may be able to perform the operation on the partitioned table as a whole.
alter table fff_main_1_prt_1 exchange partition aa  with table fff_main_1_prt_2 without validation;
ERROR:  can't exchange a part into "fff_main_1_prt_1"; it is part of a partitioned table
HINT:  You may be able to perform the operation on the partitioned table as a whole.
alter table fff_main add partition aa start ('2008') end ('2009');
ERROR:  cannot add RANGE partition "aa" to relation "fff_main" with DEFAULT partition "def"
HINT:  need to SPLIT partition "def"
alter table fff_main add partition bb start ('2009') end ('2010');
ERROR:  cannot add RANGE partition "bb" to relation "fff_main" with DEFAULT partition "def"
HINT:  need to SPLIT partition "def"
alter table fff_main_1_prt_1 add partition cc start ('2010') end ('2011');
ERROR:  can't alter "fff_main_1_prt_1"; it is part of a partitioned table
HINT:  You may be able to perform the operation on the partitioned table as a whole.
drop table fff_main, fff_main2;
DROP TABLE
create table mpp5878 (a int, b char, d char)
partition by list (b,d)
(values (('a','b'),('c','d')),
values (('e','f'),('g','h')));
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
select partitionlistvalues from pg_partitions where tablename like 'mpp5878';
                partitionlistvalues                 
----------------------------------------------------
 'a'::bpchar, 'b'::bpchar, 'c'::bpchar, 'd'::bpchar
 'e'::bpchar, 'f'::bpchar, 'g'::bpchar, 'h'::bpchar
(2 rows)

select partitionboundary from pg_partitions where tablename like 'mpp5878';
        partitionboundary         
----------------------------------
 VALUES( ('a', 'b'),  ('c', 'd'))
 VALUES( ('e', 'f'),  ('g', 'h'))
(2 rows)

CREATE TABLE mpp5878a (
    a integer,
    b character(1),
    d character(1)
) distributed by (a) PARTITION BY LIST(b, d) 
          (
          VALUES( ('a', 'b'),  ('c', 'd')), 
          VALUES( ('e', 'f'),  ('g', 'h'))
          );
CREATE TABLE
select partitionlistvalues from pg_partitions where tablename like 'mpp5878a';
                partitionlistvalues                 
----------------------------------------------------
 'a'::bpchar, 'b'::bpchar, 'c'::bpchar, 'd'::bpchar
 'e'::bpchar, 'f'::bpchar, 'g'::bpchar, 'h'::bpchar
(2 rows)

select partitionboundary from pg_partitions where tablename like 'mpp5878a';
        partitionboundary         
----------------------------------
 VALUES( ('a', 'b'),  ('c', 'd'))
 VALUES( ('e', 'f'),  ('g', 'h'))
(2 rows)

drop table mpp5878, mpp5878a;
DROP TABLE
-- start_ignore
-- end_ignore
CREATE TABLE sg_cal_event_silvertail_hour (
caldt date NOT NULL,                                               
calhr smallint NOT NULL,
ip character varying(128),
transactionid character varying(32),
transactiontime timestamp(2) without time zone
)
WITH (appendonly=true, compresslevel=5)
distributed by (ip) PARTITION BY RANGE(transactiontime)
(
PARTITION "P2009041607"
START ('2009-04-16 07:00:00'::timestamp without time zone)
END ('2009-04-16 08:00:00'::timestamp without time zone),
PARTITION "P2009041608"
START ('2009-04-16 08:00:00'::timestamp without time zone)
END ('2009-04-16 09:00:00'::timestamp without time zone),
DEFAULT PARTITION st_default
);
CREATE TABLE
ALTER TABLE SG_CAL_EVENT_SILVERTAIL_HOUR SPLIT DEFAULT PARTITION
START ('2009-04-29 07:00:00'::timestamp) INCLUSIVE END ('2009-04-29
08:00:00'::timestamp) EXCLUSIVE INTO ( PARTITION "P2009042907" ,
PARTITION st_default );
ALTER TABLE
\d sg_cal_event_silvertail_hour*
   Append-Only Table "partition_ddl3.sg_cal_event_silvertail_hour"
     Column      |              Type              | Modifiers 
-----------------+--------------------------------+-----------
 caldt           | date                           | not null
 calhr           | smallint                       | not null
 ip              | character varying(128)         | 
 transactionid   | character varying(32)          | 
 transactiontime | timestamp(2) without time zone | 
Compression Type: zlib
Compression Level: 5
Block Size: 32768
Checksum: f
Number of child tables: 4 (Use \d+ to list them.)
Distributed by: (ip)

Append-Only Table "partition_ddl3.sg_cal_event_silvertail_hour_1_prt_P2009041607"
     Column      |              Type              | Modifiers 
-----------------+--------------------------------+-----------
 caldt           | date                           | not null
 calhr           | smallint                       | not null
 ip              | character varying(128)         | 
 transactionid   | character varying(32)          | 
 transactiontime | timestamp(2) without time zone | 
Compression Type: zlib
Compression Level: 5
Block Size: 32768
Checksum: f
Check constraints:
    "sg_cal_event_silvertail_hour_1_prt_P2009041607_check" CHECK (transactiontime >= '2009-04-16 07:00:00'::timestamp without time zone AND transactiontime < '2009-04-16 08:00:00'::timestamp without time zone)
Inherits: sg_cal_event_silvertail_hour
Distributed by: (ip)

Append-Only Table "partition_ddl3.sg_cal_event_silvertail_hour_1_prt_P2009041608"
     Column      |              Type              | Modifiers 
-----------------+--------------------------------+-----------
 caldt           | date                           | not null
 calhr           | smallint                       | not null
 ip              | character varying(128)         | 
 transactionid   | character varying(32)          | 
 transactiontime | timestamp(2) without time zone | 
Compression Type: zlib
Compression Level: 5
Block Size: 32768
Checksum: f
Check constraints:
    "sg_cal_event_silvertail_hour_1_prt_P2009041608_check" CHECK (transactiontime >= '2009-04-16 08:00:00'::timestamp without time zone AND transactiontime < '2009-04-16 09:00:00'::timestamp without time zone)
Inherits: sg_cal_event_silvertail_hour
Distributed by: (ip)

Append-Only Table "partition_ddl3.sg_cal_event_silvertail_hour_1_prt_P2009042907"
     Column      |              Type              | Modifiers 
-----------------+--------------------------------+-----------
 caldt           | date                           | not null
 calhr           | smallint                       | not null
 ip              | character varying(128)         | 
 transactionid   | character varying(32)          | 
 transactiontime | timestamp(2) without time zone | 
Compression Type: zlib
Compression Level: 5
Block Size: 32768
Checksum: f
Check constraints:
    "sg_cal_event_silvertail_hour_1_prt_P2009042907_check" CHECK (transactiontime >= '2009-04-29 07:00:00'::timestamp without time zone AND transactiontime < '2009-04-29 08:00:00'::timestamp without time zone)
Inherits: sg_cal_event_silvertail_hour
Distributed by: (ip)

Append-Only Table "partition_ddl3.sg_cal_event_silvertail_hour_1_prt_st_default"
     Column      |              Type              | Modifiers 
-----------------+--------------------------------+-----------
 caldt           | date                           | not null
 calhr           | smallint                       | not null
 ip              | character varying(128)         | 
 transactionid   | character varying(32)          | 
 transactiontime | timestamp(2) without time zone | 
Compression Type: zlib
Compression Level: 5
Block Size: 32768
Checksum: f
Inherits: sg_cal_event_silvertail_hour
Distributed by: (ip)

drop table sg_cal_event_silvertail_hour;
DROP TABLE
CREATE TABLE mpp5185 (id int, mpp5185 int, year date, gender
char(1)) DISTRIBUTED BY (id, gender, year)
partition by list (gender)
subpartition by range (year)
subpartition template (
start (date '2001-01-01'),
start (date '2002-01-01'),
start (date '2003-01-01'),
start (date '2004-01-01'),
start (date '2005-01-01')
)
(
partition boys values ('M'),
partition girls values ('F')
);
CREATE TABLE
alter table mpp5185 set subpartition template();
ALTER TABLE
alter table mpp5185 set subpartition template (start (date '2006-01-01') with (appendonly=true));
ALTER TABLE
select * from pg_partition_templates where tablename='mpp5185';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |                 partitionboundary                 
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+---------------------------------------------------
 partition_ddl3     | mpp5185   |               | range         |              1 |             1 |                 1 |                     | '2006-01-01'::date  | t                       |                   | f                     |                      | f                  | START ('2006-01-01'::date) WITH (appendonly=true)
(1 row)

alter table mpp5185 add partition f1 values ('N');
ALTER TABLE
alter table mpp5185 set subpartition template (start (date '2007-01-01') with (appendonly=true, compresslevel=5));
ALTER TABLE
alter table mpp5185 add partition f2 values ('C');
ALTER TABLE
select * from pg_partition_templates where tablename='mpp5185';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |                         partitionboundary                          
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+--------------------------------------------------------------------
 partition_ddl3     | mpp5185   |               | range         |              1 |             1 |                 1 |                     | '2007-01-01'::date  | t                       |                   | f                     |                      | f                  | START ('2007-01-01'::date) WITH (appendonly=true, compresslevel=5)
(1 row)

drop table mpp5185;
DROP TABLE
CREATE TABLE partsupp_def ( ps_partkey int,
ps_suppkey integer, ps_availqty integer,
ps_supplycost numeric, ps_comment character varying(199) )
PARTITION BY RANGE(ps_partkey)
subpartition by range (ps_partkey)
subpartition template
( subpartition sp1 start(0) end (300) every(100),
  default subpartition subdef
)
( partition aa start (0) end (300) every(100),
  default partition def
);
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
alter table partsupp_def set subpartition template();
ALTER TABLE
alter table partsupp_def set subpartition template( subpartition aaa start(400) end (600) every(100) );
ALTER TABLE
select * from pg_partition_templates where tablename='partsupp_def';
 schemaname |  tablename   | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |                  partitionboundary                   
------------+--------------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+------------------------------------------------------
 partition_ddl3     | partsupp_def | aaa_1         | range         |              1 |             1 |                 1 |                     | 400                 | t                       | 500               | f                     | 100                  | f                  | SUBPARTITION aaa_1 START (400) END (500) EVERY (100)
 partition_ddl3     | partsupp_def | aaa_2         | range         |              1 |             2 |                 2 |                     | 500                 | t                       | 600               | f                     | 100                  | f                  | SUBPARTITION aaa_2 START (500) END (600) EVERY (100)
(2 rows)

alter table partsup_def add partition f1 start(0) end (300) every(100);
ERROR:  relation "partsup_def" does not exist
CREATE TABLE partsupp_def2 ( ps_partkey int,
ps_suppkey integer, ps_availqty integer,
ps_supplycost numeric, ps_comment character varying(199) )
PARTITION BY RANGE(ps_partkey)
subpartition by range (ps_partkey)
subpartition template
( subpartition sp1 start(0) end (300) every(100),
  default subpartition subdef
)
( partition aa start (0) end (300) every(100)
);
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
alter table partsupp_def2 set subpartition template();
ALTER TABLE
alter table partsupp_def2 set subpartition template( subpartition aaa start(400) end (600) every(100) );
ALTER TABLE
select * from pg_partition_templates where tablename='partsupp_def2';
 schemaname |   tablename   | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |                  partitionboundary                   
------------+---------------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+------------------------------------------------------
 partition_ddl3     | partsupp_def2 | aaa_1         | range         |              1 |             1 |                 1 |                     | 400                 | t                       | 500               | f                     | 100                  | f                  | SUBPARTITION aaa_1 START (400) END (500) EVERY (100)
 partition_ddl3     | partsupp_def2 | aaa_2         | range         |              1 |             2 |                 2 |                     | 500                 | t                       | 600               | f                     | 100                  | f                  | SUBPARTITION aaa_2 START (500) END (600) EVERY (100)
(2 rows)

drop table partsupp_def;
DROP TABLE
drop table partsupp_def2;
DROP TABLE
-- start_ignore
-- end_ignore
create table mpp5431 (c1 date, c2 int) distributed by (c2) partition by range (c1) (partition p20090401 start('2009-04-01 00:00:00'::timestamp) inclusive end ('2009-04-02 00:00:00'::timestamp) exclusive);
CREATE TABLE
alter table mpp5431 add partition p20090402 start('2009-04-02 00:00:00'::timestamp) inclusive end ('2009-04-03 00:00:00'::timestamp) exclusive;
ALTER TABLE
create or replace function mpp5431_f1 () returns void as $$
begin
alter table mpp5431 add partition p20090403 start('2009-04-03 00:00:00'::timestamp) inclusive end ('2009-04-04 00:00:00'::timestamp) exclusive;
end;
$$ LANGUAGE 'plpgsql';
CREATE FUNCTION
select mpp5431_f1();
 mpp5431_f1 
------------
 
(1 row)

drop function mpp5431_f1();
DROP FUNCTION
drop table mpp5431;
DROP TABLE
CREATE TABLE mpp6612 (
        unique1         int4,
        unique2         int4,
        two                     int4,
        four            int4,
        ten                     int4,
        twenty          int4,
        hundred         int4,
        thousand        int4,
        twothousand     int4,
        fivethous       int4,
        tenthous        int4,
        odd                     int4,
        even            int4,
        stringu1        name,
        stringu2        name,
        string4         name
) partition by range (unique1)
( partition aa start (0) end (1000) every (500), default partition default_part );
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
-- Modify any other column
alter table mpp6612 alter column unique2 type char(15);
ALTER TABLE
alter table mpp6612 alter column unique2 type char(10);
ALTER TABLE
-- Show the dsecription
\d mpp6612*
         Table "partition_ddl3.mpp6612"
   Column    |     Type      | Modifiers 
-------------+---------------+-----------
 unique1     | integer       | 
 unique2     | character(10) | 
 two         | integer       | 
 four        | integer       | 
 ten         | integer       | 
 twenty      | integer       | 
 hundred     | integer       | 
 thousand    | integer       | 
 twothousand | integer       | 
 fivethous   | integer       | 
 tenthous    | integer       | 
 odd         | integer       | 
 even        | integer       | 
 stringu1    | name          | 
 stringu2    | name          | 
 string4     | name          | 
Number of child tables: 3 (Use \d+ to list them.)
Distributed by: (unique1)

    Table "partition_ddl3.mpp6612_1_prt_aa_1"
   Column    |     Type      | Modifiers 
-------------+---------------+-----------
 unique1     | integer       | 
 unique2     | character(10) | 
 two         | integer       | 
 four        | integer       | 
 ten         | integer       | 
 twenty      | integer       | 
 hundred     | integer       | 
 thousand    | integer       | 
 twothousand | integer       | 
 fivethous   | integer       | 
 tenthous    | integer       | 
 odd         | integer       | 
 even        | integer       | 
 stringu1    | name          | 
 stringu2    | name          | 
 string4     | name          | 
Check constraints:
    "mpp6612_1_prt_aa_1_check" CHECK (unique1 >= 0 AND unique1 < 500)
Inherits: mpp6612
Distributed by: (unique1)

    Table "partition_ddl3.mpp6612_1_prt_aa_2"
   Column    |     Type      | Modifiers 
-------------+---------------+-----------
 unique1     | integer       | 
 unique2     | character(10) | 
 two         | integer       | 
 four        | integer       | 
 ten         | integer       | 
 twenty      | integer       | 
 hundred     | integer       | 
 thousand    | integer       | 
 twothousand | integer       | 
 fivethous   | integer       | 
 tenthous    | integer       | 
 odd         | integer       | 
 even        | integer       | 
 stringu1    | name          | 
 stringu2    | name          | 
 string4     | name          | 
Check constraints:
    "mpp6612_1_prt_aa_2_check" CHECK (unique1 >= 500 AND unique1 < 1000)
Inherits: mpp6612
Distributed by: (unique1)

Table "partition_ddl3.mpp6612_1_prt_default_part"
   Column    |     Type      | Modifiers 
-------------+---------------+-----------
 unique1     | integer       | 
 unique2     | character(10) | 
 two         | integer       | 
 four        | integer       | 
 ten         | integer       | 
 twenty      | integer       | 
 hundred     | integer       | 
 thousand    | integer       | 
 twothousand | integer       | 
 fivethous   | integer       | 
 tenthous    | integer       | 
 odd         | integer       | 
 even        | integer       | 
 stringu1    | name          | 
 stringu2    | name          | 
 string4     | name          | 
Inherits: mpp6612
Distributed by: (unique1)

-- Modify the partion definition. MPP-3724
-- alter table mpp6612 alter column unique1 type char(10); -- This should fail
-- alter table mpp6612 alter column unique1 type int8;
-- Show the dsecription
-- \d mpp6612*
drop table mpp6612;
DROP TABLE
create table mpp4048 (aaa int, bbb date)
partition by range (bbb)
subpartition by range (bbb)
subpartition by range (bbb)
(
partition y2008 start (date '2008-01-01') end (date '2009-01-01')
(
  subpartition dec start (date '2008-12-01') end (date '2009-01-01') (start (date '2008-12-01') end (date '2009-01-01') every (interval '1 day'))
));
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
drop table mpp4048;
DROP TABLE
-- start_ignore
-- end_ignore
-- This is only for ADD primary key for partition table
-- DROP primary key is still in progress
-- MPP-6573
CREATE TABLE mpp6573 (id int, date date, amt decimal(10,2)) 
DISTRIBUTED BY (id) 
PARTITION BY RANGE (date) 
( START (date '2008-01-01') INCLUSIVE 
   END (date '2008-01-03') EXCLUSIVE 
   EVERY (INTERVAL '1 day') );
CREATE TABLE
alter table mpp6573 add primary key (id, date) ;
ALTER TABLE
\d mpp6573*
       Table "partition_ddl3.mpp6573"
 Column |     Type      | Modifiers 
--------+---------------+-----------
 id     | integer       | not null
 date   | date          | not null
 amt    | numeric(10,2) | 
Indexes:
    "mpp6573_pkey" PRIMARY KEY, btree (id, date)
Number of child tables: 2 (Use \d+ to list them.)
Distributed by: (id)

   Table "partition_ddl3.mpp6573_1_prt_1"
 Column |     Type      | Modifiers 
--------+---------------+-----------
 id     | integer       | not null
 date   | date          | not null
 amt    | numeric(10,2) | 
Indexes:
    "mpp6573_1_prt_1_pkey" PRIMARY KEY, btree (id, date)
Check constraints:
    "mpp6573_1_prt_1_check" CHECK (date >= '2008-01-01'::date AND date < '2008-01-02'::date)
Inherits: mpp6573
Distributed by: (id)

Index "partition_ddl3.mpp6573_1_prt_1_pkey"
 Column |  Type   | Definition 
--------+---------+------------
 id     | integer | id
 date   | date    | date
primary key, btree, for table "partition_ddl3.mpp6573_1_prt_1"

   Table "partition_ddl3.mpp6573_1_prt_2"
 Column |     Type      | Modifiers 
--------+---------------+-----------
 id     | integer       | not null
 date   | date          | not null
 amt    | numeric(10,2) | 
Indexes:
    "mpp6573_1_prt_2_pkey" PRIMARY KEY, btree (id, date)
Check constraints:
    "mpp6573_1_prt_2_check" CHECK (date >= '2008-01-02'::date AND date < '2008-01-03'::date)
Inherits: mpp6573
Distributed by: (id)

Index "partition_ddl3.mpp6573_1_prt_2_pkey"
 Column |  Type   | Definition 
--------+---------+------------
 id     | integer | id
 date   | date    | date
primary key, btree, for table "partition_ddl3.mpp6573_1_prt_2"

  Index "partition_ddl3.mpp6573_pkey"
 Column |  Type   | Definition 
--------+---------+------------
 id     | integer | id
 date   | date    | date
primary key, btree, for table "partition_ddl3.mpp6573"

drop table mpp6573;
DROP TABLE
-- MPP-6724
create table mpp6724 ( c1 int, dt DATE, c2 varchar, PRIMARY KEY ( c1,dt ) ) distributed by (c1) partition by range ( dt ) ( start ( date '2009-01-01' ) inclusive end ( date '2009-01-03' ) EXCLUSIVE EVERY ( INTERVAL '1 day' ) );
CREATE TABLE
insert into mpp6724 values ( 1,'2009-01-01','One'), (2,'2009-01-02','Two'),(3,'2009-01-01','three'), (3,'2009-01-02', 'three`');
INSERT 0 4
insert into mpp6724 values ( 1,'2009-01-01','One'); -- This violate the primary key, expected to fail
ERROR:  duplicate key value violates unique constraint "mpp6724_1_prt_1_pkey"
DETAIL:  Key (c1, dt)=(1, 2009-01-01) already exists.
alter table mpp6724 add partition start ( date '2009-01-03' ) inclusive end ( date '2009-01-04' ) ;
ALTER TABLE
insert into mpp6724 values ( 4,'2009-01-03','Four');
INSERT 0 1
-- Should fail because violates the primary key
insert into mpp6724 values ( 4,'2009-01-03','Four');
ERROR:  duplicate key value violates unique constraint "mpp6724_1_prt_rxxxxxx_pkey"
DETAIL:  Key (c1, dt)=(4, 2009-01-03) already exists.
insert into mpp6724 values ( 4,'2009-01-03','Four');
ERROR:  duplicate key value violates unique constraint "mpp6724_1_prt_rxxxxxx_pkey"
DETAIL:  Key (c1, dt)=(4, 2009-01-03) already exists.
insert into mpp6724 values ( 4,'2009-01-03','Four');
ERROR:  duplicate key value violates unique constraint "mpp6724_1_prt_rxxxxxx_pkey"
DETAIL:  Key (c1, dt)=(4, 2009-01-03) already exists.
insert into mpp6724 values ( 4,'2009-01-03','Four');
ERROR:  duplicate key value violates unique constraint "mpp6724_1_prt_rxxxxxx_pkey"
DETAIL:  Key (c1, dt)=(4, 2009-01-03) already exists.
select c1, dt, count(*) from mpp6724 group by 1,2 having count(*) > 1;
 c1 | dt | count 
----+----+-------
(0 rows)

drop table mpp6724;
DROP TABLE
create table mpp6247_foo ( c1 int, dt date ) distributed by ( c1 ) partition by range (dt) ( start ( date '2009-05-01' ) end ( date '2009-05-11' ) every ( interval '1 day' ) );
CREATE TABLE
create table mpp6247_bar (like mpp6247_foo);
CREATE TABLE
explain delete from mpp6247_foo using mpp6247_bar where mpp6247_foo.c1 = mpp6247_bar.c1 and mpp6247_foo.dt = '2009-05-03';
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Delete (slice0; segments: 2)  (rows=2 width=10)
   ->  Hash Join  (cost=0.01..0.05 rows=2 width=10)
         Hash Cond: partition_ddl3.mpp6247_foo.c1 = mpp6247_bar.c1
         ->  Seq Scan on mpp6247_foo_1_prt_3 mpp6247_foo  (cost=0.00..0.00 rows=1 width=14)
               Filter: dt = '2009-05-03'::date
         ->  Hash  (cost=0.00..0.00 rows=1 width=4)
               ->  Seq Scan on mpp6247_bar  (cost=0.00..0.00 rows=1 width=4)
(7 rows)

drop table mpp6247_bar;
DROP TABLE
drop table mpp6247_foo;
DROP TABLE
-- --------------------------------------------------------------------------------------
-- COPYRIGHT: Copyright (c) 2010, Greenplum.  All rights reserved.
-- PURPOSE: test partition elimination, MPP-7891
--
-- AUTHOR: Lyublena Antova
--
-- WARNINGS (if applicable):
-- ALGORITHM (optional):
-- LAST MODIFIED:
--      - 2010/02/04: initial version
-- --------------------------------------------------------------------------------------
-- cleanup
-- start_ignore
drop table if exists r_part;
DROP TABLE
drop table if exists r_co;
DROP TABLE
deallocate f1;
psql:/path/sql_file:1: ERROR:  prepared statement "f1" does not exist
deallocate f2;
psql:/path/sql_file:1: ERROR:  prepared statement "f2" does not exist
deallocate f3;
psql:/path/sql_file:1: ERROR:  prepared statement "f3" does not exist
create table r_part(a int, b int) partition by range(a) (start (1) end(10) every(1));
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
create table r_co(a int, b int) with (orientation=column, appendonly=true) partition by range(a) (start (1) end(10) every(1)) ;
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
-- end_ignore
insert into r_part values (1,1), (2,2), (3,3);
INSERT 0 3
select * from r_part order by a,b;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
(3 rows)

analyze r_part;
ANALYZE
explain select * from r_part r1, r_part r2 where r1.a=1; -- should eliminate partitions in the r1 copy of r_part
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=1.04..10.43 rows=5 width=16)
   ->  Nested Loop  (cost=1.04..10.43 rows=5 width=16)
         ->  Append  (cost=0.00..9.03 rows=5 width=8)
               ->  Seq Scan on r_part_1_prt_1 r2  (cost=0.00..1.01 rows=1 width=8)
               ->  Seq Scan on r_part_1_prt_2 r2  (cost=0.00..1.01 rows=1 width=8)
               ->  Seq Scan on r_part_1_prt_3 r2  (cost=0.00..1.01 rows=1 width=8)
               ->  Seq Scan on r_part_1_prt_4 r2  (cost=0.00..1.00 rows=1 width=8)
               ->  Seq Scan on r_part_1_prt_5 r2  (cost=0.00..1.00 rows=1 width=8)
               ->  Seq Scan on r_part_1_prt_6 r2  (cost=0.00..1.00 rows=1 width=8)
               ->  Seq Scan on r_part_1_prt_7 r2  (cost=0.00..1.00 rows=1 width=8)
               ->  Seq Scan on r_part_1_prt_8 r2  (cost=0.00..1.00 rows=1 width=8)
               ->  Seq Scan on r_part_1_prt_9 r2  (cost=0.00..1.00 rows=1 width=8)
         ->  Materialize  (cost=1.04..1.06 rows=1 width=8)
               ->  Broadcast Motion 1:2  (slice1; segments: 1)  (cost=0.00..1.04 rows=2 width=8)
                     ->  Append  (cost=0.00..1.01 rows=1 width=8)
                           ->  Seq Scan on r_part_1_prt_1 r1  (cost=0.00..1.01 rows=1 width=8)
                                 Filter: a = 1
(17 rows)

explain select * from r_part where a in (1,2); -- should eliminate partitions
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2.02 rows=1 width=8)
   ->  Append  (cost=0.00..2.02 rows=1 width=8)
         ->  Seq Scan on r_part_1_prt_1 r_part  (cost=0.00..1.01 rows=1 width=8)
               Filter: a = ANY ('{1,2}'::integer[])
         ->  Seq Scan on r_part_1_prt_2 r_part  (cost=0.00..1.01 rows=1 width=8)
               Filter: a = ANY ('{1,2}'::integer[])
(6 rows)

/*
	test partition elimination in prepared statements
*/
prepare f1(int) as select * from r_part where a = 1 order by a,b; 
PREPARE
prepare f2(int) as select * from r_part where a = $1 order by a,b;
PREPARE
execute f1(1); 
 a | b 
---+---
 1 | 1
(1 row)

execute f2(1); 
 a | b 
---+---
 1 | 1
(1 row)

execute f2(2); 
 a | b 
---+---
 2 | 2
(1 row)

explain select * from r_part where a = 1 order by a,b; -- should eliminate partitions
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..1.03 rows=1 width=8)
   Merge Key: a, b
   ->  Sort  (cost=1.02..1.03 rows=1 width=8)
         Sort Key: partition_ddl3.r_part.a, partition_ddl3.r_part.b
         ->  Append  (cost=0.00..1.01 rows=1 width=8)
               ->  Seq Scan on r_part_1_prt_1 r_part  (cost=0.00..1.01 rows=1 width=8)
                     Filter: a = 1
(7 rows)

--force_explain
explain execute f1(1); -- should eliminate partitions 
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..1.03 rows=1 width=8)
   Merge Key: a, b
   ->  Sort  (cost=1.02..1.03 rows=1 width=8)
         Sort Key: partition_ddl3.r_part.a, partition_ddl3.r_part.b
         ->  Append  (cost=0.00..1.01 rows=1 width=8)
               ->  Seq Scan on r_part_1_prt_1 r_part  (cost=0.00..1.01 rows=1 width=8)
                     Filter: a = 1
(7 rows)

--force_explain
explain execute f2(2); -- should eliminate partitions
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..1.03 rows=1 width=8)
   Merge Key: a, b
   ->  Sort  (cost=1.02..1.03 rows=1 width=8)
         Sort Key: partition_ddl3.r_part.a, partition_ddl3.r_part.b
         ->  Append  (cost=0.00..1.01 rows=1 width=8)
               ->  Seq Scan on r_part_1_prt_2 r_part  (cost=0.00..1.01 rows=1 width=8)
                     Filter: a = 2
(7 rows)

/*
	test partition elimination on CO tables
*/
insert into r_co values (1,1), (2,2), (3,3);
INSERT 0 3
analyze r_co; 
ANALYZE
explain select * from r_co where a=2; -- should eliminate partitions
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=0.00..1.01 rows=1 width=8)
   ->  Append  (cost=0.00..1.01 rows=1 width=8)
         ->  Append-only Columnar Scan on r_co_1_prt_2 r_co  (cost=0.00..1.01 rows=1 width=8)
               Filter: a = 2
(4 rows)

/*
	test partition elimination in prepared statements on CO tables
*/
prepare f3(int) as select * from r_co where a = $1 order by a,b; 
PREPARE
--force_explain
explain execute f3(2); -- should eliminate partitions
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..1.03 rows=1 width=8)
   Merge Key: a, b
   ->  Sort  (cost=1.02..1.03 rows=1 width=8)
         Sort Key: partition_ddl3.r_co.a, partition_ddl3.r_co.b
         ->  Append  (cost=0.00..1.01 rows=1 width=8)
               ->  Append-only Columnar Scan on r_co_1_prt_2 r_co  (cost=0.00..1.01 rows=1 width=8)
                     Filter: a = 2
(7 rows)

-- start_ignore
drop table r_part;
DROP TABLE
drop table r_co;
DROP TABLE
deallocate f1;
DEALLOCATE
deallocate f2;
DEALLOCATE
deallocate f3;
DEALLOCATE
-- end_ignore
-- --------------------------------------------------------------------------------------
-- COPYRIGHT: Copyright (c) 2010, Greenplum.  All rights reserved.
-- PURPOSE: test partition elimination, MPP-7891
--
-- AUTHOR: Lyublena Antova
--
-- WARNINGS (if applicable):
-- ALGORITHM (optional):
-- LAST MODIFIED:
--      - 2010/02/04: initial version
-- --------------------------------------------------------------------------------------
-- start_ignore
drop table if exists fact;
DROP TABLE
deallocate f1;
psql:/path/sql_file:1: ERROR:  prepared statement "f1" does not exist
create table fact(x int, dd date, dt text) distributed by (x) partition by range (dd) ( start('2008-01-01') end ('2320-01-01') every(interval '100 years'));
CREATE TABLE
-- end_ignore
analyze fact;
ANALYZE
select '2009-01-02'::date = to_date('2009-01-02','YYYY-MM-DD'); -- ensure that both are in fact equal
 ?column? 
----------
 t
(1 row)

explain select * from fact where dd < '2009-01-02'::date; -- partitions eliminated
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..6.84 rows=52 width=40)
   ->  Append  (cost=0.00..6.84 rows=52 width=40)
         ->  Seq Scan on fact_1_prt_1 fact  (cost=0.00..6.84 rows=52 width=40)
               Filter: dd < '2009-01-02'::date
(4 rows)

explain select * from fact where dd < to_date('2009-01-02','YYYY-MM-DD'); -- partitions eliminated
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..6.84 rows=52 width=40)
   ->  Append  (cost=0.00..6.84 rows=52 width=40)
         ->  Seq Scan on fact_1_prt_1 fact  (cost=0.00..6.84 rows=52 width=40)
               Filter: dd < '2009-01-02'::date
(4 rows)

explain select * from fact where dd < current_date; --partitions eliminated
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..6.84 rows=52 width=40)
   ->  Append  (cost=0.00..6.84 rows=52 width=40)
         ->  Seq Scan on fact_1_prt_1 fact  (cost=0.00..6.84 rows=52 width=40)
               Filter: dd < '2010-05-03'::date
(4 rows)

-- test partition elimination in prepared statements
prepare f1(date) as select * from fact where dd < $1;
PREPARE
-- force_explain
explain execute f1('2009-01-02'::date); -- should eliminate partitions
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..6.84 rows=52 width=40)
   ->  Append  (cost=0.00..6.84 rows=52 width=40)
         ->  Seq Scan on fact_1_prt_1 fact  (cost=0.00..6.84 rows=52 width=40)
               Filter: dd < '2009-01-02'::date
(4 rows)

-- force_explain
explain execute f1(to_date('2009-01-02'::date,'YYYY-MM-DD')); -- should eliminate partitions
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..6.84 rows=52 width=40)
   ->  Append  (cost=0.00..6.84 rows=52 width=40)
         ->  Seq Scan on fact_1_prt_1 fact  (cost=0.00..6.84 rows=52 width=40)
               Filter: dd < '2009-01-02'::date
(4 rows)

-- start_ignore
drop table fact;
DROP TABLE
deallocate f1;
DEALLOCATE
-- end_ignore
-- Test for partition cleanup
-- Johnny Soedomo
-- start_ignore
drop schema partition_999 cascade;
psql:/path/sql_file:1: ERROR:  schema "partition_999" does not exist
create schema partition_999;
CREATE SCHEMA
set search_path=partition_ddl3,partition_999;
SET
-- end_ignore
create table partition_cleanup1 (a int, b int, c int, d int, e int, f int, g int, h int, i int, j int, k int, l int, m int, n int, o int, p int, q int, r int, s int, t int, u int, v int, w int, x int, y int, z int)
partition by range (a)
( partition aa start (1) end (10) every (1) );
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
CREATE TABLE partition_999.partition_cleanup2(a int, b int, c int, d int, e int, f int, g int, h int, i int, j int, k int, l int, m int, n int, o int, p int, q int, r int, s int, t int, u int, v int, w int, x int, y int, z int)
partition by range (a)
subpartition by range (b) subpartition template ( start (1) end (10) every (1))
( partition aa start (1) end (10) every (1) );
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
drop table partition_cleanup1;
DROP TABLE
drop schema partition_999 cascade;
DROP SCHEMA
-- These should be empty
select 'pg_partition_columns', count(*) from pg_partition_columns where tablename='partition_cleanup%';
       ?column?       | count 
----------------------+-------
 pg_partition_columns |     0
(1 row)

select 'pg_partitions', count(*) from pg_partitions where tablename='partition_cleanup%';
   ?column?    | count 
---------------+-------
 pg_partitions |     0
(1 row)

select 'pg_partition_templates', count(*) from pg_partition_templates where tablename='partition_cleanup%';
        ?column?        | count 
------------------------+-------
 pg_partition_templates |     0
(1 row)

