SET default_table_access_method=ao_column;
DROP TABLE IF EXISTS rep;
NOTICE:  table "rep" does not exist, skipping
DROP TABLE IF EXISTS dis;
NOTICE:  table "dis" does not exist, skipping
CREATE TABLE rep (a int, b int) DISTRIBUTED REPLICATED;
CREATE TABLE dis (a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO rep VALUES (1, 1), (2, 2), (3, NULL), (NULL, 4);
INSERT INTO dis VALUES (1, 1), (2, 2);
EXPLAIN SELECT rep.a, rep.b, dis.a, dis.b FROM rep LEFT JOIN dis ON rep.a = dis.a ORDER BY rep.a;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Vec Gather Motion 3:1  (slice1; segments: 3)  (cost=392919.37..497939.84 rows=7413210 width=16)
   Merge Key: rep.a
   ->  Vec Sort  (cost=392919.37..399097.04 rows=2471070 width=16)
         Sort Key: rep.a
         ->  Vec Hash Left Join  (cost=679.75..130532.45 rows=2471070 width=16)
               Hash Cond: (rep.a = dis.a)
               ->  Vec Redistribute Motion 1:3  (slice2; segments: 1)  (cost=0.00..2109.00 rows=28700 width=8)
                     Hash Key: rep.a
                     ->  Vec Seq Scan on rep  (cost=0.00..961.00 rows=86100 width=8)
               ->  Vec Hash  (cost=321.00..321.00 rows=28700 width=8)
                     ->  Vec Seq Scan on dis  (cost=0.00..321.00 rows=28700 width=8)
 Optimizer: Postgres query optimizer
(12 rows)

SELECT rep.a, rep.b, dis.a, dis.b FROM rep LEFT JOIN dis ON rep.a = dis.a ORDER BY rep.a;
 a | b | a | b 
---+---+---+---
 1 | 1 | 1 | 1
 2 | 2 | 2 | 2
 3 |   |   |  
   | 4 |   |  
(4 rows)

INSERT INTO rep SELECT generate_series(1, 10000), generate_series(1, 10000);
INSERT INTO dis SELECT generate_series(1, 3000), generate_series(1, 3000);
EXPLAIN SELECT count(*) FROM rep LEFT JOIN dis ON rep.a = dis.a;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Vec Finalize Vec Aggregate  (cost=136710.18..136710.19 rows=1 width=8)
   ->  Vec Gather Motion 3:1  (slice1; segments: 3)  (cost=136710.12..136710.18 rows=3 width=8)
         ->  Vec Partial Vec Aggregate  (cost=136710.12..136710.14 rows=1 width=8)
               ->  Vec Hash Left Join  (cost=679.75..130532.45 rows=2471070 width=0)
                     Hash Cond: (rep.a = dis.a)
                     ->  Vec Redistribute Motion 1:3  (slice2; segments: 1)  (cost=0.00..2109.00 rows=28700 width=4)
                           Hash Key: rep.a
                           ->  Vec Seq Scan on rep  (cost=0.00..961.00 rows=86100 width=4)
                     ->  Vec Hash  (cost=321.00..321.00 rows=28700 width=4)
                           ->  Vec Seq Scan on dis  (cost=0.00..321.00 rows=28700 width=4)
 Optimizer: Postgres query optimizer
(11 rows)

SELECT count(*) FROM rep LEFT JOIN dis ON rep.a = dis.a;
 count 
-------
 10008
(1 row)

DROP TABLE rep;
DROP TABLE dis;
